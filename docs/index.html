<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VaultFlow</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='16' fill='%230f172a'/%3E%3Ctext x='50%25' y='54%25' text-anchor='middle' font-family='Space Grotesk,Arial' font-size='28' fill='%23ffffff'%3EVF%3C/text%3E%3C/svg%3E" />
  
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap");
    :root {
      color-scheme: light;
      --bg: #0f172a;
      --panel: #ffffff;
      --muted: #6b7280;
      --text: #0b1224;
      --border: #e5e7eb;
      --primary: #0f172a;
      --accent: #0ea5e9;
      --success: #0ea76b;
      --danger: #ef4444;
      --shadow: 0 16px 60px rgba(15, 23, 42, 0.12);
      --soft: #f8fafc;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1000px at 15% 20%, #e8f4ff, transparent),
        radial-gradient(900px at 80% 0%, #e2f5ed, transparent),
        #f8fafc;
      color: var(--text);
      min-height: 100vh;
    }
    h1,h2,h3 { margin: 0; }
    p { margin: 0; }
    .muted { color: var(--muted); }
    .err { color: var(--danger); white-space: pre-wrap; margin-top: 6px; }
    .ok { color: var(--success); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
    .app-shell {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 100vh;
      transition: grid-template-columns 0.25s ease;
    }
    .app-shell.collapsed { grid-template-columns: 96px 1fr; }
    .sidebar {
      background: linear-gradient(180deg, #0f172a 0%, #0b1224 100%);
      color: #e2e8f0;
      padding: 22px 20px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      position: sticky;
      top: 0;
      height: 100vh;
      border-right: 1px solid rgba(255, 255, 255, 0.04);
      width: 100%;
      overflow: hidden;
    }
    .brand-row {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: space-between;
    }
    .brand { display: flex; align-items: center; gap: 10px; }
    .logo {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      background: linear-gradient(135deg, #0ea5e9, #22d3ee);
      display: grid;
      place-items: center;
      font-weight: 700;
      color: #0b1224;
      letter-spacing: -0.5px;
      flex-shrink: 0;
    }
    .brand-text { display: grid; gap: 2px; }
    .brand-name { font-weight: 700; letter-spacing: -0.2px; }
    .brand-sub { font-size: 12px; color: #94a3b8; }
    .icon-btn {
      width: 36px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.06);
      color: #e2e8f0;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
      padding: 0;
      line-height: 0;
    }
    .icon-btn svg { width: 18px; height: 18px; display: block; }
    .icon-btn:hover { transform: translateY(-1px); background: rgba(255, 255, 255, 0.1); }
    .nav { display: grid; gap: 6px; }
    .nav-item {
      position: relative;
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: transparent;
      color: #e2e8f0;
      font-weight: 600;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 10px;
      white-space: nowrap;
      overflow: hidden;
    }
    .nav-icon { width: 22px; height: 22px; display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .nav-icon svg { width: 22px; height: 22px; display: block; }
    .nav-label { line-height: 1; }
    .nav-item:hover { background: rgba(255, 255, 255, 0.05); }
    .nav-item.active { border-color: rgba(255, 255, 255, 0.16); background: rgba(255, 255, 255, 0.08); }
    .sidebar-footer {
      margin-top: auto;
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.04);
      display: grid;
      gap: 8px;
    }
    .sidebar-footer .label { font-size: 12px; color: #94a3b8; }
    .sidebar-footer .strong { font-weight: 600; }
    .main-area { background: transparent; }
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 28px 32px 10px;
    }
    .eyebrow { text-transform: uppercase; font-size: 11px; letter-spacing: 0.1em; color: var(--muted); margin-bottom: 6px; }
    .top-actions { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .wallet-select {
      min-width: 120px;
      padding: 9px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      font-weight: 700;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.06);
      cursor: pointer;
      appearance: none;
      background-image: linear-gradient(45deg, transparent 50%, var(--text) 50%), linear-gradient(135deg, var(--text) 50%, transparent 50%);
      background-position: calc(100% - 18px) 50%, calc(100% - 12px) 50%;
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;
      padding-right: 32px;
    }
    .wallet-select:focus { border-color: var(--accent); box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.12); }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f8fafc;
      color: var(--text);
      font-size: 12px;
      font-weight: 600;
    }
    .month-control {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fff;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
      font-weight: 700;
      color: var(--text);
    }
    .month-control .mc-btn { border: none; background: transparent; padding: 6px; border-radius: 10px; cursor: pointer; display: grid; place-items: center; color: var(--text); }
    .month-control .mc-btn:hover { background: #f1f5f9; }
    .month-control .mc-label { white-space: nowrap; cursor: pointer; user-select: none; }
    .month-control .mc-btn svg path { fill: currentColor; }
    .month-input {
      position: absolute;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
      border: 0;
      padding: 0;
      margin: 0;
    }
    .content { padding: 0 32px 32px; display: grid; gap: 16px; }
    .card, .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
    }
    .card { padding: 20px; }
    .panel { padding: 18px 18px 16px; }
    .panel-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 10px; margin-bottom: 14px; }
    .panel-footer { margin-top: 12px; display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .auth-card { display: grid; gap: 12px; border: 1px solid #dbeafe; background: linear-gradient(135deg, #ffffff, #f8fbff); }
    .auth-grid { display: grid; gap: 10px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
    input, select, textarea {
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #fff;
      min-width: 200px;
      font: inherit;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    input:focus, select:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.12); }
    button {
      padding: 11px 14px;
      border-radius: 12px;
      border: 1px solid var(--primary);
      background: var(--primary);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
      letter-spacing: -0.2px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 30px rgba(15, 23, 42, 0.12); }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    button.secondary { background: #fff; color: var(--primary); border-color: var(--border); }
    button.ghost { background: #f8fafc; color: var(--text); border-color: var(--border); }
    button svg { width: 18px; height: 18px; display: block; }
    .app-grid { display: grid; gap: 16px; }
    .page { display: none; }
    .page.active { display: grid; gap: 14px; }
    .filters { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; align-items: end; }
    .kpi-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin: 10px 0 6px; }
    .metric-card { padding: 14px; border-radius: 14px; border: 1px solid var(--border); background: linear-gradient(150deg, #ffffff, #f8fafc); display: grid; gap: 6px; }
    .metric-card .label { font-size: 13px; color: var(--muted); }
    .metric-card .value { font-size: 24px; font-weight: 700; letter-spacing: -0.3px; }
    .metric-card.income { border-color: rgba(14, 167, 107, 0.2); background: linear-gradient(135deg, #f0fdf4, #f8fffb); }
    .metric-card.expense { border-color: rgba(239, 68, 68, 0.2); background: linear-gradient(135deg, #fff1f2, #fff7f7); }
    .metric-card.balance { background: linear-gradient(135deg, #e0f2fe, #f8fbff); border-color: rgba(14, 165, 233, 0.2); }
    .mini-label { font-size: 12px; color: var(--muted); }
    .kpi { padding: 12px; border-radius: 12px; border: 1px solid var(--border); background: #f8fafc; }
    .kpi .label { font-size: 12px; color: var(--muted); }
    .kpi .value { font-size: 18px; font-weight: 700; }
    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 10px; background: var(--soft); border: 1px solid var(--border); font-size: 12px; color: var(--text); }
    .tabs { display: inline-flex; gap: 8px; background: #f8fafc; padding: 6px; border-radius: 12px; border: 1px solid var(--border); margin: 8px 0 4px; }
    .tab { padding: 8px 12px; border-radius: 10px; border: 1px solid transparent; background: transparent; cursor: pointer; font-size: 13px; color: var(--text); font-weight: 600; }
    .tab.active { background: #fff; border-color: var(--border); box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08); }
    .info-note { background: #f8fafc; border: 1px dashed var(--border); border-radius: 12px; padding: 10px 12px; color: var(--muted); margin: 6px 0 2px; }
    .table-shell { border: 1px solid var(--border); border-radius: 14px; overflow: hidden; background: #fff; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 12px 12px; border-bottom: 1px solid var(--border); text-align: left; }
    th { font-size: 12px; letter-spacing: 0.05em; text-transform: uppercase; color: var(--muted); }
    td { font-size: 14px; }
    td .muted { font-size: 12px; }
    .right { text-align: right; }
    .nowrap { white-space: nowrap; }
    .table-shell.large { max-height: 420px; overflow: auto; }
    .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; align-items: end; }
    .chip-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .divider { height: 1px; background: var(--border); margin: 14px 0; }
    .list-panel { padding-bottom: 10px; grid-column: 1 / -1; }
    .stack-list { display: grid; gap: 10px; }
    .move-card { padding: 12px; border-radius: 12px; border: 1px solid var(--border); background: #fff; display: grid; gap: 4px; box-shadow: 0 10px 30px rgba(15, 23, 42, 0.05); }
    .move-meta { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--muted); }
    .move-amount { font-weight: 700; }
    .actions { display: flex; gap: 6px; justify-content: flex-end; }
    .split-panels { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; }
    .mini-panel { padding: 12px; border: 1px solid var(--border); border-radius: 12px; background: #fff; box-shadow: 0 8px 24px rgba(15, 23, 42, 0.06); display: grid; gap: 6px; }
    .mini-panel h3 { margin: 0; font-size: 16px; }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; border: 1px solid var(--border); background: var(--soft); font-size: 12px; font-weight: 600; }
    .section-heading { display: flex; align-items: center; justify-content: space-between; gap: 8px; flex-wrap: wrap; }
    .section-heading h2, .section-heading h3 { margin: 0; }
    .icon-action { border: 1px solid var(--border); background: var(--soft); border-radius: 10px; padding: 8px 10px; cursor: pointer; }
    .icon-action:hover { background: #fff; }
    .optional-block { margin-top: 10px; padding: 12px; border-radius: 12px; border: 1px dashed var(--border); background: #f8fafc; display: grid; gap: 10px; }
    .optional-title { font-size: 12px; text-transform: uppercase; letter-spacing: 0.06em; color: var(--muted); margin: 0; }
    .optional-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; align-items: start; }
    .option-card { border: 1px solid var(--border); border-radius: 12px; background: #fff; box-shadow: 0 4px 12px rgba(15, 23, 42, 0.05); padding: 10px; display: grid; gap: 8px; }
    .option-head { display: flex; align-items: center; gap: 10px; }
    .option-head input[type="checkbox"] { width: 16px; height: 16px; }
    .option-text { display: grid; gap: 2px; }
    .option-label { font-weight: 700; }
    .option-sub { font-size: 12px; color: var(--muted); }
    .option-fields { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; }
    @media (max-width: 1180px) {
      .app-shell { grid-template-columns: 1fr; }
      .sidebar { position: relative; height: auto; border-right: none; }
      .app-grid { grid-template-columns: 1fr; }
      .page.active { grid-template-columns: 1fr; }
    }
    @media (max-width: 720px) {
      .topbar, .panel-header { flex-direction: column; align-items: flex-start; }
      .content { padding: 0 18px 24px; }
      .card, .panel { padding: 16px; }
    }
    .app-shell.collapsed .brand-text,
    .app-shell.collapsed .nav-item .nav-label,
    .app-shell.collapsed .sidebar-footer .label,
    .app-shell.collapsed .sidebar-footer .strong,
    .app-shell.collapsed .sidebar-footer .mono { display: none; }
    .app-shell.collapsed .sidebar { padding: 18px 12px; align-items: center; }
    .app-shell.collapsed .brand-row { justify-content: center; }
    .app-shell.collapsed .brand { justify-content: center; }
    .app-shell.collapsed .icon-btn { width: 36px; height: 36px; }
    .app-shell.collapsed .nav { gap: 10px; width: 64px; margin: 0 auto; }
    .app-shell.collapsed .nav-item {
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 6px;
      text-align: center;
      padding: 10px;
      min-height: 48px;
      width: 64px;
      margin: 0 auto;
    }
    .app-shell.collapsed .nav-item .nav-label { display: none; }
    .app-shell.collapsed .nav-item .nav-icon { margin: 0; }
    .app-shell.collapsed .nav-item::after { content: none; }
  </style>

</head>
<body>
<div class="app-shell">
  <aside class="sidebar">
    <div class="brand-row">
      <div class="brand">
        <div class="logo">VF</div>
        <div class="brand-text">
          <div class="brand-name">VaultFlow</div>
          <div class="brand-sub">Fintech control</div>
        </div>
      </div>
      <button class="icon-btn" id="sidebarToggle" aria-label="Recolher menu" type="button">
        <svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2 6a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM2 18a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM3 11a1 1 0 1 0 0 2h18a1 1 0 1 0 0-2H3Z" fill="#ffffff"/></svg>
      </button>
    </div>

    <nav class="nav">
      <button class="nav-item active" type="button" data-page-target="dashboard">
        <span class="nav-icon" aria-hidden="true"><svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11.499 9.5 11.5 21H6.25a3.25 3.25 0 0 1-3.245-3.065L3 17.752V9.499h8.499Zm1.5 5.999H21.5v2.253a3.25 3.25 0 0 1-3.25 3.25L13 21l-.001-5.502Zm5.252-13a3.25 3.25 0 0 1 3.245 3.065l.005.184-.001 8.251h-8.501L13 2.498h5.251ZM11.5 2.497 11.499 8H3V5.748a3.25 3.25 0 0 1 3.25-3.25h5.25Z" fill="#ffffff"/></svg></span>
        <span class="nav-label">Dashboard</span>
      </button>
      <button class="nav-item" type="button" data-page-target="transactions">
        <span class="nav-icon" aria-hidden="true"><svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6.5 2a1 1 0 0 0-1 1v.112A4.502 4.502 0 0 0 2 7.5v.384a4.883 4.883 0 0 0 2.796 4.415l.704.332v6.14A2.5 2.5 0 0 1 4 16.48v-.845a1 1 0 1 0-2 0v.845a4.502 4.502 0 0 0 3.5 4.389v.124a1 1 0 0 0 2 0v-.124a4.502 4.502 0 0 0 3.5-4.389v-.372A4.875 4.875 0 0 0 8.209 11.7l-.709-.335V5.208A2.5 2.5 0 0 1 9 7.5v.865a1 1 0 1 0 2 0V7.5a4.502 4.502 0 0 0-3.5-4.388V3a1 1 0 0 0-1-1ZM4 7.5a2.5 2.5 0 0 1 1.5-2.292v5.206A2.884 2.884 0 0 1 4 7.884V7.5Zm3.5 11.271v-5.189c.92.501 1.5 1.468 1.5 2.525v.372a2.5 2.5 0 0 1-1.5 2.292Z" fill="#ffffff"/><path d="M15 12c0-.332.015-.657.043-.975H16a1 1 0 0 0 0-2h-.577a7.898 7.898 0 0 1 .979-2.125c.85-1.268 1.916-1.9 2.962-1.9.378 0 .785.117 1.067.31a1 1 0 1 0 1.13-1.65C20.904 3.21 20.09 3 19.364 3c-1.917 0-3.533 1.159-4.623 2.786-.619.923-1.094 2.025-1.39 3.239H12a1 1 0 1 0 0 2h1.036c-.024.32-.036.646-.036.975v.027h-1a1 1 0 1 0 0 2h1.16c.255 1.588.804 3.03 1.58 4.187C15.832 19.84 17.448 21 19.364 21c.697 0 1.535-.174 2.222-.67a1 1 0 0 0-1.172-1.621c-.254.183-.644.291-1.05.291-1.046 0-2.112-.632-2.962-1.9-.553-.824-.98-1.876-1.212-3.075H16a1 1 0 0 0 0-2h-1V12Z" fill="#ffffff"/></svg></span>
        <span class="nav-label">Transações</span>
      </button>
      <button class="nav-item" type="button" data-page-target="categories">
        <span class="nav-icon" aria-hidden="true"><svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2 6a2 2 0 0 1 2-2h1v7.174a6.488 6.488 0 0 0-3 1.636V6ZM16 8.5h-4a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5V9a.5.5 0 0 0-.5-.5Z" fill="#ffffff"/><path d="M12.502 20H20a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6.5v7a6.5 6.5 0 0 1 6.002 9ZM10 9a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v1a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2V9Z" fill="#ffffff"/><path d="M6.5 12a5.5 5.5 0 1 1 0 11 5.5 5.5 0 0 1 0-11Zm.501 8.503V18h2.496a.5.5 0 0 0 0-1H7v-2.5a.5.5 0 1 0-1 0V17H3.496a.5.5 0 0 0 0 1H6v2.503a.5.5 0 1 0 1 0Z" fill="#ffffff"/></svg></span>
        <span class="nav-label">Categorias</span>
      </button>
      <button class="nav-item" type="button" data-page-target="settings">
        <span class="nav-icon" aria-hidden="true"><svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2 6a1 1 0 0 1 1-1h15a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM2 18a1 1 0 0 1 1-1h11a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM3 11a1 1 0 1 0 0 2h18a1 1 0 1 0 0-2H3Z" fill="#ffffff"/></svg></span>
        <span class="nav-label">Preferências</span>
      </button>
    </nav>

    <div class="sidebar-footer">
      <div class="label">Sessão</div>
      <div class="strong" id="me">Aguardando login</div>
      <button id="btnLogout" class="ghost" style="display:none;">Sair</button>
    </div>
  </aside>

  <div class="main-area">
    <header class="topbar">
      <div>
        <p class="eyebrow">VaultFlow</p>
        <h1 id="pageTitle">Dashboard</h1>
      </div>
      <div class="top-actions">
        <select id="walletSelect" class="wallet-select" aria-label="Selecionar carteira"></select>
        <div class="month-control">
          <button class="mc-btn" id="btnMonthPrev" type="button" aria-label="Mês anterior">◀</button>
          <span class="mc-label" id="monthDisplay">Mês atual</span>
          <button class="mc-btn" id="btnMonthNext" type="button" aria-label="Próximo mês">▶</button>
          <button class="mc-btn" id="btnMonthPicker" type="button" aria-label="Escolher mês">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17 4a1 1 0 0 1 1 1v1h1a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h1V5a1 1 0 1 1 2 0v1h6V5a1 1 0 0 1 1-1Zm2 7H5v7h14v-7Zm-4-5v1a1 1 0 1 1-2 0V6h-4v1a1 1 0 1 1-2 0V6H6v2h12V6h-1Zm-8.5 7a1 1 0 1 1 0 2h-1a1 1 0 1 1 0-2h1Zm5 0a1 1 0 1 1 0 2h-1a1 1 0 1 1 0-2h1Zm5 0a1 1 0 1 1 0 2h-1a1 1 0 1 1 0-2h1Z" fill="currentColor"/></svg>
          </button>
        </div>
        <input id="month" type="month" class="month-input" />
      </div>
    </header>

    <main class="content">
      <section class="card auth-card" id="authCard">
        <div class="panel-header" style="margin-bottom:0;">
          <div>
            <p class="eyebrow">Acesso</p>
            <h2>Entrar</h2>
          </div>
          <p id="authStatus" class="muted"></p>
        </div>
        <div class="auth-grid">
          <div class="form-grid">
            <div>
              <label for="email">E-mail</label>
              <input id="email" type="email" placeholder="seu@email.com" autocomplete="username" />
            </div>
            <div>
              <label for="pass">Senha</label>
              <input id="pass" type="password" placeholder="********" autocomplete="current-password" />
            </div>
          </div>
          <div class="row">
            <button id="btnEmail">Entrar com e-mail</button>
            <button id="btnGoogle" class="secondary">Google</button>
          </div>
        </div>
        <p id="authError" class="err"></p>
      </section>

      <section class="app-grid" id="appGrid" style="display:none;">
        <section class="page active" id="page-dashboard">
          <p class="err" id="appError"></p>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Carteira</p>
                <h2>Dashboard</h2>
              </div>
            </div>

            <div class="kpi-row" id="kpis">
              <div class="metric-card income">
                <div class="label">Receitas</div>
                <div class="value" id="kpiIncome">R$ 0,00</div>
                <div class="mini-label">Entradas no período</div>
              </div>
              <div class="metric-card expense">
                <div class="label">Despesas</div>
                <div class="value" id="kpiExpense">R$ 0,00</div>
                <div class="mini-label">Saídas no período</div>
              </div>
              <div class="metric-card balance">
                <div class="label">Saldo</div>
                <div class="value" id="kpiBalance">R$ 0,00</div>
                <div class="mini-label">Resultado consolidado</div>
              </div>
            </div>

            <div class="tabs" id="coupleTabs" style="display:none;">
              <button class="tab active" data-tab="totals">Totais</button>
              <button class="tab" data-tab="details">Detalhes</button>
            </div>

            <div id="coupleHint" class="info-note" style="display:none;">
              Visão consolidada: sincronizada automaticamente a partir das carteiras individuais.
            </div>

            <div id="coupleBreakdown" style="display:none; margin-top:10px;"></div>
          </div>

          <div class="panel list-panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Movimentações</p>
                <h2>Receitas e Despesas</h2>
              </div>
            </div>
            <div class="split-panels">
              <div class="mini-panel">
                <div class="section-heading"><h3>Receitas</h3><span class="pill">Mês selecionado</span></div>
                <div id="incomeList" class="stack-list"></div>
              </div>
              <div class="mini-panel">
                <div class="section-heading"><h3>Despesas</h3><span class="pill">Mês selecionado</span></div>
                <div id="expenseList" class="stack-list"></div>
              </div>
            </div>
            <p class="muted" id="dashboardStatus"></p>
          </div>
        </section>

        <section class="page" id="page-transactions">
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Fluxo</p>
                <h3>Transações</h3>
              </div>
            </div>
            <div class="form-grid">
              <div>
                <label for="txnDate">Data</label>
                <input id="txnDate" type="date" />
              </div>
              <div>
                <label for="txnType">Tipo</label>
                <select id="txnType">
                  <option value="expense">Despesa</option>
                  <option value="income">Receita</option>
                  <option value="reserve">Reserva</option>
                </select>
              </div>
              <div>
                <label for="txnNote">Descrição</label>
                <input id="txnNote" placeholder="Observação" />
              </div>
            </div>

            <div class="form-grid" style="margin-top:10px;">
              <div>
                <label for="txnAmount">Valor</label>
                <input id="txnAmount" placeholder="Ex.: 35,90" />
              </div>
              <div>
                <label for="txnPayment">Forma de pagamento</label>
                <select id="txnPayment">
                  <option value="">Selecione</option>
                  <option value="pix">Pix</option>
                  <option value="credito">Cartão de crédito</option>
                  <option value="debito">Cartão de débito</option>
                  <option value="dinheiro">Dinheiro</option>
                  <option value="transferencia">Transferência</option>
                  <option value="boleto">Boleto</option>
                  <option value="outro">Outro</option>
                </select>
              </div>
              <div>
                <label for="txnCat">Categoria</label>
                <select id="txnCat"></select>
              </div>
            </div>
            <div class="form-grid" id="creditTxnFields" style="margin-top:6px;" hidden>
              <div>
                <label for="txnCard">Cartão</label>
                <select id="txnCard"></select>
              </div>
              <div>
                <label for="txnPurchaseDate">Data da compra</label>
                <input id="txnPurchaseDate" type="date" />
              </div>
              <div>
                <label for="txnStatementMonth">Fatura</label>
                <input id="txnStatementMonth" disabled />
              </div>
            </div>

            <div class="optional-block">
              <p class="optional-title">Opcionais</p>
              <div class="optional-cards">
                <div class="option-card" id="cardRecurring">
                  <div class="option-head">
                    <input type="checkbox" id="cbRecurring" />
                    <div class="option-text">
                      <span class="option-label">Tornar recorrente</span>
                      <span class="option-sub">Mensal</span>
                    </div>
                  </div>
                </div>

                <div class="option-card" id="cardInstallment" hidden>
                  <div class="option-head">
                    <input type="checkbox" id="cbInstallment" />
                    <div class="option-text">
                      <span class="option-label">Despesa parcelada</span>
                      <span class="option-sub">Controlar parcelas</span>
                    </div>
                  </div>
                  <div class="option-fields" id="installmentFields" hidden>
                    <div>
                      <label for="installmentTotal">Total de parcelas</label>
                      <input id="installmentTotal" type="number" min="1" step="1" placeholder="Ex.: 12" />
                    </div>
                    <div>
                      <label for="installmentCurrent">Parcela atual</label>
                      <input id="installmentCurrent" type="number" min="1" step="1" placeholder="Ex.: 3" />
                    </div>
                  </div>
                </div>

                <div class="option-card" id="cardFinance" hidden>
                  <div class="option-head">
                    <input type="checkbox" id="cbFinance" />
                    <div class="option-text">
                      <span class="option-label">Financiamento</span>
                      <span class="option-sub">Detalhar parcelas</span>
                    </div>
                  </div>
                  <div class="option-fields" id="financeFields" hidden>
                    <div>
                      <label for="financeTotal">Total de parcelas</label>
                      <input id="financeTotal" type="number" min="1" step="1" placeholder="Ex.: 48" />
                    </div>
                    <div>
                      <label for="financeCurrent">Parcela atual</label>
                      <input id="financeCurrent" type="number" min="1" step="1" placeholder="Ex.: 10" />
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div style="display:flex; align-items:flex-end; justify-content:flex-start; margin-top:12px;">
              <button id="btnAddTxn">Adicionar</button>
            </div>
            <p class="muted" id="txnStatus" style="margin-top:10px;"></p>
            <p class="err" id="opsError"></p>
          </div>

          <div class="panel list-panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Movimentações</p>
                <h2>Lista do mês</h2>
              </div>
            </div>
            <div class="table-shell large">
              <table>
                <thead>
                  <tr>
                    <th class="nowrap">Data</th>
                    <th>Categoria</th>
                    <th>Descrição</th>
                    <th class="right nowrap">Valor</th>
                    <th class="right nowrap">Ações</th>
                  </tr>
                </thead>
                <tbody id="txnTable"></tbody>
              </table>
            </div>
          </div>
        </section>

        <section class="page" id="page-categories">
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Organização</p>
                <h3>Categorias</h3>
              </div>
            </div>

            <div class="form-grid">
              <div>
                <label for="catName">Nome</label>
                <input id="catName" placeholder="Ex.: Alimentação" />
              </div>
              <div>
                <label for="catKind">Tipo</label>
                <select id="catKind">
                  <option value="expense">Despesa</option>
                  <option value="income">Receita</option>
                  <option value="both">Ambos</option>
                </select>
              </div>
              <div class="row">
                <button id="btnAddCat">Adicionar</button>
                <button id="btnSeedCats" class="ghost">Categorias padrão</button>
              </div>
            </div>
            <div class="muted" id="catStatus" style="margin-top:6px;"></div>
            <div class="table-shell" style="margin-top:10px; max-height: 240px; overflow:auto;">
              <table>
                <thead>
                  <tr><th>Nome</th><th>Tipo</th><th class="right">Ações</th></tr>
                </thead>
                <tbody id="catTable"></tbody>
              </table>
            </div>
          </div>
        </section>

        <section class="page" id="page-settings">
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Sessão</p>
                <h3>Preferências</h3>
              </div>
            </div>
            <p class="muted">Use o menu para navegar. Seus dados sincronizam automaticamente.</p>
          </div>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Ferramentas</p>
                <h3>Transacoes v2</h3>
              </div>
            </div>
            <p class="muted">Aplica defaults v2 em transacoes pessoais e no consolidado.</p>
            <div class="row">
              <button id="btnMigrateTxnV2" class="ghost">Aplicar defaults (Transactions v2)</button>
            </div>
            <div class="muted" id="migrateStatus" style="margin-top:6px;"></div>
          </div>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Automacao</p>
                <h3>Planos</h3>
              </div>
            </div>
            <div class="form-grid">
              <div>
                <label for="planTitle">Descricao</label>
                <input id="planTitle" placeholder="Ex.: Aluguel" />
              </div>
              <div>
                <label for="planType">Tipo</label>
                <select id="planType">
                  <option value="recurring">Recorrente mensal</option>
                  <option value="installment">Parcelado</option>
                  <option value="finance">Financiamento</option>
                  <option value="credit_installment">Compra no cartao</option>
                </select>
              </div>
              <div>
                <label for="planTxnType">Natureza</label>
                <select id="planTxnType">
                  <option value="expense">Despesa</option>
                  <option value="income">Receita</option>
                </select>
              </div>
            </div>
            <div class="form-grid" style="margin-top:10px;">
              <div>
                <label for="planCategory">Categoria</label>
                <select id="planCategory"></select>
              </div>
              <div id="planAmountEachWrap">
                <label for="planAmountEach">Valor mensal</label>
                <input id="planAmountEach" placeholder="Ex.: 350,00" />
              </div>
              <div id="planAmountTotalWrap">
                <label for="planAmountTotal">Valor total</label>
                <input id="planAmountTotal" placeholder="Ex.: 1200,00" />
              </div>
            </div>
            <div class="form-grid" style="margin-top:10px;">
              <div id="planMonthsWrap">
                <label for="planMonthsTotal">Numero de meses</label>
                <input id="planMonthsTotal" type="number" min="1" step="1" placeholder="Ex.: 12" />
              </div>
              <div>
                <label for="planStartMonth">Mes inicial</label>
                <input id="planStartMonth" type="month" />
              </div>
              <div id="planPaymentWrap">
                <label for="planPaymentMethod">Forma de pagamento</label>
                <select id="planPaymentMethod">
                  <option value="pix">Pix</option>
                  <option value="credito">Cartao de credito</option>
                  <option value="debito">Cartao de debito</option>
                  <option value="dinheiro">Dinheiro</option>
                  <option value="transferencia">Transferencia</option>
                  <option value="boleto">Boleto</option>
                  <option value="outro">Outro</option>
                </select>
              </div>
            </div>
            <div class="form-grid" id="planCardWrap" style="margin-top:10px;" hidden>
              <div>
                <label for="planCreditCard">Cartao</label>
                <select id="planCreditCard"></select>
              </div>
              <div id="planPurchaseWrap" hidden>
                <label for="planPurchaseDate">Data da compra</label>
                <input id="planPurchaseDate" type="date" />
              </div>
            </div>
            <div class="row">
              <button id="btnCreatePlan">Gerar agora</button>
            </div>
            <div class="muted" id="planStatus" style="margin-top:6px;"></div>
            <div class="table-shell" style="margin-top:12px; max-height: 260px; overflow:auto;">
              <table>
                <thead>
                  <tr>
                    <th>Plano</th>
                    <th>Tipo</th>
                    <th class="right nowrap">Valor</th>
                    <th class="right nowrap">Inicio</th>
                    <th>Status</th>
                    <th class="right">Acoes</th>
                  </tr>
                </thead>
                <tbody id="planTable"></tbody>
              </table>
            </div>
          </div>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Cartoes</p>
                <h3>Cadastro</h3>
              </div>
            </div>
            <div class="form-grid">
              <div>
                <label for="cardName">Nome</label>
                <input id="cardName" placeholder="Ex.: Nubank" />
              </div>
              <div>
                <label for="cardClosingDay">Fechamento</label>
                <input id="cardClosingDay" type="number" min="1" max="28" step="1" placeholder="Ex.: 10" />
              </div>
              <div>
                <label for="cardDueDay">Vencimento</label>
                <input id="cardDueDay" type="number" min="1" max="28" step="1" placeholder="Ex.: 20" />
              </div>
            </div>
            <div class="row">
              <button id="btnAddCard" class="ghost">Adicionar cartao</button>
            </div>
            <div class="muted" id="cardStatus" style="margin-top:6px;"></div>
            <div class="table-shell" style="margin-top:12px; max-height: 220px; overflow:auto;">
              <table>
                <thead>
                  <tr>
                    <th>Cartao</th>
                    <th class="right">Fechamento</th>
                    <th class="right">Vencimento</th>
                    <th>Status</th>
                    <th class="right">Acoes</th>
                  </tr>
                </thead>
                <tbody id="cardTable"></tbody>
              </table>
            </div>
          </div>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Cartao</p>
                <h3>Faturas</h3>
              </div>
            </div>
            <div class="form-grid">
              <div>
                <label for="statementCard">Cartao</label>
                <select id="statementCard"></select>
              </div>
            </div>
            <div class="muted" id="statementStatus" style="margin-top:6px;"></div>
            <div class="table-shell" style="margin-top:12px; max-height: 240px; overflow:auto;">
              <table>
                <thead>
                  <tr>
                    <th>Mes</th>
                    <th class="right">Total</th>
                    <th>Status</th>
                    <th class="right">Acoes</th>
                  </tr>
                </thead>
                <tbody id="statementTable"></tbody>
              </table>
            </div>
            <div class="table-shell" style="margin-top:12px; max-height: 240px; overflow:auto;">
              <table>
                <thead>
                  <tr>
                    <th>Data</th>
                    <th>Categoria</th>
                    <th>Descricao</th>
                    <th class="right">Valor</th>
                  </tr>
                </thead>
                <tbody id="statementItemsTable"></tbody>
              </table>
            </div>
          </div>
        </section>
      </section>
    </main>
  </div>
</div>

<script type="module">


  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js";

  import {
    getAuth,
    onAuthStateChanged,
    signInWithEmailAndPassword,
    GoogleAuthProvider,
    signInWithPopup,
    signOut
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

  import {
    getFirestore,
    Timestamp,
    doc,
    getDoc,
    setDoc,
    deleteDoc,
    collection,
    getDocs,
    addDoc,
    query,
    where,
    orderBy,
    serverTimestamp,
    runTransaction
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

  // Firebase Config (VaultFlow-Dev / vaultflow-dev-marc35)
  const firebaseConfig = {
    apiKey: "AIzaSyDIXLjoqxDQrDr7rhxfBjCBzsXZUycTWD0",
    authDomain: "vaultflow-dev-marc35.firebaseapp.com",
    projectId: "vaultflow-dev-marc35",
    storageBucket: "vaultflow-dev-marc35.firebasestorage.app",
    messagingSenderId: "806046110940",
    appId: "1:806046110940:web:aab0a3245bb304e14b9019",
    measurementId: "G-CMZTW66KS9"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Allowlist (somente vocês 3)
  const ALLOWED_EMAILS = new Set([
    "hbmarc35@gmail.com",
    "lzmarc25@gmail.com",
    "herbertmarck@gmail.com"
  ]);

  const COUPLE_WALLET_ID = "w_casal";
  const PERSONAL_WALLETS = new Set(["w_marcelino", "w_luiza"]);
  const KNOWN_WALLETS = ["w_marcelino", "w_luiza", "w_casal"];
  const FRIENDLY_WALLET_NAMES = {
    w_marcelino: "Marcelino",
    w_luiza: "Luiza",
    w_casal: "Casal"
  };
  const USER_PERSONAL_WALLET = {
    "hbmarc35@gmail.com": "w_marcelino",
    "lzmarc25@gmail.com": "w_luiza",
    "herbertmarck@gmail.com": "w_marcelino"
  };

  const $ = (id) => document.getElementById(id);

  const btnEmail = $("btnEmail");
  const btnGoogle = $("btnGoogle");
  const btnLogout = $("btnLogout");
  const authCard = $("authCard");

  const authStatus = $("authStatus");
  const authError = $("authError");

  const appGrid = $("appGrid");
  const pageTitle = $("pageTitle");
  const navButtons = Array.from(document.querySelectorAll("[data-page-target]"));
  const pages = {
    dashboard: $("page-dashboard"),
    transactions: $("page-transactions"),
    categories: $("page-categories"),
    settings: $("page-settings")
  };

  const me = $("me");

  const walletSelect = $("walletSelect");
  const monthInput = $("month");
  const monthDisplay = $("monthDisplay");
  const btnMonthPrev = $("btnMonthPrev");
  const btnMonthNext = $("btnMonthNext");
  const btnMonthPicker = $("btnMonthPicker");

  const kpiIncome = $("kpiIncome");
  const kpiExpense = $("kpiExpense");
  const kpiBalance = $("kpiBalance");
  const coupleBreakdown = $("coupleBreakdown");

  const coupleTabs = $("coupleTabs");
  const coupleHint = $("coupleHint");

  const incomeList = $("incomeList");
  const expenseList = $("expenseList");
  const dashboardStatus = $("dashboardStatus");

  const catName = $("catName");
  const catKind = $("catKind");
  const btnAddCat = $("btnAddCat");
  const btnSeedCats = $("btnSeedCats");
  const catStatus = $("catStatus");
  const catTable = $("catTable");

  const txnDate = $("txnDate");
  const txnType = $("txnType");
  const txnPayment = $("txnPayment");
  const txnCat = $("txnCat");
  const txnAmount = $("txnAmount");
  const txnNote = $("txnNote");
  const btnAddTxn = $("btnAddTxn");
  const creditTxnFields = $("creditTxnFields");
  const txnCard = $("txnCard");
  const txnPurchaseDate = $("txnPurchaseDate");
  const txnStatementMonth = $("txnStatementMonth");

  const cbRecurring = $("cbRecurring");
  const cbInstallment = $("cbInstallment");
  const cbFinance = $("cbFinance");
  const installmentFields = $("installmentFields");
  const financeFields = $("financeFields");
  const cardInstallment = $("cardInstallment");
  const cardFinance = $("cardFinance");
  const installmentTotal = $("installmentTotal");
  const installmentCurrent = $("installmentCurrent");
  const financeTotal = $("financeTotal");
  const financeCurrent = $("financeCurrent");

  const txnTable = $("txnTable");
  const txnStatus = $("txnStatus");

  const appError = $("appError");
  const opsError = $("opsError");
  const appShell = document.querySelector(".app-shell");
  const sidebarToggle = $("sidebarToggle");

  const diagWallet = $("diagWallet");
  const diagRole = $("diagRole");
  const diagType = $("diagType");
  const diagMemberStatus = $("diagMemberStatus");
  const diagMembershipStatus = $("diagMembershipStatus");
  const diagActionStatus = $("diagActionStatus");
  const diagError = $("diagError");
  const btnRunDiag = $("btnRunDiag");
  const btnReconcile = $("btnReconcile");
  const btnMigrateTxnV2 = $("btnMigrateTxnV2");
  const migrateStatus = $("migrateStatus");

  const planTitle = $("planTitle");
  const planType = $("planType");
  const planTxnType = $("planTxnType");
  const planCategory = $("planCategory");
  const planAmountEach = $("planAmountEach");
  const planAmountTotal = $("planAmountTotal");
  const planMonthsTotal = $("planMonthsTotal");
  const planStartMonth = $("planStartMonth");
  const planPaymentMethod = $("planPaymentMethod");
  const planCreditCard = $("planCreditCard");
  const planPurchaseDate = $("planPurchaseDate");
  const planAmountEachWrap = $("planAmountEachWrap");
  const planAmountTotalWrap = $("planAmountTotalWrap");
  const planMonthsWrap = $("planMonthsWrap");
  const planPaymentWrap = $("planPaymentWrap");
  const planCardWrap = $("planCardWrap");
  const planPurchaseWrap = $("planPurchaseWrap");
  const btnCreatePlan = $("btnCreatePlan");
  const planStatus = $("planStatus");
  const planTable = $("planTable");

  const cardName = $("cardName");
  const cardClosingDay = $("cardClosingDay");
  const cardDueDay = $("cardDueDay");
  const btnAddCard = $("btnAddCard");
  const cardStatus = $("cardStatus");
  const cardTable = $("cardTable");

  const statementCard = $("statementCard");
  const statementStatus = $("statementStatus");
  const statementTable = $("statementTable");
  const statementItemsTable = $("statementItemsTable");

  const editModal = $("editModal");
  const editHelper = $("editHelper");
  const editTxnDate = $("editTxnDate");
  const editTxnType = $("editTxnType");
  const editTxnCat = $("editTxnCat");
  const editTxnAmount = $("editTxnAmount");
  const editTxnNote = $("editTxnNote");
  const btnCloseEdit = $("btnCloseEdit");
  const btnSaveEdit = $("btnSaveEdit");
  const editStatus = $("editStatus");
  const editError = $("editError");

  const state = {
    user: null,
    email: null,
    uid: null,
    displayName: "",
    walletId: null,
    walletRole: null,
    walletType: null,
    walletName: null,
    walletLabels: new Map(),
    coupleTab: "totals",
    categories: new Map(), // catId -> {name, kind}
    creditCards: new Map(), // cardId -> {name, closingDay, dueDay, status}
    plans: new Map(), // planId -> plan data
    currentRows: [],
    txnCache: new Map()
  };
  Object.entries(FRIENDLY_WALLET_NAMES).forEach(([id, label]) => state.walletLabels.set(id, label));

  function setAuthMessage(msg, isError = false) {
    authStatus.textContent = isError ? "" : msg;
    authError.textContent = isError ? msg : "";
  }
  function setAppError(msg = "") { appError.textContent = msg; }
  function setOpsError(msg = "") { opsError.textContent = msg; }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function toBRL(cents) {
    const v = (Number(cents || 0) / 100);
    return v.toLocaleString("pt-BR", { style: "currency", currency: "BRL" });
  }

  function parseAmountToCents(text) {
    const clean = (text ?? "").trim().replace(/\./g, "").replace(",", ".");
    const n = Number(clean);
    if (!Number.isFinite(n)) return null;
    return Math.round(n * 100);
  }

  function formatCentsToInputValue(cents) {
    const v = Number(cents || 0) / 100;
    return v.toFixed(2).replace(".", ",");
  }

  function parsePositiveInt(value) {
    const n = Number(value);
    if (!Number.isFinite(n) || n <= 0) return null;
    return Math.trunc(n);
  }

  function buildTxnV2Defaults(type = "expense", originalType = null) {
    const baseType = type || "expense";
    return {
      originalType: originalType || baseType,
      paymentMethod: "outro",
      recurring: { isRecurring: false, cadence: "none" },
      installment: { isInstallment: false, total: null, current: null },
      finance: { isFinance: false, total: null, current: null }
    };
  }

  function normalizeTxnV2(txn = {}) {
    const baseType = txn.type ?? "expense";
    const defaults = buildTxnV2Defaults(baseType, txn.originalType ?? baseType);
    const paymentRaw = (txn.paymentMethod ?? "").trim();

    return {
      ...txn,
      type: baseType,
      originalType: txn.originalType ?? defaults.originalType,
      paymentMethod: paymentRaw || defaults.paymentMethod,
      recurring: {
        isRecurring: Boolean(txn.recurring?.isRecurring),
        cadence: txn.recurring?.cadence ?? (txn.recurring?.isRecurring ? "monthly" : defaults.recurring.cadence)
      },
      installment: {
        isInstallment: Boolean(txn.installment?.isInstallment),
        total: txn.installment?.total ?? defaults.installment.total,
        current: txn.installment?.current ?? defaults.installment.current
      },
      finance: {
        isFinance: Boolean(txn.finance?.isFinance),
        total: txn.finance?.total ?? defaults.finance.total,
        current: txn.finance?.current ?? defaults.finance.current
      }
    };
  }

  function buildTxnV2Payload(rawType, type) {
    const defaults = buildTxnV2Defaults(type, rawType || type);
    const paymentRaw = (txnPayment?.value ?? "").trim();
    const paymentMethod = paymentRaw || defaults.paymentMethod;

    const isRecurring = !!cbRecurring?.checked;
    const recurring = {
      isRecurring,
      cadence: isRecurring ? "monthly" : defaults.recurring.cadence
    };

    const isInstallment = !!cbInstallment?.checked;
    const installment = {
      isInstallment,
      total: isInstallment ? parsePositiveInt(installmentTotal?.value) : defaults.installment.total,
      current: isInstallment ? parsePositiveInt(installmentCurrent?.value) : defaults.installment.current
    };

    const isFinance = !!cbFinance?.checked;
    const finance = {
      isFinance,
      total: isFinance ? parsePositiveInt(financeTotal?.value) : defaults.finance.total,
      current: isFinance ? parsePositiveInt(financeCurrent?.value) : defaults.finance.current
    };

    return {
      originalType: defaults.originalType,
      paymentMethod,
      recurring,
      installment,
      finance
    };
  }

  function buildTxnV2MergePatch(txn = {}) {
    const baseType = txn.type ?? "expense";
    const patch = {};

    if (!txn.originalType) patch.originalType = baseType;

    const paymentRaw = (txn.paymentMethod ?? "").trim();
    if (!paymentRaw) patch.paymentMethod = "outro";

    const recurringPatch = {};
    if (txn.recurring?.isRecurring == null) recurringPatch.isRecurring = false;
    if (txn.recurring?.cadence == null) recurringPatch.cadence = "none";
    if (Object.keys(recurringPatch).length) patch.recurring = recurringPatch;

    const installmentPatch = {};
    if (txn.installment?.isInstallment == null) installmentPatch.isInstallment = false;
    if (txn.installment?.total == null) installmentPatch.total = null;
    if (txn.installment?.current == null) installmentPatch.current = null;
    if (Object.keys(installmentPatch).length) patch.installment = installmentPatch;

    const financePatch = {};
    if (txn.finance?.isFinance == null) financePatch.isFinance = false;
    if (txn.finance?.total == null) financePatch.total = null;
    if (txn.finance?.current == null) financePatch.current = null;
    if (Object.keys(financePatch).length) patch.finance = financePatch;

    return patch;
  }

  function parseYYYYMM(yyyyMM) {
    if (!/^\d{4}-\d{2}$/.test(yyyyMM || "")) return null;
    const [y, m] = yyyyMM.split("-").map(Number);
    if (!y || !m || m < 1 || m > 12) return null;
    return { y, m };
  }

  function formatYYYYMM(y, m) {
    const mm = String(m).padStart(2, "0");
    return `${y}-${mm}`;
  }

  function addMonthsYYYYMM(yyyyMM, delta) {
    const parsed = parseYYYYMM(yyyyMM);
    if (!parsed) return null;
    const total = parsed.y * 12 + (parsed.m - 1) + delta;
    const y = Math.floor(total / 12);
    const m = (total % 12) + 1;
    return formatYYYYMM(y, m);
  }

  function compareYYYYMM(a, b) {
    const pa = parseYYYYMM(a);
    const pb = parseYYYYMM(b);
    if (!pa || !pb) return 0;
    const va = pa.y * 12 + (pa.m - 1);
    const vb = pb.y * 12 + (pb.m - 1);
    return va === vb ? 0 : (va < vb ? -1 : 1);
  }

  function monthDiff(startYYYYMM, endYYYYMM) {
    const start = parseYYYYMM(startYYYYMM);
    const end = parseYYYYMM(endYYYYMM);
    if (!start || !end) return 0;
    return (end.y - start.y) * 12 + (end.m - start.m);
  }

  function firstDateOfMonth(yyyyMM) {
    const parsed = parseYYYYMM(yyyyMM);
    if (!parsed) return null;
    return new Date(parsed.y, parsed.m - 1, 1, 0, 0, 0);
  }

  function timestampFromYYYYMM(yyyyMM) {
    const date = firstDateOfMonth(yyyyMM);
    return date ? Timestamp.fromDate(date) : null;
  }

  function splitAmountByMonths(totalCents, monthsTotal) {
    const total = Number(totalCents || 0);
    const months = Number(monthsTotal || 0);
    if (!Number.isFinite(total) || !Number.isFinite(months) || months <= 0) return [];
    const base = Math.floor(total / months);
    const remainder = total - base * months;
    const amounts = [];
    for (let i = 1; i <= months; i += 1) {
      amounts.push(base + (i <= remainder ? 1 : 0));
    }
    return amounts;
  }

  function computeStatementMonth(purchaseDate, closingDay = 10) {
    const d = purchaseDate instanceof Date ? purchaseDate : new Date(purchaseDate || Date.now());
    const day = d.getDate();
    let y = d.getFullYear();
    let m = d.getMonth() + 1;
    if (day > closingDay) {
      m += 1;
      if (m > 12) { m = 1; y += 1; }
    }
    return formatYYYYMM(y, m);
  }

  function yyyyMMFromMonthInput(value) {
    if (!value || !/^\d{4}-\d{2}$/.test(value)) return null;
    return value;
  }

  function yyyyMMFromDateStr(dateStr) {
    if (!dateStr || dateStr.length < 7) return null;
    return dateStr.slice(0, 7);
  }

  function yyyyMMFromTimestamp(ts) {
    try {
      const d = ts?.toDate?.();
      if (!d) return null;
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      return `${d.getFullYear()}-${mm}`;
    } catch { return null; }
  }

  function startEndForMonth(yyyyMM) {
    const [y, m] = yyyyMM.split("-").map(Number);
    const start = new Date(Date.UTC(y, m - 1, 1, 0, 0, 0));
    const end = new Date(Date.UTC(y, m, 1, 0, 0, 0));
    return { start, end };
  }

  function toISODateLocal(d) {
    const pad = (x) => String(x).padStart(2, "0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  }

  function currentDateInTZ(timeZone = "America/Sao_Paulo") {
    try {
      const iso = new Date().toLocaleString("en-US", { timeZone, hour12: false });
      return new Date(iso);
    } catch {
      return new Date();
    }
  }

  function currentYYYYMM(timeZone = "America/Sao_Paulo") {
    const d = currentDateInTZ(timeZone);
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    return `${d.getFullYear()}-${mm}`;
  }

  function monthLabelFromYYYYMM(yyyyMM) {
    if (!yyyyMMFromMonthInput(yyyyMM)) return "Mês";
    const [y, m] = yyyyMM.split("-").map(Number);
    // usa data local (não UTC) para evitar regressão de mês ao aplicar timezone
    const d = new Date(y, m - 1, 1);
    const raw = d.toLocaleString("pt-BR", { month: "long", timeZone: "America/Sao_Paulo" }) || "";
    return raw ? raw.charAt(0).toUpperCase() + raw.slice(1) : "Mês";
  }

  function renderKPIs(incomeCents, expenseCents) {
    const bal = Number(incomeCents || 0) - Number(expenseCents || 0);
    kpiIncome.textContent = toBRL(incomeCents);
    kpiExpense.textContent = toBRL(expenseCents);
    kpiBalance.textContent = toBRL(bal);
  }

  function syncMonthLabel() {
    if (monthDisplay) monthDisplay.textContent = monthLabelFromYYYYMM(monthInput.value) || "Mês";
  }

  function shiftMonth(delta) {
    const current = yyyyMMFromMonthInput(monthInput.value)
      || currentYYYYMM()
      || yyyyMMFromDateStr(toISODateLocal(currentDateInTZ()));
    if (!current) return;
    const [y, m] = current.split("-").map(Number);
    const nextDate = new Date(Date.UTC(y, m - 1 + delta, 1));
    const mm = String(nextDate.getUTCMonth() + 1).padStart(2, "0");
    const yyyyMM = `${nextDate.getUTCFullYear()}-${mm}`;
    monthInput.value = yyyyMM;
    syncMonthLabel();
    reloadAll();
  }

  function renderMovementList(target, rows) {
    if (!target) return;
    target.innerHTML = "";
    if (!rows || rows.length === 0) {
      target.innerHTML = `<p class="muted">Sem lançamentos.</p>`;
      return;
    }
    const limited = rows.slice(0, 6);
    for (const r of limited) {
      const dt = r.date ? toISODateLocal(r.date) : "-";
      const card = document.createElement("div");
      card.className = "move-card";
      card.innerHTML = `
        <div class="move-meta">
          <span>${escapeHtml(dt)} - ${escapeHtml(r.categoryName || "-")}</span>
          <span class="move-amount">${toBRL(Math.abs(r.amountCents))}</span>
        </div>
        <div class="muted">${escapeHtml(r.note || "")}${r.sourceLabel ? ` - ${escapeHtml(r.sourceLabel)}` : ""}</div>
      `;
      target.appendChild(card);
    }
  }

  function renderDashboardMovements(rows) {
    const incomeRows = [];
    const expenseRows = [];
    for (const r of rows || []) {
      if (r.type === "income") incomeRows.push(r);
      else expenseRows.push(r);
    }
    renderMovementList(incomeList, incomeRows);
    renderMovementList(expenseList, expenseRows);
  }

  function syncOptionalFields() {
    const isExpense = txnType.value === "expense";

    if (cardInstallment) cardInstallment.hidden = !isExpense;
    if (cardFinance) cardFinance.hidden = !isExpense;

    if (!isExpense) {
      cbInstallment.checked = false;
      cbFinance.checked = false;
    }

    const showInstallment = isExpense && cbInstallment.checked;
    const showFinance = isExpense && cbFinance.checked;

    installmentFields.hidden = !showInstallment;
    financeFields.hidden = !showFinance;

    [installmentTotal, installmentCurrent].forEach((el) => { if (el) el.disabled = !showInstallment; });
    [financeTotal, financeCurrent].forEach((el) => { if (el) el.disabled = !showFinance; });
  }

  function syncCreditTxnFields() {
    if (!creditTxnFields) return;
    const isCredit = (txnPayment?.value === "credito");
    creditTxnFields.hidden = !isCredit;
    if (!isCredit) {
      if (txnStatementMonth) txnStatementMonth.value = "";
      return;
    }

    if (txnPurchaseDate && !txnPurchaseDate.value && txnDate?.value) {
      txnPurchaseDate.value = txnDate.value;
    }

    const cardId = txnCard?.value || "";
    if (!cardId) {
      if (txnStatementMonth) txnStatementMonth.value = "";
      return;
    }
    const closingDay = getCardClosingDay(cardId);
    const purchaseDateStr = txnPurchaseDate?.value || txnDate?.value || "";
    if (!purchaseDateStr) {
      if (txnStatementMonth) txnStatementMonth.value = "";
      return;
    }

    const purchaseDateObj = new Date(purchaseDateStr + "T00:00:00");
    const statementMonth = computeStatementMonth(purchaseDateObj, closingDay);
    if (txnStatementMonth) txnStatementMonth.value = statementMonth || "";
  }

  function syncPlanFields() {
    if (!planType) return;
    const type = planType.value;
    const isRecurring = type === "recurring";
    const isCredit = type === "credit_installment";

    if (planAmountEachWrap) planAmountEachWrap.hidden = !isRecurring;
    if (planAmountTotalWrap) planAmountTotalWrap.hidden = isRecurring;
    if (planMonthsWrap) planMonthsWrap.hidden = isRecurring;

    if (planPaymentWrap) planPaymentWrap.hidden = isCredit;
    if (planPaymentMethod) {
      if (isCredit) {
        planPaymentMethod.value = "credito";
        planPaymentMethod.disabled = true;
      } else {
        planPaymentMethod.disabled = false;
        if (!planPaymentMethod.value) planPaymentMethod.value = "outro";
      }
    }

    if (planCardWrap) planCardWrap.hidden = !isCredit;
    if (planPurchaseWrap) planPurchaseWrap.hidden = !isCredit;
  }

  function syncCoupleTabs() {
    if (!coupleTabs) return;
    coupleTabs.querySelectorAll(".tab").forEach((btn) => {
      const tab = btn.getAttribute("data-tab");
      btn.classList.toggle("active", tab === state.coupleTab);
    });
  }

  function isCoupleWallet() {
    return state.walletId === COUPLE_WALLET_ID && state.walletType === "aggregate";
  }

  function isPersonalWalletId(walletId) {
    return PERSONAL_WALLETS.has(walletId);
  }

  function friendlyWalletLabel(walletId, fallbackName = "") {
    if (FRIENDLY_WALLET_NAMES[walletId]) return FRIENDLY_WALLET_NAMES[walletId];
    if (fallbackName) {
      const trimmed = fallbackName.includes("(") ? fallbackName.split("(")[0].trim() : fallbackName.trim();
      if (trimmed) return trimmed;
    }
    if (walletId?.startsWith("w_")) {
      const slug = walletId.slice(2).replace(/_/g, " ");
      return slug ? slug.charAt(0).toUpperCase() + slug.slice(1) : walletId;
    }
    return walletId || fallbackName || "";
  }

  function showPage(key) {
    const titles = {
      dashboard: "Dashboard",
      transactions: "Transações",
      categories: "Categorias",
      settings: "Preferências"
    };

    Object.entries(pages).forEach(([pageKey, el]) => {
      if (!el) return;
      const active = pageKey === key;
      el.classList.toggle("active", active);
      el.style.display = active ? "grid" : "none";
    });

    navButtons.forEach((btn) => {
      const target = btn.getAttribute("data-page-target");
      btn.classList.toggle("active", target === key);
    });

    if (pageTitle) pageTitle.textContent = titles[key] ?? "VaultFlow";
  }

  // ===== Bootstrap =====

  async function ensureUserProfile(user) {
    const ref = doc(db, "users", user.uid);
    const snap = await getDoc(ref);
    if (!snap.exists()) {
      await setDoc(ref, {
        displayName: user.displayName ?? (user.email?.split("@")[0] ?? "Usuário"),
        email: (user.email ?? "").toLowerCase(),
        createdAt: Timestamp.now()
      }, { merge: true });
    } else {
      await setDoc(ref, {
        email: (user.email ?? "").toLowerCase(),
        displayName: snap.data().displayName ?? user.displayName ?? "Usuário"
      }, { merge: true });
    }
  }

  async function ensureWalletMetaIfOwner(user) {
    const email = (user.email ?? "").toLowerCase();
    const uid = user.uid;

    const isMarcelino = email === "hbmarc35@gmail.com";
    const isLuiza = email === "lzmarc25@gmail.com";

    async function upsertWallet(walletId, dataIfCreate, dataMerge) {
      const wRef = doc(db, "wallets", walletId);
      const wSnap = await getDoc(wRef);
      if (!wSnap.exists()) {
        await setDoc(wRef, dataIfCreate, { merge: false });
      } else {
        await setDoc(wRef, dataMerge, { merge: true });
      }
    }

    if (isMarcelino) {
      await upsertWallet(
        "w_marcelino",
        { name: "Marcelino", type: "personal", createdBy: uid, createdAt: Timestamp.now() },
        { name: "Marcelino", type: "personal" }
      );
    }

    if (isLuiza) {
      await upsertWallet(
        "w_luiza",
        { name: "Luiza", type: "personal", createdBy: uid, createdAt: Timestamp.now() },
        { name: "Luiza", type: "personal" }
      );
    }

    if (isMarcelino || isLuiza) {
      const srcRefs = [
        doc(db, "wallets", "w_marcelino"),
        doc(db, "wallets", "w_luiza")
      ];
      await upsertWallet(
        "w_casal",
        {
          name: "Casal",
          type: "aggregate",
          createdBy: uid,
          createdAt: Timestamp.now(),
          sources: srcRefs
        },
        {
          name: "Casal",
          type: "aggregate",
          sources: srcRefs
        }
      );
    }
  }

  async function ensureMembershipShortcutsFromMembers(user) {
    const membershipCol = collection(db, "users", user.uid, "memberships");
    const existing = await getDocs(membershipCol);
    if (existing.size > 0) return;

    for (const walletId of KNOWN_WALLETS) {
      try {
        const mRef = doc(db, "wallets", walletId, "members", user.uid);
        const mSnap = await getDoc(mRef);
        if (!mSnap.exists()) continue;

        const role = mSnap.data().role;
        await setDoc(doc(db, "users", user.uid, "memberships", walletId), {
          role,
          createdAt: Timestamp.now()
        }, { merge: true });
      } catch {
        // ignore
      }
    }
  }

  async function loadWalletOptions(user) {
    const membershipCol = collection(db, "users", user.uid, "memberships");
    const snaps = await getDocs(membershipCol);
    const list = snaps.docs.map(d => ({ walletId: d.id, role: d.data().role }));

    const personalId = USER_PERSONAL_WALLET[state.email];

    // mantém só a carteira pessoal do usuário e o casal (se existirem); se nada sobrar, usa a lista original
    const filtered = list.filter(w => w.walletId === personalId || w.walletId === COUPLE_WALLET_ID);
    const effectiveList = filtered.length ? filtered : list;

    // Ordena priorizando pessoais antes das agregadas
    effectiveList.sort((a, b) => {
      const aPersonal = PERSONAL_WALLETS.has(a.walletId);
      const bPersonal = PERSONAL_WALLETS.has(b.walletId);
      if (aPersonal !== bPersonal) return aPersonal ? -1 : 1;
      return (state.walletLabels.get(a.walletId) || a.walletId).localeCompare(state.walletLabels.get(b.walletId) || b.walletId);
    });

    walletSelect.innerHTML = "";
    state.walletLabels.clear();
    for (const item of effectiveList) {
      let label = item.walletId;
      let type = "?";
      try {
        const wSnap = await getDoc(doc(db, "wallets", item.walletId));
        if (wSnap.exists()) {
          label = wSnap.data().name ?? item.walletId;
          type = wSnap.data().type ?? "?";
        }
      } catch {}

      let friendly = friendlyWalletLabel(item.walletId, label);
      if (item.walletId === personalId) friendly = "Pessoal";
      if (item.walletId === COUPLE_WALLET_ID) friendly = "Casal";
      state.walletLabels.set(item.walletId, friendly);

      const opt = document.createElement("option");
      opt.value = item.walletId;
      opt.textContent = friendly;
      opt.dataset.type = type;
      walletSelect.appendChild(opt);
    }
    return effectiveList;
  }

  function selectDefaultWallet(wallets) {
    const current = walletSelect.value;
    const hasCurrent = wallets.some(w => w.walletId === current);
    if (hasCurrent && isPersonalWalletId(current)) return;

    const preferredId = USER_PERSONAL_WALLET[state.email];
    if (preferredId && wallets.some(w => w.walletId === preferredId)) {
      walletSelect.value = preferredId;
      return;
    }

    const casal = wallets.find(w => w.walletId === COUPLE_WALLET_ID);
    if (casal) {
      walletSelect.value = casal.walletId;
      return;
    }

    if (hasCurrent) {
      walletSelect.value = current;
      return;
    }

    if (wallets.length > 0) {
      walletSelect.value = wallets[0].walletId;
    }
  }

  async function refreshWalletContext() {
    setAppError("");
    setOpsError("");

    const walletId = walletSelect.value;
    if (!walletId) {
      setAppError("Nenhuma carteira disponível para sua conta.");
      return;
    }

    let role = null;
    try {
      const mSnap = await getDoc(doc(db, "users", state.uid, "memberships", walletId));
      role = mSnap.exists() ? mSnap.data().role : null;
    } catch {}

    let name = walletId;
    let type = "?";
    try {
      const wSnap = await getDoc(doc(db, "wallets", walletId));
      if (wSnap.exists()) {
        name = wSnap.data().name ?? walletId;
        type = wSnap.data().type ?? "?";
      }
    } catch (e) {
      setAppError("Não foi possível carregar a carteira. Tente novamente.");
    }

    state.walletId = walletId;
    state.walletRole = role ?? "-";
    state.walletType = type;
    state.walletName = friendlyWalletLabel(walletId, name);
    state.walletLabels.set(walletId, state.walletName);

    const couple = isCoupleWallet();
    state.coupleTab = couple ? "details" : "totals";
    syncCoupleTabs();
    coupleTabs.style.display = couple ? "" : "none";
    coupleHint.style.display = couple ? "" : "none";
    coupleBreakdown.style.display = couple ? "" : "none";

    const disablePersonal = couple;
    [catName, catKind, btnAddCat, btnSeedCats].forEach((el) => el && (el.disabled = disablePersonal));
    [txnDate, txnType, txnCat, txnAmount, txnNote, txnPayment, txnCard, txnPurchaseDate, btnAddTxn].forEach((el) => el && (el.disabled = disablePersonal));
    [
      planTitle, planType, planTxnType, planCategory, planAmountEach, planAmountTotal, planMonthsTotal,
      planStartMonth, planPaymentMethod, planCreditCard, planPurchaseDate, btnCreatePlan
    ].forEach((el) => el && (el.disabled = disablePersonal));
    [cardName, cardClosingDay, cardDueDay, btnAddCard, statementCard].forEach((el) => el && (el.disabled = disablePersonal));
    if (catStatus) catStatus.textContent = disablePersonal ? "Categorias não disponíveis nesta visão." : "";
    if (disablePersonal && txnStatus) txnStatus.textContent = "Visão consolidada em modo leitura.";
    if (disablePersonal && planStatus) planStatus.textContent = "Planos não disponíveis nesta visão.";
    if (disablePersonal && cardStatus) cardStatus.textContent = "Cartões não disponíveis nesta visão.";

    const now = new Date();
    txnDate.value = toISODateLocal(now);

    await reloadAll();
    await loadCreditCards();
    await loadPlans();
  }

  async function runDiagnostics() {
    if (!diagError || !diagWallet || !diagRole || !diagType || !diagMemberStatus || !diagMembershipStatus) {
      return;
    }
    diagError.textContent = "";

    if (!state.walletId) {
      diagError.textContent = "Selecione uma wallet para avaliar.";
      return;
    }

    diagWallet.textContent = `${state.walletName} (${state.walletId})`;
    diagRole.textContent = state.walletRole ?? "-";
    diagType.textContent = state.walletType ?? "-";

    try {
      const memberRef = doc(db, "wallets", state.walletId, "members", state.uid);
      const memberSnap = await getDoc(memberRef);
      const memberRole = memberSnap.exists() ? (memberSnap.data()?.role ?? "-") : null;

      const membershipRef = doc(db, "users", state.uid, "memberships", state.walletId);
      const membershipSnap = await getDoc(membershipRef);
      const membershipRole = membershipSnap.exists() ? (membershipSnap.data()?.role ?? "-") : null;

      if (memberSnap.exists()) {
        diagMemberStatus.textContent = `OK: wallets/${state.walletId}/members/${state.uid} (role: ${memberRole})`;
      } else {
        diagMemberStatus.textContent = `FALHA: wallets/${state.walletId}/members/${state.uid} ausente.`;
      }

      if (!membershipSnap.exists()) {
        diagMembershipStatus.textContent = `FALHA: users/${state.uid}/memberships/${state.walletId} ausente.`;
      } else if (memberRole && membershipRole && memberRole !== membershipRole) {
        diagMembershipStatus.textContent = `FALHA: role divergente (members=${memberRole}, membership=${membershipRole}).`;
      } else if (!memberSnap.exists() && membershipSnap.exists()) {
        diagMembershipStatus.textContent = `FALHA: membership existe, mas usuário não está em members.`;
      } else {
        diagMembershipStatus.textContent = `OK: membership consistente (role: ${membershipRole ?? "-"}).`;
      }
    } catch (e) {
      diagError.textContent = e?.message ?? String(e);
    }
  }

  async function reconcileMembershipsFromMembers() {
    if (!btnReconcile || !diagActionStatus || !diagError) {
      return;
    }
    diagError.textContent = "";
    diagActionStatus.textContent = "Reconhecendo memberships...";
    btnReconcile.disabled = true;

    try {
      for (const walletId of KNOWN_WALLETS) {
        const memberRef = doc(db, "wallets", walletId, "members", state.uid);
        const memberSnap = await getDoc(memberRef);
        const membershipRef = doc(db, "users", state.uid, "memberships", walletId);
        const membershipSnap = await getDoc(membershipRef);

        if (!memberSnap.exists()) {
          try { await deleteDoc(membershipRef); } catch {}
          continue;
        }

        const role = memberSnap.data()?.role;
        const payload = {
          role,
          updatedAt: serverTimestamp()
        };

        if (!membershipSnap.exists()) payload.createdAt = serverTimestamp();

        await setDoc(membershipRef, payload, { merge: true });
      }

      diagActionStatus.textContent = "Reconciliado com base em wallets/*/members.";
    } catch (e) {
      diagError.textContent = e?.message ?? String(e);
    } finally {
      btnReconcile.disabled = false;
    }
  }

  // ===== Categories =====

  function setCategoryOptions(selectEl, selectedId = "", fallbackLabel = "") {
    if (!selectEl) return;
    selectEl.innerHTML = "";
    const entries = Array.from(state.categories.entries())
      .map(([id, c]) => ({ id, ...c }))
      .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));

    if (entries.length == 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "Sem categorias";
      selectEl.appendChild(opt);
      return;
    }

    let hasSelected = false;
    for (const c of entries) {
      const opt = document.createElement("option");
      opt.value = c.id;
      opt.textContent = c.name;
      if (selectedId && selectedId == c.id) hasSelected = true;
      selectEl.appendChild(opt);
    }

    if (selectedId && hasSelected) {
      selectEl.value = selectedId;
    } else if (fallbackLabel) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = fallbackLabel;
      selectEl.appendChild(opt);
      selectEl.value = "";
    }
  }

  async function loadCategories() {
    state.categories.clear();
    if (txnCat) txnCat.innerHTML = "";
    if (editTxnCat) editTxnCat.innerHTML = "";
    if (planCategory) planCategory.innerHTML = "";

    if (isCoupleWallet()) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "-";
      if (txnCat) txnCat.appendChild(opt);
      if (editTxnCat) editTxnCat.appendChild(opt.cloneNode(true));
      if (planCategory) planCategory.appendChild(opt.cloneNode(true));
      if (catTable) catTable.innerHTML = "";
      if (catStatus) catStatus.textContent = "Categorias n?o dispon?veis nesta carteira.";
      return;
    }

    const colRef = collection(db, "wallets", state.walletId, "categories");
    const snaps = await getDocs(colRef);

    for (const d of snaps.docs) {
      const data = d.data();
      state.categories.set(d.id, { name: data.name, kind: data.kind });
    }

    setCategoryOptions(txnCat);
    if (editTxnCat) setCategoryOptions(editTxnCat, editTxnCat.value);
    if (planCategory) setCategoryOptions(planCategory, planCategory.value);

    renderCategoriesTable();
    if (catStatus) catStatus.textContent = `Categorias carregadas: ${state.categories.size}`;
  }

function renderCategoriesTable() {
    if (!catTable) return;
    catTable.innerHTML = "";
    const entries = Array.from(state.categories.entries())
      .map(([id, c]) => ({ id, ...c }))
      .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));

    for (const c of entries) {
      const kindLabel = c.kind === "income" ? "Receita" : (c.kind === "expense" ? "Despesa" : "Ambos");
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(c.name)}</td>
        <td><span class="badge">${escapeHtml(kindLabel)}</span></td>
        <td class="right actions">
          <button class="icon-action" data-edit-cat="${c.id}" aria-label="Editar">✏</button>
          <button class="icon-action" data-del-cat="${c.id}" aria-label="Excluir">🗑</button>
        </td>
      `;
      catTable.appendChild(tr);
    }

    catTable.querySelectorAll("button[data-edit-cat]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-edit-cat");
        await editCategory(id);
      });
    });

    catTable.querySelectorAll("button[data-del-cat]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-del-cat");
        if (!confirm("Excluir esta categoria?")) return;
        try {
          await deleteDoc(doc(db, "wallets", state.walletId, "categories", id));
          await loadCategories();
        } catch (e) {
          catStatus.textContent = "Não foi possível excluir a categoria.";
        }
      });
    });
  }

  async function addCategory() {
    setOpsError("");
    catStatus.textContent = "";
    const name = (catName.value ?? "").trim();
    const kind = catKind.value;

    if (!name) {
      catStatus.textContent = "Informe o nome da categoria.";
      return;
    }

    try {
      await addDoc(collection(db, "wallets", state.walletId, "categories"), {
        name,
        kind,
        createdAt: serverTimestamp(),
        createdBy: state.uid
      });
      catName.value = "";
      await loadCategories();
    } catch (e) {
      catStatus.textContent = "Não foi possível adicionar a categoria.";
    }
  }

  async function editCategory(catId) {
    setOpsError("");
    const current = state.categories.get(catId);
    const nextName = prompt("Editar nome da categoria", current?.name ?? "");
    if (nextName == null) return;
    const trimmed = nextName.trim();
    if (!trimmed) return;

    try {
      await setDoc(doc(db, "wallets", state.walletId, "categories", catId), { name: trimmed }, { merge: true });
      await loadCategories();
    } catch (e) {
      catStatus.textContent = "Não foi possível atualizar a categoria.";
    }
  }

  async function seedDefaultCategories() {
    setOpsError("");
    if (!confirm("Criar categorias padrão nesta carteira?")) return;

    const defaults = [
      { name: "Alimentação", kind: "expense" },
      { name: "Transporte", kind: "expense" },
      { name: "Moradia", kind: "expense" },
      { name: "Saúde", kind: "expense" },
      { name: "Lazer", kind: "expense" },
      { name: "Compras", kind: "expense" },
      { name: "Salário", kind: "income" },
      { name: "Outras receitas", kind: "income" }
    ];

    try {
      for (const c of defaults) {
        await addDoc(collection(db, "wallets", state.walletId, "categories"), {
          ...c,
          createdAt: serverTimestamp(),
          createdBy: state.uid
        });
      }
      await loadCategories();
      catStatus.textContent = "Categorias padrão criadas.";
    } catch (e) {
      catStatus.textContent = "Não foi possível criar categorias padrão agora.";
    }
  }

  // ===== Auto-sync Casal (corrigido: reads antes de writes) =====

  function clampNonNegative(n) {
    n = Number(n || 0);
    return n < 0 ? 0 : n;
  }

  function computeCoupleSourceNext(repData, sourceWalletId, deltaIncomeCents, deltaExpenseCents) {
    const sources = repData?.sources ?? {};
    const cur = sources?.[sourceWalletId] ?? {};
    const curIncome = Number(cur.incomeCents || 0);
    const curExpense = Number(cur.expenseCents || 0);

    const nextIncome = clampNonNegative(curIncome + Number(deltaIncomeCents || 0));
    const nextExpense = clampNonNegative(curExpense + Number(deltaExpenseCents || 0));

    return { nextIncome, nextExpense };
  }

  function friendlyPlanType(type) {
    switch (type) {
      case "recurring": return "Recorrente";
      case "installment": return "Parcelado";
      case "finance": return "Financiamento";
      case "credit_installment": return "Cartao parcelado";
      default: return "Plano";
    }
  }

  function friendlyPlanStatus(status) {
    switch (status) {
      case "active": return "Ativo";
      case "paused": return "Pausado";
      case "canceled": return "Cancelado";
      case "completed": return "Concluido";
      default: return "Ativo";
    }
  }

  function friendlyTxnStatus(status) {
    if (status === "paid") return "Pago";
    if (status === "skipped") return "Pulado";
    if (status === "scheduled") return "Agendado";
    return "";
  }

  function statementSignedAmount(amountCents, type) {
    const amt = Number(amountCents || 0);
    return (type === "income") ? -amt : amt;
  }

  function getStatementKey(txn = {}) {
    if (txn.paymentMethod !== "credito") return null;
    if (!txn.creditCardId || !txn.statementMonth) return null;
    return { cardId: txn.creditCardId, month: txn.statementMonth };
  }

  function getStatementRef(walletId, cardId, month) {
    return doc(db, "wallets", walletId, "credit_cards", cardId, "statements", month);
  }

  function getCardClosingDay(cardId) {
    const card = state.creditCards.get(cardId);
    const closing = Number(card?.closingDay ?? 0);
    if (Number.isFinite(closing) && closing >= 1 && closing <= 28) return closing;
    return 10;
  }

  // ===== Credit Cards =====

  async function loadCreditCards() {
    state.creditCards.clear();
    if (txnCard) txnCard.innerHTML = "";
    if (planCreditCard) planCreditCard.innerHTML = "";
    if (statementCard) statementCard.innerHTML = "";

    if (isCoupleWallet()) {
      setCreditCardOptions(txnCard, "", "Nao disponivel");
      setCreditCardOptions(planCreditCard, "", "Nao disponivel");
      setCreditCardOptions(statementCard, "", "Nao disponivel");
      if (cardTable) cardTable.innerHTML = "";
      if (cardStatus) cardStatus.textContent = "Cartoes nao disponiveis nesta carteira.";
      return;
    }

    try {
      const colRef = collection(db, "wallets", state.walletId, "credit_cards");
      const snaps = await getDocs(colRef);
      for (const d of snaps.docs) {
        const data = d.data();
        state.creditCards.set(d.id, {
          name: data.name ?? "Cartao",
          closingDay: Number(data.closingDay || 0),
          dueDay: Number(data.dueDay || 0),
          status: data.status ?? "active"
        });
      }
      setCreditCardOptions(txnCard, txnCard?.value || "");
      setCreditCardOptions(planCreditCard, planCreditCard?.value || "");
      setCreditCardOptions(statementCard, statementCard?.value || "");
      renderCardTable();
      if (cardStatus) cardStatus.textContent = state.creditCards.size ? "" : "Nenhum cartao cadastrado.";
      syncCreditTxnFields();
      syncPlanFields();
      if (statementCard) await loadStatements();
    } catch (e) {
      if (cardStatus) cardStatus.textContent = "Nao foi possivel carregar cartoes.";
    }
  }

  function renderCardTable() {
    if (!cardTable) return;
    cardTable.innerHTML = "";
    const entries = Array.from(state.creditCards.entries())
      .map(([id, c]) => ({ id, ...c }))
      .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));

    for (const c of entries) {
      const statusLabel = c.status === "active" ? "Ativo" : "Inativo";
      const actionLabel = c.status === "active" ? "Desativar" : "Ativar";
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(c.name)}</td>
        <td class="right">${c.closingDay || "-"}</td>
        <td class="right">${c.dueDay || "-"}</td>
        <td><span class="badge">${statusLabel}</span></td>
        <td class="right actions">
          <button class="ghost" data-toggle-card="${c.id}">${actionLabel}</button>
        </td>
      `;
      cardTable.appendChild(tr);
    }

    cardTable.querySelectorAll("button[data-toggle-card]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-toggle-card");
        await toggleCardStatus(id);
      });
    });
  }

  async function addCreditCard() {
    if (!cardName || !cardClosingDay || !cardDueDay || !cardStatus) return;
    cardStatus.textContent = "";
    if (!isPersonalWalletId(state.walletId)) {
      cardStatus.textContent = "Selecione uma carteira pessoal.";
      return;
    }

    const name = (cardName.value ?? "").trim();
    const closingDay = parsePositiveInt(cardClosingDay.value);
    const dueDay = parsePositiveInt(cardDueDay.value);

    if (!name) { cardStatus.textContent = "Informe o nome do cartao."; return; }
    if (!closingDay || closingDay < 1 || closingDay > 28) { cardStatus.textContent = "Fechamento invalido."; return; }
    if (!dueDay || dueDay < 1 || dueDay > 28) { cardStatus.textContent = "Vencimento invalido."; return; }

    try {
      await addDoc(collection(db, "wallets", state.walletId, "credit_cards"), {
        name,
        closingDay,
        dueDay,
        status: "active",
        createdAt: serverTimestamp(),
        createdBy: state.uid,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      });
      cardName.value = "";
      cardClosingDay.value = "";
      cardDueDay.value = "";
      await loadCreditCards();
    } catch (e) {
      console.error("addCreditCard failed", e);
      cardStatus.textContent = "Nao foi possivel salvar o cartao. Verifique sua permissao.";
    }
  }

  async function toggleCardStatus(cardId) {
    if (!cardId) return;
    const current = state.creditCards.get(cardId);
    const nextStatus = current?.status === "active" ? "inactive" : "active";
    try {
      await setDoc(doc(db, "wallets", state.walletId, "credit_cards", cardId), {
        status: nextStatus,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
      await loadCreditCards();
    } catch {
      if (cardStatus) cardStatus.textContent = "Nao foi possivel atualizar o cartao.";
    }
  }

  async function loadStatements() {
    if (!statementTable || !statementItemsTable || !statementStatus) return;
    statementTable.innerHTML = "";
    statementItemsTable.innerHTML = "";

    const cardId = statementCard?.value;
    if (!cardId) {
      statementStatus.textContent = "Selecione um cartao para ver as faturas.";
      return;
    }

    try {
      const colRef = collection(db, "wallets", state.walletId, "credit_cards", cardId, "statements");
      const snaps = await getDocs(colRef);
      const entries = snaps.docs.map(d => {
        const data = d.data();
        return {
          id: d.id,
          month: data.month ?? d.id,
          totalCents: Number(data.totalCents || 0),
          status: data.status ?? "open",
          paidAt: data.paidAt ?? null
        };
      }).sort((a, b) => compareYYYYMM(b.month, a.month));

      if (!entries.length) {
        statementStatus.textContent = "Sem faturas para este cartao.";
        return;
      }

      statementStatus.textContent = "";

      for (const s of entries) {
        const statusLabel = s.status === "paid" ? "Pago" : "Aberta";
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${escapeHtml(s.month)}</td>
          <td class="right">${toBRL(s.totalCents)}</td>
          <td><span class="badge">${statusLabel}</span></td>
          <td class="right actions">
            <button class="ghost" data-view-statement="${s.month}">Ver itens</button>
            ${s.status !== "paid" ? `<button class="ghost" data-pay-statement="${s.month}">Marcar paga</button>` : ""}
          </td>
        `;
        statementTable.appendChild(tr);
      }

      statementTable.querySelectorAll("button[data-view-statement]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const month = btn.getAttribute("data-view-statement");
          await loadStatementItems(cardId, month);
        });
      });

      statementTable.querySelectorAll("button[data-pay-statement]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const month = btn.getAttribute("data-pay-statement");
          await markStatementPaid(cardId, month);
        });
      });
    } catch {
      statementStatus.textContent = "Nao foi possivel carregar as faturas.";
    }
  }

  async function loadStatementItems(cardId, month) {
    if (!statementItemsTable) return;
    statementItemsTable.innerHTML = "";
    if (!cardId || !month) return;

    try {
      const qRef = query(
        collection(db, "wallets", state.walletId, "transactions"),
        where("creditCardId", "==", cardId),
        where("statementMonth", "==", month),
        orderBy("date", "desc")
      );
      const snaps = await getDocs(qRef);
      if (snaps.empty) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="4" class="muted">Sem itens nesta fatura.</td>`;
        statementItemsTable.appendChild(tr);
        return;
      }
      for (const d of snaps.docs) {
        const t = normalizeTxnV2(d.data());
        const tr = document.createElement("tr");
        const dt = t.date?.toDate?.() ? toISODateLocal(t.date.toDate()) : "-";
        tr.innerHTML = `
          <td class="nowrap">${escapeHtml(dt)}</td>
          <td>${escapeHtml(t.categoryName || "-")}</td>
          <td>${escapeHtml(t.note || "")}</td>
          <td class="right">${toBRL(Math.abs(Number(t.amountCents || 0)))}</td>
        `;
        statementItemsTable.appendChild(tr);
      }
    } catch {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="4" class="muted">Nao foi possivel carregar os itens.</td>`;
      statementItemsTable.appendChild(tr);
    }
  }

  async function markStatementPaid(cardId, month) {
    if (!cardId || !month) return;
    try {
      await setDoc(getStatementRef(state.walletId, cardId, month), {
        status: "paid",
        paidAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
      await loadStatements();
    } catch {
      if (statementStatus) statementStatus.textContent = "Nao foi possivel atualizar a fatura.";
    }
  }

  // ===== Plans =====

  async function loadPlans() {
    state.plans.clear();
    if (planTable) planTable.innerHTML = "";

    if (isCoupleWallet()) {
      if (planStatus) planStatus.textContent = "Planos disponiveis apenas em carteiras pessoais.";
      return;
    }

    try {
      const colRef = collection(db, "wallets", state.walletId, "plans");
      const snaps = await getDocs(colRef);
      for (const d of snaps.docs) {
        state.plans.set(d.id, d.data());
      }
      renderPlansTable();
      if (planStatus) planStatus.textContent = state.plans.size ? "" : "Nenhum plano cadastrado.";
    } catch {
      if (planStatus) planStatus.textContent = "Nao foi possivel carregar os planos.";
    }
  }

  function renderPlansTable() {
    if (!planTable) return;
    planTable.innerHTML = "";
    const entries = Array.from(state.plans.entries())
      .map(([id, p]) => ({ id, ...p }))
      .sort((a, b) => (a.title ?? "").localeCompare(b.title ?? ""));

    for (const p of entries) {
      const typeLabel = friendlyPlanType(p.type);
      const statusKey = p.status || "active";
      const statusLabel = friendlyPlanStatus(statusKey);
      const amountLabel = p.type === "recurring"
        ? toBRL(p.amountEachCents || 0)
        : `${toBRL(p.amountTotalCents || 0)} / ${p.monthsTotal || "-"}`;
      const generated = p.generatedThrough ? `Gerado ate ${p.generatedThrough}` : "Sem geracao";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(p.title || "Plano")}${generated ? `<div class="muted" style="margin-top:4px;">${escapeHtml(generated)}</div>` : ""}</td>
        <td>${escapeHtml(typeLabel)}</td>
        <td class="right nowrap">${escapeHtml(amountLabel)}</td>
        <td class="right nowrap">${escapeHtml(p.startMonth || "-")}</td>
        <td><span class="badge">${escapeHtml(statusLabel)}</span></td>
        <td class="right actions">
          <button class="ghost" data-plan-generate="${p.id}">${p.type === "recurring" ? "Gerar +12" : "Gerar"}</button>
          ${statusKey === "paused" ? `<button class="ghost" data-plan-resume="${p.id}">Retomar</button>` : ""}
          ${statusKey === "active" ? `<button class="ghost" data-plan-pause="${p.id}">Pausar</button>` : ""}
          ${statusKey !== "canceled" ? `<button class="ghost" data-plan-cancel="${p.id}">Cancelar</button>` : ""}
        </td>
      `;
      planTable.appendChild(tr);
    }

    planTable.querySelectorAll("button[data-plan-generate]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-plan-generate");
        await generatePlanById(id);
      });
    });
    planTable.querySelectorAll("button[data-plan-resume]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-plan-resume");
        await updatePlanStatus(id, "active");
      });
    });
    planTable.querySelectorAll("button[data-plan-pause]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-plan-pause");
        await updatePlanStatus(id, "paused");
      });
    });
    planTable.querySelectorAll("button[data-plan-cancel]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-plan-cancel");
        if (!confirm("Cancelar este plano?")) return;
        await updatePlanStatus(id, "canceled");
      });
    });
  }

  async function updatePlanStatus(planId, status) {
    if (!planId) return;
    try {
      await setDoc(doc(db, "wallets", state.walletId, "plans", planId), {
        status,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
      await loadPlans();
    } catch {
      if (planStatus) planStatus.textContent = "Nao foi possivel atualizar o plano.";
    }
  }

  async function getPlan(planId) {
    const ref = doc(db, "wallets", state.walletId, "plans", planId);
    const snap = await getDoc(ref);
    if (!snap.exists()) return null;
    return { id: planId, ...snap.data() };
  }

  function buildPlanNote(plan, index, total) {
    const base = plan.title || plan.categoryName || "Plano";
    if (total && index) return `${base} (${index}/${total})`;
    return base;
  }

  function buildPlanV2Fields(plan, index, total) {
    const baseType = plan.txnType || "expense";
    const v2 = buildTxnV2Defaults(baseType, baseType);

    if (plan.type === "recurring") {
      v2.recurring = { isRecurring: true, cadence: "monthly" };
    } else if (plan.type === "installment" || plan.type === "credit_installment") {
      v2.installment = { isInstallment: true, total, current: index };
    } else if (plan.type === "finance") {
      v2.finance = { isFinance: true, total, current: index };
    }

    v2.paymentMethod = plan.paymentMethod || v2.paymentMethod;
    return v2;
  }

  async function createPlanFromTxnForm({
    planMode,
    dateStr,
    type,
    catId,
    categoryName,
    amountCents,
    note,
    paymentMethod
  }) {
    if (!planMode) return;
    if (txnStatus) txnStatus.textContent = "";
    if (!isPersonalWalletId(state.walletId)) {
      setOpsError("Planos so podem ser criados em carteiras pessoais.");
      return;
    }

    const title = note || categoryName || "Plano";
    let startMonth = yyyyMMFromDateStr(dateStr);
    if (!startMonth) {
      setOpsError("Informe um mes valido.");
      return;
    }

    let monthsTotal = null;
    let amountTotalCents = amountCents;
    let amountEachCents = amountCents;

    if (planMode === "installment" || planMode === "credit_installment") {
      monthsTotal = parsePositiveInt(installmentTotal?.value);
      if (!monthsTotal) {
        setOpsError("Informe o numero de parcelas.");
        return;
      }
      amountEachCents = Math.floor(amountTotalCents / monthsTotal);
    } else if (planMode === "finance") {
      monthsTotal = parsePositiveInt(financeTotal?.value);
      if (!monthsTotal) {
        setOpsError("Informe o numero de parcelas.");
        return;
      }
      amountEachCents = Math.floor(amountTotalCents / monthsTotal);
    }

    if (planMode === "finance" && paymentMethod === "credito") {
      setOpsError("Financiamento nao usa cartao de credito.");
      return;
    }

    let creditCardId = null;
    let purchaseDate = null;
    let statementStartMonth = null;

    if (planMode === "credit_installment" || (planMode === "recurring" && paymentMethod === "credito")) {
      creditCardId = txnCard?.value || "";
      if (!creditCardId) {
        setOpsError("Selecione um cartao.");
        return;
      }
      const purchaseDateStr = txnPurchaseDate?.value || dateStr;
      const purchaseDateObj = new Date(purchaseDateStr + "T00:00:00");
      purchaseDate = Timestamp.fromDate(purchaseDateObj);
      const closingDay = getCardClosingDay(creditCardId);
      statementStartMonth = computeStatementMonth(purchaseDateObj, closingDay);
      if (planMode === "credit_installment" && statementStartMonth) {
        startMonth = statementStartMonth;
      }
    }

    btnAddTxn.disabled = true;
    btnAddTxn.textContent = "Gerando...";

    try {
      const planRef = doc(collection(db, "wallets", state.walletId, "plans"));
      const planPayment = planMode === "credit_installment" ? "credito" : (paymentMethod || "outro");
      const payload = {
        type: planMode,
        title,
        walletId: state.walletId,
        txnType: type,
        categoryId: catId,
        categoryName,
        amountTotalCents,
        amountEachCents,
        startMonth,
        monthsTotal: monthsTotal ?? null,
        generatedThrough: null,
        status: "active",
        paymentMethod: planPayment,
        creditCardId: creditCardId || null,
        statementStartMonth: statementStartMonth || null,
        purchaseDate: purchaseDate || null,
        paidCount: monthsTotal ? 0 : null,
        remainingCount: monthsTotal ? monthsTotal : null,
        createdAt: serverTimestamp(),
        createdBy: state.uid,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      };

      await setDoc(planRef, payload);

      if (planMode === "recurring") await generateRecurring(planRef.id, payload);
      else if (planMode === "installment") await generateInstallments(planRef.id, payload);
      else if (planMode === "finance") await generateFinance(planRef.id, payload);
      else if (planMode === "credit_installment") await generateCreditInstallments(planRef.id, payload);

      txnAmount.value = "";
      txnNote.value = "";
      if (txnPayment) txnPayment.value = "";
      if (txnCard) txnCard.value = "";
      if (txnStatementMonth) txnStatementMonth.value = "";
      cbRecurring.checked = false;
      cbInstallment.checked = false;
      cbFinance.checked = false;
      syncOptionalFields();
      syncCreditTxnFields();

      txnStatus.textContent = "Plano gerado com sucesso.";
      await loadPlans();
      await reloadAll();
    } catch (e) {
      console.error("createPlanFromTxnForm failed", e);
      setOpsError("Nao foi possivel gerar o plano. Verifique sua permissao.");
    } finally {
      btnAddTxn.disabled = false;
      btnAddTxn.textContent = "Adicionar";
    }
  }

  async function createPlanAndGenerate() {
    if (!btnCreatePlan || !planStatus) return;
    planStatus.textContent = "";

    if (!isPersonalWalletId(state.walletId)) {
      planStatus.textContent = "Planos so podem ser criados em carteiras pessoais.";
      return;
    }

    const type = planType?.value || "recurring";
    const title = (planTitle?.value ?? "").trim();
    const txnKind = planTxnType?.value || "expense";
    const categoryId = planCategory?.value || "";
    const cat = state.categories.get(categoryId);
    const categoryName = cat?.name ?? (planCategory?.options[planCategory.selectedIndex]?.textContent ?? "");

    if (!title) { planStatus.textContent = "Informe a descricao do plano."; return; }
    if (!categoryId) { planStatus.textContent = "Selecione uma categoria."; return; }

    let amountTotalCents = null;
    let amountEachCents = null;
    let monthsTotal = null;

    if (type === "recurring") {
      amountEachCents = parseAmountToCents(planAmountEach?.value);
      if (!amountEachCents || amountEachCents <= 0) { planStatus.textContent = "Informe o valor mensal."; return; }
      amountTotalCents = amountEachCents;
    } else {
      amountTotalCents = parseAmountToCents(planAmountTotal?.value);
      monthsTotal = parsePositiveInt(planMonthsTotal?.value);
      if (!amountTotalCents || amountTotalCents <= 0) { planStatus.textContent = "Informe o valor total."; return; }
      if (!monthsTotal || monthsTotal <= 0) { planStatus.textContent = "Informe o numero de meses."; return; }
      amountEachCents = Math.floor(amountTotalCents / monthsTotal);
    }

    let startMonth = yyyyMMFromMonthInput(planStartMonth?.value);
    if (!startMonth) startMonth = currentYYYYMM();
    if (!startMonth) { planStatus.textContent = "Informe o mes inicial."; return; }

    let paymentMethod = planPaymentMethod?.value || "outro";
    let creditCardId = null;
    let purchaseDate = null;
    let statementStartMonth = null;

    if (type === "credit_installment") {
      paymentMethod = "credito";
      creditCardId = planCreditCard?.value || "";
      if (!creditCardId) { planStatus.textContent = "Selecione um cartao."; return; }

      const purchaseDateStr = planPurchaseDate?.value || "";
      if (!purchaseDateStr) { planStatus.textContent = "Informe a data da compra."; return; }
      const purchaseDateObj = new Date(purchaseDateStr + "T00:00:00");
      purchaseDate = Timestamp.fromDate(purchaseDateObj);
      const closingDay = getCardClosingDay(creditCardId);
      statementStartMonth = computeStatementMonth(purchaseDateObj, closingDay);
    }

    btnCreatePlan.disabled = true;
    btnCreatePlan.textContent = "Gerando...";

    try {
      const planRef = doc(collection(db, "wallets", state.walletId, "plans"));
      const payload = {
        type,
        title,
        walletId: state.walletId,
        txnType: txnKind,
        categoryId,
        categoryName,
        amountTotalCents,
        amountEachCents,
        startMonth,
        monthsTotal: monthsTotal ?? null,
        generatedThrough: null,
        status: "active",
        paymentMethod,
        creditCardId: creditCardId || null,
        statementStartMonth: statementStartMonth || null,
        purchaseDate: purchaseDate || null,
        paidCount: monthsTotal ? 0 : null,
        remainingCount: monthsTotal ? monthsTotal : null,
        createdAt: serverTimestamp(),
        createdBy: state.uid,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      };

      await setDoc(planRef, payload);

      if (type === "recurring") await generateRecurring(planRef.id, payload);
      else if (type === "installment") await generateInstallments(planRef.id, payload);
      else if (type === "finance") await generateFinance(planRef.id, payload);
      else if (type === "credit_installment") await generateCreditInstallments(planRef.id, payload);

      planTitle.value = "";
      planAmountEach.value = "";
      planAmountTotal.value = "";
      planMonthsTotal.value = "";
      syncPlanFields();
      planStatus.textContent = "Plano gerado com sucesso.";
      await loadPlans();
      await reloadAll();
    } catch (e) {
      console.error("createPlanAndGenerate failed", e);
      planStatus.textContent = "Nao foi possivel gerar o plano. Verifique sua permissao.";
    } finally {
      btnCreatePlan.disabled = false;
      btnCreatePlan.textContent = "Gerar agora";
    }
  }

  async function generatePlanById(planId) {
    if (!planId) return;
    const plan = await getPlan(planId);
    if (!plan) return;
    if (plan.status === "canceled") {
      if (planStatus) planStatus.textContent = "Plano cancelado.";
      return;
    }
    if (plan.status === "paused") {
      if (planStatus) planStatus.textContent = "Plano pausado.";
      return;
    }
    if (plan.type === "recurring") await generateRecurring(planId, plan);
    else if (plan.type === "installment") await generateInstallments(planId, plan);
    else if (plan.type === "finance") await generateFinance(planId, plan);
    else if (plan.type === "credit_installment") await generateCreditInstallments(planId, plan);
    await loadPlans();
    await reloadAll();
  }

  async function ensureGeneratedUpTo(planId, targetMonth) {
    const plan = await getPlan(planId);
    if (!plan || plan.type !== "recurring") return;

    if (plan.status !== "active") {
      if (planStatus) planStatus.textContent = "Plano pausado ou cancelado.";
      return;
    }

    let current = plan.generatedThrough ? addMonthsYYYYMM(plan.generatedThrough, 1) : plan.startMonth;
    if (!current || !targetMonth) return;

    let lastGenerated = null;
    while (compareYYYYMM(current, targetMonth) <= 0) {
      const index = monthDiff(plan.startMonth, current) + 1;
      const txnId = `r_${planId}_${current}`;
      const v2 = buildPlanV2Fields(plan, index, null);
      let creditFields = {};
      if (plan.paymentMethod === "credito" && plan.creditCardId) {
        const baseDay = plan.purchaseDate?.toDate?.().getDate?.() ?? 1;
        const parsed = parseYYYYMM(current);
        if (parsed) {
          const day = Math.min(baseDay, 28);
          const purchaseDateObj = new Date(parsed.y, parsed.m - 1, day);
          const closingDay = getCardClosingDay(plan.creditCardId);
          const statementMonth = computeStatementMonth(purchaseDateObj, closingDay);
          creditFields = {
            creditCardId: plan.creditCardId,
            statementMonth,
            purchaseDate: Timestamp.fromDate(purchaseDateObj)
          };
        }
      }
      const payload = {
        date: timestampFromYYYYMM(current),
        amountCents: plan.amountEachCents || 0,
        type: plan.txnType || "expense",
        categoryId: plan.categoryId,
        categoryName: plan.categoryName,
        note: buildPlanNote(plan, index, null),
        ...v2,
        planId,
        planType: plan.type,
        occurrenceIndex: index,
        occurrenceTotal: null,
        ...creditFields,
        status: "scheduled"
      };
      await createTxnWithDerivations(payload, { walletId: plan.walletId, txnId });
      lastGenerated = current;
      current = addMonthsYYYYMM(current, 1);
    }

    if (lastGenerated) {
      await setDoc(doc(db, "wallets", plan.walletId, "plans", planId), {
        generatedThrough: lastGenerated,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
    }
  }

  async function generateRecurring(planId, planOverride = null) {
    const plan = planOverride || await getPlan(planId);
    if (!plan) return;
    const start = plan.generatedThrough ? addMonthsYYYYMM(plan.generatedThrough, 1) : plan.startMonth;
    if (!start) return;
    const target = addMonthsYYYYMM(start, 11);
    await ensureGeneratedUpTo(planId, target);
  }

  async function generateInstallments(planId, planOverride = null) {
    const plan = planOverride || await getPlan(planId);
    if (!plan || !plan.monthsTotal) return;
    if (plan.status !== "active") return;

    const amounts = splitAmountByMonths(plan.amountTotalCents || 0, plan.monthsTotal);
    let lastMonth = null;

    for (let i = 1; i <= plan.monthsTotal; i += 1) {
      const month = addMonthsYYYYMM(plan.startMonth, i - 1);
      const txnId = `p_${planId}_${String(i).padStart(2, "0")}`;
      const v2 = buildPlanV2Fields(plan, i, plan.monthsTotal);
      const payload = {
        date: timestampFromYYYYMM(month),
        amountCents: amounts[i - 1] ?? plan.amountEachCents ?? 0,
        type: plan.txnType || "expense",
        categoryId: plan.categoryId,
        categoryName: plan.categoryName,
        note: buildPlanNote(plan, i, plan.monthsTotal),
        ...v2,
        planId,
        planType: plan.type,
        occurrenceIndex: i,
        occurrenceTotal: plan.monthsTotal,
        status: "scheduled"
      };
      await createTxnWithDerivations(payload, { walletId: plan.walletId, txnId });
      lastMonth = month;
    }

    if (lastMonth) {
      await setDoc(doc(db, "wallets", plan.walletId, "plans", planId), {
        generatedThrough: lastMonth,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
    }
  }

  async function generateFinance(planId, planOverride = null) {
    const plan = planOverride || await getPlan(planId);
    if (!plan || !plan.monthsTotal) return;
    if (plan.status !== "active") return;

    const amounts = splitAmountByMonths(plan.amountTotalCents || 0, plan.monthsTotal);
    let lastMonth = null;

    for (let i = 1; i <= plan.monthsTotal; i += 1) {
      const month = addMonthsYYYYMM(plan.startMonth, i - 1);
      const txnId = `f_${planId}_${String(i).padStart(2, "0")}`;
      const v2 = buildPlanV2Fields(plan, i, plan.monthsTotal);
      const payload = {
        date: timestampFromYYYYMM(month),
        amountCents: amounts[i - 1] ?? plan.amountEachCents ?? 0,
        type: plan.txnType || "expense",
        categoryId: plan.categoryId,
        categoryName: plan.categoryName,
        note: buildPlanNote(plan, i, plan.monthsTotal),
        ...v2,
        planId,
        planType: plan.type,
        occurrenceIndex: i,
        occurrenceTotal: plan.monthsTotal,
        status: "scheduled"
      };
      await createTxnWithDerivations(payload, { walletId: plan.walletId, txnId });
      lastMonth = month;
    }

    if (lastMonth) {
      await setDoc(doc(db, "wallets", plan.walletId, "plans", planId), {
        generatedThrough: lastMonth,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
    }
  }

  async function generateCreditInstallments(planId, planOverride = null) {
    const plan = planOverride || await getPlan(planId);
    if (!plan || !plan.monthsTotal) return;
    if (plan.status !== "active") return;
    if (!plan.creditCardId || !plan.statementStartMonth) return;

    const amounts = splitAmountByMonths(plan.amountTotalCents || 0, plan.monthsTotal);
    let lastMonth = null;

    for (let i = 1; i <= plan.monthsTotal; i += 1) {
      const statementMonth = addMonthsYYYYMM(plan.statementStartMonth, i - 1);
      const txnId = `cc_${planId}_${statementMonth}`;
      const v2 = buildPlanV2Fields(plan, i, plan.monthsTotal);
      v2.paymentMethod = "credito";
      const payload = {
        date: timestampFromYYYYMM(statementMonth),
        amountCents: amounts[i - 1] ?? plan.amountEachCents ?? 0,
        type: plan.txnType || "expense",
        categoryId: plan.categoryId,
        categoryName: plan.categoryName,
        note: buildPlanNote(plan, i, plan.monthsTotal),
        ...v2,
        planId,
        planType: plan.type,
        occurrenceIndex: i,
        occurrenceTotal: plan.monthsTotal,
        status: "scheduled",
        creditCardId: plan.creditCardId,
        statementMonth,
        purchaseDate: plan.purchaseDate || null
      };
      await createTxnWithDerivations(payload, { walletId: plan.walletId, txnId });
      lastMonth = statementMonth;
    }

    if (lastMonth) {
      await setDoc(doc(db, "wallets", plan.walletId, "plans", planId), {
        generatedThrough: lastMonth,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
    }
  }

  // ===== Transactions write (derivations) =====

  async function createTxnWithDerivations(txnPayload, { walletId = state.walletId, txnId = null } = {}) {
    const personalWalletId = walletId;
    const shouldSyncToCouple = isPersonalWalletId(personalWalletId);

    const personalCol = collection(db, "wallets", personalWalletId, "transactions");
    const personalRef = txnId ? doc(personalCol, txnId) : doc(personalCol);
    const realTxnId = personalRef.id;
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${personalWalletId}_${realTxnId}`);

    const month = yyyyMMFromTimestamp(txnPayload.date);
    if (!month) throw new Error("Data invalida.");

    const reportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", month);

    const needsStatement = txnPayload.paymentMethod === "credito" && txnPayload.creditCardId && txnPayload.statementMonth;
    const statementRef = needsStatement ? getStatementRef(personalWalletId, txnPayload.creditCardId, txnPayload.statementMonth) : null;

    await runTransaction(db, async (tx) => {
      const txnSnap = await tx.get(personalRef);
      if (txnSnap.exists()) return;

      let repSnap = null;
      let repData = null;
      let repExists = false;
      let stmtSnap = null;

      if (shouldSyncToCouple) {
        repSnap = await tx.get(reportRef);
        repExists = repSnap.exists();
        repData = repExists ? repSnap.data() : null;
      }

      if (needsStatement && statementRef) {
        stmtSnap = await tx.get(statementRef);
      }

      const basePayload = {
        ...txnPayload,
        createdAt: serverTimestamp(),
        createdBy: state.uid
      };

      tx.set(personalRef, basePayload, { merge: true });

      if (shouldSyncToCouple) {
        tx.set(viewRef, {
          ...basePayload,
          sourceWalletId: personalWalletId,
          sourceTxnId: realTxnId,
          sourceUid: state.uid,
          syncedAt: serverTimestamp()
        }, { merge: true });

        const deltaIncome = (txnPayload.type === "income") ? Number(txnPayload.amountCents || 0) : 0;
        const deltaExpense = (txnPayload.type === "expense") ? Number(txnPayload.amountCents || 0) : 0;

        const { nextIncome, nextExpense } = computeCoupleSourceNext(repData, personalWalletId, deltaIncome, deltaExpense);

        const reportPatch = {
          month,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid,
          sources: {
            [personalWalletId]: {
              incomeCents: nextIncome,
              expenseCents: nextExpense,
              updatedAt: serverTimestamp(),
              updatedBy: state.uid
            }
          }
        };

        const mergeFields = ["month", "updatedAt", "updatedBy", `sources.${personalWalletId}`];
        if (!repExists) {
          reportPatch.createdAt = serverTimestamp();
          reportPatch.createdBy = state.uid;
          mergeFields.push("createdAt", "createdBy");
        }
        tx.set(reportRef, reportPatch, { mergeFields });
      }

      if (needsStatement && statementRef) {
        const currentTotal = Number(stmtSnap?.data()?.totalCents || 0);
        const delta = statementSignedAmount(txnPayload.amountCents, txnPayload.type);
        const nextTotal = currentTotal + delta;
        const patch = {
          month: txnPayload.statementMonth,
          totalCents: nextTotal,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid
        };
        if (!stmtSnap?.exists?.()) {
          patch.status = "open";
          patch.paidAt = null;
          patch.createdAt = serverTimestamp();
          patch.createdBy = state.uid;
        }
        tx.set(statementRef, patch, { merge: true });
      }
    });
  }

  async function updateTxnWithDerivations(txnId, updates, { walletId = state.walletId } = {}) {
    const personalWalletId = walletId;
    const shouldSyncToCouple = isPersonalWalletId(personalWalletId);
    const personalRef = doc(db, "wallets", personalWalletId, "transactions", txnId);
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${personalWalletId}_${txnId}`);

    await runTransaction(db, async (tx) => {
      const txnSnap = await tx.get(personalRef);
      if (!txnSnap.exists()) throw new Error("Transacao nao encontrada.");

      const existingRaw = txnSnap.data();
      const existing = normalizeTxnV2(existingRaw);
      const nextRaw = { ...existingRaw, ...updates };
      const next = normalizeTxnV2(nextRaw);

      const oldAmount = Number(existing.amountCents || 0);
      const newAmount = Number(next.amountCents || 0);
      const oldType = existing.type ?? "expense";
      const newType = next.type ?? "expense";
      const oldMonth = yyyyMMFromTimestamp(existing.date);
      const newMonth = yyyyMMFromTimestamp(next.date);
      if (!oldMonth || !newMonth) throw new Error("Data invalida.");

      let oldRepSnap = null;
      let newRepSnap = null;
      let oldReportRef = null;
      let newReportRef = null;

      if (shouldSyncToCouple) {
        oldReportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", oldMonth);
        oldRepSnap = await tx.get(oldReportRef);
        if (newMonth === oldMonth) {
          newReportRef = oldReportRef;
          newRepSnap = oldRepSnap;
        } else {
          newReportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", newMonth);
          newRepSnap = await tx.get(newReportRef);
        }
      }

      const oldStmtKey = getStatementKey(existing);
      const newStmtKey = getStatementKey(next);
      let oldStmtSnap = null;
      let newStmtSnap = null;
      let oldStmtRef = null;
      let newStmtRef = null;

      if (oldStmtKey) {
        oldStmtRef = getStatementRef(personalWalletId, oldStmtKey.cardId, oldStmtKey.month);
        oldStmtSnap = await tx.get(oldStmtRef);
      }
      if (newStmtKey) {
        newStmtRef = getStatementRef(personalWalletId, newStmtKey.cardId, newStmtKey.month);
        if (!oldStmtKey || oldStmtKey.cardId !== newStmtKey.cardId || oldStmtKey.month !== newStmtKey.month) {
          newStmtSnap = await tx.get(newStmtRef);
        } else {
          newStmtSnap = oldStmtSnap;
        }
      }

      tx.set(personalRef, {
        ...updates,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });

      if (shouldSyncToCouple) {
        tx.set(viewRef, {
          ...next,
          sourceWalletId: personalWalletId,
          sourceTxnId: txnId,
          sourceUid: existing.sourceUid || state.uid,
          syncedAt: serverTimestamp()
        }, { merge: true });

        const oldIncome = oldType === "income" ? oldAmount : 0;
        const oldExpense = oldType === "expense" ? oldAmount : 0;
        const newIncome = newType === "income" ? newAmount : 0;
        const newExpense = newType === "expense" ? newAmount : 0;

        const applyReportUpdate = (repRef, repSnap, deltaIncome, deltaExpense) => {
          const repExists = repSnap?.exists?.() ?? false;
          const repData = repExists ? repSnap.data() : null;
          const { nextIncome, nextExpense } = computeCoupleSourceNext(repData, personalWalletId, deltaIncome, deltaExpense);

          const patch = {
            month: repRef.id,
            updatedAt: serverTimestamp(),
            updatedBy: state.uid,
            sources: {
              [personalWalletId]: {
                incomeCents: nextIncome,
                expenseCents: nextExpense,
                updatedAt: serverTimestamp(),
                updatedBy: state.uid
              }
            }
          };
          const mergeFields = ["month", "updatedAt", "updatedBy", `sources.${personalWalletId}`];
          if (!repExists) {
            patch.createdAt = serverTimestamp();
            patch.createdBy = state.uid;
            mergeFields.push("createdAt", "createdBy");
          }
          tx.set(repRef, patch, { mergeFields });
        };

        if (newMonth === oldMonth) {
          applyReportUpdate(oldReportRef, oldRepSnap, newIncome - oldIncome, newExpense - oldExpense);
        } else {
          applyReportUpdate(oldReportRef, oldRepSnap, -oldIncome, -oldExpense);
          applyReportUpdate(newReportRef, newRepSnap, newIncome, newExpense);
        }
      }

      const applyStatementUpdate = (stmtRef, stmtSnap, delta) => {
        if (!stmtRef || !delta) return;
        const currentTotal = Number(stmtSnap?.data()?.totalCents || 0);
        const nextTotal = currentTotal + delta;
        const patch = {
          month: stmtRef.id,
          totalCents: nextTotal,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid
        };
        if (!stmtSnap?.exists?.()) {
          patch.status = "open";
          patch.paidAt = null;
          patch.createdAt = serverTimestamp();
          patch.createdBy = state.uid;
        }
        tx.set(stmtRef, patch, { merge: true });
      };

      const oldSigned = statementSignedAmount(oldAmount, oldType);
      const newSigned = statementSignedAmount(newAmount, newType);

      if (oldStmtRef && newStmtRef && oldStmtRef.path === newStmtRef.path) {
        const delta = newSigned - oldSigned;
        applyStatementUpdate(oldStmtRef, oldStmtSnap, delta);
      } else {
        if (oldStmtRef) applyStatementUpdate(oldStmtRef, oldStmtSnap, -oldSigned);
        if (newStmtRef) applyStatementUpdate(newStmtRef, newStmtSnap, newSigned);
      }
    });
  }

  async function deleteTxnWithDerivations(txnId, { walletId = state.walletId } = {}) {
    const personalWalletId = walletId;
    if (!isPersonalWalletId(personalWalletId)) return;
    const personalRef = doc(db, "wallets", personalWalletId, "transactions", txnId);
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${personalWalletId}_${txnId}`);

    await runTransaction(db, async (tx) => {
      const txnSnap = await tx.get(personalRef);
      if (!txnSnap.exists()) return;

      const existing = normalizeTxnV2(txnSnap.data());
      const amount = Number(existing.amountCents || 0);
      const type = existing.type ?? "expense";
      const month = yyyyMMFromTimestamp(existing.date);
      if (!month) return;

      let repSnap = null;
      let repData = null;
      let repExists = false;
      const reportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", month);

      if (isPersonalWalletId(personalWalletId)) {
        repSnap = await tx.get(reportRef);
        repExists = repSnap.exists();
        repData = repExists ? repSnap.data() : null;
      }

      const stmtKey = getStatementKey(existing);
      const stmtRef = stmtKey ? getStatementRef(personalWalletId, stmtKey.cardId, stmtKey.month) : null;
      const stmtSnap = stmtRef ? await tx.get(stmtRef) : null;

      tx.delete(personalRef);
      tx.delete(viewRef);

      const deltaIncome = (type === "income") ? -amount : 0;
      const deltaExpense = (type === "expense") ? -amount : 0;

      if (repData || repExists) {
        const { nextIncome, nextExpense } = computeCoupleSourceNext(repData, personalWalletId, deltaIncome, deltaExpense);
        const reportPatch = {
          month,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid,
          sources: {
            [personalWalletId]: {
              incomeCents: nextIncome,
              expenseCents: nextExpense,
              updatedAt: serverTimestamp(),
              updatedBy: state.uid
            }
          }
        };
        const mergeFields = ["month", "updatedAt", "updatedBy", `sources.${personalWalletId}`];
        if (!repExists) {
          reportPatch.createdAt = serverTimestamp();
          reportPatch.createdBy = state.uid;
          mergeFields.push("createdAt", "createdBy");
        }
        tx.set(reportRef, reportPatch, { mergeFields });
      }

      if (stmtRef) {
        const currentTotal = Number(stmtSnap?.data()?.totalCents || 0);
        const delta = -statementSignedAmount(amount, type);
        const nextTotal = currentTotal + delta;
        const patch = {
          month: stmtRef.id,
          totalCents: nextTotal,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid
        };
        if (!stmtSnap?.exists?.()) {
          patch.status = "open";
          patch.paidAt = null;
          patch.createdAt = serverTimestamp();
          patch.createdBy = state.uid;
        }
        tx.set(stmtRef, patch, { merge: true });
      }
    });
  }

  async function markOccurrencePaid(txnId) {
    if (!isPersonalWalletId(state.walletId)) return;
    const personalRef = doc(db, "wallets", state.walletId, "transactions", txnId);
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${state.walletId}_${txnId}`);

    await runTransaction(db, async (tx) => {
      const txnSnap = await tx.get(personalRef);
      if (!txnSnap.exists()) return;
      const txn = txnSnap.data();
      if (txn.status === "paid") return;

      tx.set(personalRef, {
        status: "paid",
        paidAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });

      tx.set(viewRef, {
        status: "paid",
        paidAt: serverTimestamp(),
        syncedAt: serverTimestamp()
      }, { merge: true });

      if (txn.planId) {
        const planRef = doc(db, "wallets", state.walletId, "plans", txn.planId);
        const planSnap = await tx.get(planRef);
        if (planSnap.exists()) {
          const plan = planSnap.data();
          const monthsTotal = Number(plan.monthsTotal || 0);
          const paidCount = Number(plan.paidCount || 0) + 1;
          const patch = {
            paidCount,
            updatedAt: serverTimestamp(),
            updatedBy: state.uid
          };
          if (monthsTotal) {
            patch.remainingCount = Math.max(0, monthsTotal - paidCount);
            if (paidCount >= monthsTotal) patch.status = "completed";
          }
          tx.set(planRef, patch, { merge: true });
        }
      }
    });
  }

  async function prepareEditModal(txnId) {
    if (!editModal || !editTxnDate || !editTxnType || !editTxnCat || !editTxnAmount || !editTxnNote || !editStatus || !editError) {
      return;
    }
    editError.textContent = "";
    editStatus.textContent = "";

    if (!isPersonalWalletId(state.walletId)) {
      editError.textContent = "Edição só é permitida em wallets pessoais.";
      return;
    }

    let txn = state.txnCache.get(txnId);
    if (!txn) {
      try {
        const snap = await getDoc(doc(db, "wallets", state.walletId, "transactions", txnId));
        if (snap.exists()) {
          const data = normalizeTxnV2(snap.data());
          txn = {
            id: txnId,
            date: data.date?.toDate?.() ?? null,
            amountCents: Number(data.amountCents || 0),
            type: data.type ?? "expense",
            categoryId: data.categoryId ?? "",
            categoryName: data.categoryName ?? "",
            note: data.note ?? ""
          };
        }
      } catch (e) {
        editError.textContent = e?.message ?? String(e);
        return;
      }
    }

    if (!txn) {
      editError.textContent = "Transação não encontrada para edição.";
      return;
    }

    if (txn.date) editTxnDate.value = toISODateLocal(txn.date);
    editTxnType.value = txn.type || "expense";
    setCategoryOptions(editTxnCat, txn.categoryId || "", txn.categoryName || "Categoria removida");
    editTxnAmount.value = formatCentsToInputValue(txn.amountCents);
    editTxnNote.value = txn.note || "";

    openEditModal(txnId);
  }

  async function addTransaction() {
    setOpsError("");

    if (isCoupleWallet()) {
      setOpsError("Esta visao consolidada e somente leitura. Lance receitas e despesas em uma carteira pessoal.");
      return;
    }

    const dateStr = txnDate.value;
    if (!dateStr) { setOpsError("Informe a data."); return; }

    const rawType = txnType.value;
    const type = rawType === "reserve" ? "expense" : rawType;
    const txnV2 = buildTxnV2Payload(rawType, type);
    const catId = txnCat.value;
    if (!catId) { setOpsError("Selecione uma categoria."); return; }

    const amountCents = parseAmountToCents(txnAmount.value);
    if (amountCents == null || amountCents <= 0) {
      setOpsError("Informe um valor valido (maior que zero).");
      return;
    }

    const note = (txnNote.value ?? "").trim();
    const cat = state.categories.get(catId);
    const categoryName = cat?.name ?? "";

    const wantsRecurring = !!cbRecurring?.checked;
    const wantsInstallment = !!cbInstallment?.checked;
    const wantsFinance = !!cbFinance?.checked;

    if ((wantsInstallment && wantsFinance) || (wantsRecurring && (wantsInstallment || wantsFinance))) {
      setOpsError("Escolha apenas uma opcao de plano.");
      return;
    }

    let planMode = "";
    if (wantsFinance) planMode = "finance";
    else if (wantsInstallment) planMode = (txnV2.paymentMethod === "credito" ? "credit_installment" : "installment");
    else if (wantsRecurring) planMode = "recurring";

    if (planMode) {
      await createPlanFromTxnForm({
        planMode,
        dateStr,
        type,
        catId,
        categoryName,
        amountCents,
        note,
        paymentMethod: txnV2.paymentMethod
      });
      return;
    }

    const personalWalletId = state.walletId;

    let creditCardId = null;
    let statementMonth = null;
    let purchaseDate = null;

    if (txnV2.paymentMethod === "credito") {
      creditCardId = txnCard?.value || "";
      if (!creditCardId) { setOpsError("Selecione um cartao."); return; }

      const purchaseDateStr = txnPurchaseDate?.value || dateStr;
      const purchaseDateObj = new Date(purchaseDateStr + "T00:00:00");
      const closingDay = getCardClosingDay(creditCardId);
      statementMonth = computeStatementMonth(purchaseDateObj, closingDay);
      purchaseDate = Timestamp.fromDate(purchaseDateObj);
    }

    btnAddTxn.disabled = true;
    btnAddTxn.textContent = "Salvando...";

    try {
      const dt = new Date(dateStr + "T00:00:00");
      const ts = Timestamp.fromDate(dt);

      const txnPayload = {
        date: ts,
        amountCents,
        type,
        categoryId: catId,
        categoryName,
        note,
        ...txnV2,
        creditCardId,
        statementMonth,
        purchaseDate
      };

      await createTxnWithDerivations(txnPayload, { walletId: personalWalletId });

      txnAmount.value = "";
      txnNote.value = "";
      if (txnPayment) txnPayment.value = "";
      if (txnCard) txnCard.value = "";
      if (txnStatementMonth) txnStatementMonth.value = "";
      syncCreditTxnFields();

      await reloadAll();
    } catch (e) {
      console.error("addTransaction failed", e);
      setOpsError("Nao foi possivel salvar a transacao. Tente novamente.");
    } finally {
      btnAddTxn.disabled = false;
      btnAddTxn.textContent = "Adicionar";
    }
  }

  async function deleteTransactionPersonalAndSync(txnId) {
    setOpsError("");

    const personalWalletId = state.walletId;
    if (!isPersonalWalletId(personalWalletId)) {
      setOpsError("Para excluir aqui, escolha uma carteira pessoal.");
      return;
    }

    try {
      await deleteTxnWithDerivations(txnId, { walletId: personalWalletId });
      await reloadAll();
    } catch (e) {
      setOpsError("Nao foi possivel excluir a transacao. Tente novamente.");
    }
  }

  async function updateTransactionPersonalAndSync() {
    if (!editModal || !editTxnDate || !editTxnType || !editTxnCat || !editTxnAmount || !editTxnNote || !btnSaveEdit || !editError || !editStatus) {
      return;
    }
    editError.textContent = "";
    editStatus.textContent = "";

    if (!state.editingTxnId) { editError.textContent = "Nenhuma transacao selecionada."; return; }
    if (!isPersonalWalletId(state.walletId)) { editError.textContent = "Edicao so e permitida em wallets pessoais."; return; }

    const txnId = state.editingTxnId;
    const dateStr = editTxnDate.value;
    const type = editTxnType.value;
    const catId = editTxnCat.value;
    const amountCents = parseAmountToCents(editTxnAmount.value);
    const note = (editTxnNote.value ?? "").trim();

    if (!dateStr) { editError.textContent = "Informe a data."; return; }
    if (!catId) { editError.textContent = "Selecione uma categoria."; return; }
    if (amountCents == null || amountCents <= 0) { editError.textContent = "Informe um valor valido (maior que zero)."; return; }

    const cat = state.categories.get(catId);
    const categoryName = cat?.name ?? (editTxnCat.options[editTxnCat.selectedIndex]?.textContent ?? "");

    btnSaveEdit.disabled = true;
    btnSaveEdit.textContent = "Salvando...";

    try {
      const dt = new Date(dateStr + "T00:00:00");
      const ts = Timestamp.fromDate(dt);

      await updateTxnWithDerivations(txnId, {
        date: ts,
        amountCents,
        type,
        categoryId: catId,
        categoryName,
        note
      }, { walletId: state.walletId });

      editStatus.textContent = "Transacao atualizada.";
      closeEditModal();
      await reloadAll();
    } catch (e) {
      editError.textContent = e?.message ?? String(e);
    } finally {
      btnSaveEdit.disabled = false;
      btnSaveEdit.textContent = "Salvar alteracoes";
    }
  }

// ===== Transactions list / Couple views =====

  function renderTxnRows(rows, { allowDelete, isCoupleView, allowEdit }) {
    txnTable.innerHTML = "";

    for (const r of rows) {
      const dt = r.date ? toISODateLocal(r.date) : "-";
      const display = toBRL(Math.abs(r.amountCents));
      const prefix = (r.type === "income") ? "+" : "-";
      const metaParts = [];
      if (r.planType) metaParts.push(friendlyPlanType(r.planType));
      if (r.occurrenceIndex && r.occurrenceTotal) metaParts.push(`${r.occurrenceIndex}/${r.occurrenceTotal}`);
      const statusLabel = friendlyTxnStatus(r.status);
      if (statusLabel) metaParts.push(statusLabel);
      if (r.paymentMethod === "credito" && r.statementMonth) metaParts.push(`Fatura ${r.statementMonth}`);
      const extraParts = [];
      if (isCoupleView && r.sourceLabel) extraParts.push(r.sourceLabel);
      if (metaParts.length) extraParts.push(metaParts.join(" · "));
      const extraLine = extraParts.length
        ? `<div class="muted" style="margin-top:4px;">${escapeHtml(extraParts.join(" | "))}</div>`
        : "";
      const canPay = allowDelete && !isCoupleView
        && r.status && r.status !== "paid"
        && ["installment", "finance", "credit_installment"].includes(r.planType);

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="nowrap">${escapeHtml(dt)}</td>
          <td>${escapeHtml(r.categoryName || "-")}</td>
          <td>${escapeHtml(r.note || "")}${extraLine}</td>
          <td class="right nowrap">${prefix} ${escapeHtml(display)}</td>
          <td class="right nowrap">
            ${allowDelete ? `<button class="ghost" data-del-txn="${r.id}">Excluir</button>` : `<span class="muted">-</span>`}
            ${canPay ? `<button class="ghost" data-pay-txn="${r.id}" style="margin-left:6px;">Marcar paga</button>` : ""}
          </td>
        `;
      txnTable.appendChild(tr);
    }

    if (allowDelete) {
      txnTable.querySelectorAll("button[data-del-txn]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-del-txn");
          if (!confirm("Excluir esta transação? Isso também removerá do consolidado.")) return;
          await deleteTransactionPersonalAndSync(id);
        });
      });
    }

    if (allowEdit) {
      txnTable.querySelectorAll("button[data-edit-txn]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-edit-txn");
          await prepareEditModal(id);
        });
      });
    }

    if (allowDelete) {
      txnTable.querySelectorAll("button[data-pay-txn]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-pay-txn");
          await markOccurrencePaid(id);
          await reloadAll();
        });
      });
    }
  }

  async function loadCoupleTotals(yyyyMM) {
    coupleBreakdown.style.display = "";
    coupleBreakdown.innerHTML = "";
    state.currentRows = [];

    let income = 0;
    let expense = 0;

    try {
      const repRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", yyyyMM);
      const repSnap = await getDoc(repRef);

      if (!repSnap.exists()) {
        coupleBreakdown.innerHTML = `<p class="muted">Sem totais para ${escapeHtml(yyyyMM)}. Adicione lançamentos nas carteiras pessoais para gerar automaticamente.</p>`;
        return { income: 0, expense: 0, balance: 0 };
      }

      const rep = repSnap.data();
      const sources = rep.sources ?? {};

      const lines = [];
      for (const [sourceWalletId, s] of Object.entries(sources)) {
        const inc = Number(s?.incomeCents || 0);
        const exp = Number(s?.expenseCents || 0);
        income += inc;
        expense += exp;
        const label = state.walletLabels.get(sourceWalletId) ?? friendlyWalletLabel(sourceWalletId);

        lines.push(`
          <div class="kpi" style="margin-top:8px;">
            <div class="label">${escapeHtml(label)}</div>
            <div class="value">${toBRL(inc - exp)}</div>
            <div class="muted">Receitas: ${toBRL(inc)} | Despesas: ${toBRL(exp)}</div>
          </div>
        `);
      }

      coupleBreakdown.innerHTML = lines.length
        ? `<div class="muted">Quebra por fonte (somado no total acima):</div>${lines.join("")}`
        : `<p class="muted">Dados consolidados disponíveis, mas sem fontes preenchidas.</p>`;

      return { income, expense, balance: income - expense };
    } catch (e) {
      setOpsError("Não foi possível carregar o consolidado agora. Tente novamente.");
      coupleBreakdown.innerHTML = `<p class="err">Falha ao carregar o consolidado.</p>`;
      return { income: 0, expense: 0, balance: 0 };
    }
  }

  async function loadCoupleDetails(startTS, endTS) {
    try {
      const qRef = query(
        collection(db, "wallets", COUPLE_WALLET_ID, "transactions_view"),
        where("date", ">=", startTS),
        where("date", "<", endTS),
        orderBy("date", "desc")
      );

      const snaps = await getDocs(qRef);
      const rows = [];
      let income = 0, expense = 0;

      for (const d of snaps.docs) {
        const t = normalizeTxnV2(d.data());
        const amount = Number(t.amountCents || 0);
        if (t.type === "income") income += amount;
        else expense += amount;
        const sourceLabel = t.sourceWalletId ? `Fonte: ${friendlyWalletLabel(t.sourceWalletId, state.walletLabels.get(t.sourceWalletId))}` : "";

        const status = t.status ?? (t.planId ? "scheduled" : "");
        rows.push({
          id: d.id,
          date: t.date?.toDate?.() ?? null,
          categoryName: t.categoryName ?? "",
          note: t.note ?? "",
          type: t.type ?? "",
          amountCents: amount,
          sourceLabel,
          planId: t.planId ?? "",
          planType: t.planType ?? "",
          occurrenceIndex: t.occurrenceIndex ?? null,
          occurrenceTotal: t.occurrenceTotal ?? null,
          status,
          paymentMethod: t.paymentMethod ?? "",
          statementMonth: t.statementMonth ?? ""
        });
      }

      state.currentRows = rows;
      renderTxnRows(rows, { allowDelete: false, isCoupleView: true });
      coupleBreakdown.style.display = "none";

      return { income, expense, balance: income - expense };
    } catch (e) {
      setOpsError("Não foi possível carregar os detalhes do consolidado.");
      txnTable.innerHTML = "";
      return { income: 0, expense: 0, balance: 0 };
    }
  }

  async function loadTransactionsForMonth() {
    txnTable.innerHTML = "";
    txnStatus.textContent = "";
    setOpsError("");
    state.currentRows = [];
    renderDashboardMovements([]);
    dashboardStatus.textContent = "";

    let yyyyMM = yyyyMMFromMonthInput(monthInput.value);
    if (!yyyyMM) {
      yyyyMM = currentYYYYMM();
      if (yyyyMM) {
        monthInput.value = yyyyMM;
        syncMonthLabel();
      }
    }
    if (!yyyyMM) { setOpsError("Selecione um mês válido."); return { income: 0, expense: 0, balance: 0 }; }

    const { start, end } = startEndForMonth(yyyyMM);
    const startTS = Timestamp.fromDate(start);
    const endTS = Timestamp.fromDate(end);

    if (isCoupleWallet()) {
      if (state.coupleTab === "totals") {
        const totals = await loadCoupleTotals(yyyyMM);
        renderKPIs(totals.income, totals.expense);
        txnStatus.textContent = "Totais consolidados carregados.";
        renderDashboardMovements([]);
        dashboardStatus.textContent = "Use a aba Detalhes para ver os lançamentos.";
        return totals;
      } else {
        const totals = await loadCoupleDetails(startTS, endTS);
        renderKPIs(totals.income, totals.expense);
        txnStatus.textContent = "Detalhes consolidados carregados.";
        renderDashboardMovements(state.currentRows);
        dashboardStatus.textContent = state.currentRows.length ? "Movimentações consolidadas do mês." : "Sem lançamentos neste mês.";
        return totals;
      }
    }

    let income = 0;
    let expense = 0;

    try {
      const qRef = query(
        collection(db, "wallets", state.walletId, "transactions"),
        where("date", ">=", startTS),
        where("date", "<", endTS),
        orderBy("date", "desc")
      );

      const snaps = await getDocs(qRef);
      const rows = [];

      for (const d of snaps.docs) {
        const t = normalizeTxnV2(d.data());
        const amount = Number(t.amountCents || 0);
        if (t.type === "income") income += amount;
        else expense += amount;

        const status = t.status ?? (t.planId ? "scheduled" : "");
        rows.push({
          id: d.id,
          date: t.date?.toDate?.() ?? null,
          categoryName: t.categoryName ?? "",
          note: t.note ?? "",
          type: t.type ?? "",
          amountCents: amount,
          categoryId: t.categoryId ?? "",
          planId: t.planId ?? "",
          planType: t.planType ?? "",
          occurrenceIndex: t.occurrenceIndex ?? null,
          occurrenceTotal: t.occurrenceTotal ?? null,
          status,
          paymentMethod: t.paymentMethod ?? "",
          creditCardId: t.creditCardId ?? "",
          statementMonth: t.statementMonth ?? ""
        });

        state.txnCache.set(d.id, {
          id: d.id,
          date: t.date?.toDate?.() ?? null,
          categoryName: t.categoryName ?? "",
          categoryId: t.categoryId ?? "",
          note: t.note ?? "",
          type: t.type ?? "",
          amountCents: amount,
          originalType: t.originalType ?? "",
          paymentMethod: t.paymentMethod ?? "outro",
          recurring: t.recurring ?? { isRecurring: false, cadence: "none" },
          installment: t.installment ?? { isInstallment: false, total: null, current: null },
          finance: t.finance ?? { isFinance: false, total: null, current: null },
          planId: t.planId ?? "",
          planType: t.planType ?? "",
          occurrenceIndex: t.occurrenceIndex ?? null,
          occurrenceTotal: t.occurrenceTotal ?? null,
          status,
          creditCardId: t.creditCardId ?? "",
          statementMonth: t.statementMonth ?? ""
        });
      }

      state.currentRows = rows;
      renderDashboardMovements(rows);
      renderTxnRows(rows, { allowDelete: true, isCoupleView: false });
      txnStatus.textContent = `Transações no mês: ${rows.length}`;
      renderKPIs(income, expense);
      dashboardStatus.textContent = rows.length ? "Movimentações do mês selecionado." : "Sem lançamentos no mês.";

      return { income, expense, balance: income - expense };
    } catch (e) {
      setOpsError("Não foi possível carregar suas movimentações. Tente novamente.");
      renderKPIs(0, 0);
      return { income: 0, expense: 0, balance: 0 };
    }
  }

  function setCreditCardOptions(selectEl, selectedId = "", emptyLabel = "Sem cartoes") {
    if (!selectEl) return;
    selectEl.innerHTML = "";
    const entries = Array.from(state.creditCards.entries())
      .map(([id, c]) => ({ id, ...c }))
      .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));

    if (entries.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = emptyLabel;
      selectEl.appendChild(opt);
      return;
    }

    let hasSelected = false;
    for (const c of entries) {
      const opt = document.createElement("option");
      opt.value = c.id;
      opt.textContent = c.name;
      if (selectedId && selectedId === c.id) hasSelected = true;
      selectEl.appendChild(opt);
    }

    if (selectedId && hasSelected) selectEl.value = selectedId;
  }

  function listPersonalWalletsForMigration() {
    const ids = new Set(PERSONAL_WALLETS);
    const byEmail = USER_PERSONAL_WALLET[state.email];
    if (byEmail) ids.add(byEmail);
    return Array.from(ids);
  }

  async function migrateTxnV2Defaults() {
    if (!btnMigrateTxnV2 || !migrateStatus) return;
    migrateStatus.textContent = "Aplicando defaults v2...";
    const originalLabel = btnMigrateTxnV2.textContent;
    btnMigrateTxnV2.disabled = true;
    btnMigrateTxnV2.textContent = "Aplicando...";

    let scanned = 0;
    let updated = 0;
    let failures = 0;

    const personalWallets = listPersonalWalletsForMigration();
    for (const walletId of personalWallets) {
      try {
        migrateStatus.textContent = `Varredura: ${walletId}...`;
        const colRef = collection(db, "wallets", walletId, "transactions");
        const snaps = await getDocs(colRef);
        for (const snap of snaps.docs) {
          scanned += 1;
          const patch = buildTxnV2MergePatch(snap.data());
          if (Object.keys(patch).length === 0) continue;
          await setDoc(snap.ref, patch, { merge: true });
          updated += 1;
        }
      } catch {
        failures += 1;
      }
    }

    try {
      migrateStatus.textContent = "Varredura: casal...";
      const viewCol = collection(db, "wallets", COUPLE_WALLET_ID, "transactions_view");
      const snaps = await getDocs(viewCol);
      for (const snap of snaps.docs) {
        scanned += 1;
        const patch = buildTxnV2MergePatch(snap.data());
        if (Object.keys(patch).length === 0) continue;
        await setDoc(snap.ref, patch, { merge: true });
        updated += 1;
      }
    } catch {
      failures += 1;
    }

    const extra = failures ? ` (${failures} com erro)` : "";
    migrateStatus.textContent = `Defaults aplicados: ${updated} de ${scanned} transacoes${extra}.`;
    btnMigrateTxnV2.disabled = false;
    btnMigrateTxnV2.textContent = originalLabel;
  }

  async function reloadAll() {
    setOpsError("");
    if (!isCoupleWallet()) await loadCategories();
    else {
      state.categories.clear();
      txnCat.innerHTML = `<option value="">—</option>`;
      catTable.innerHTML = "";
      catStatus.textContent = "Categorias não disponíveis nesta carteira.";
    }
    await loadTransactionsForMonth();
  }

  // ===== Events =====

  const openMonthPickerCurrent = () => {
    const cur = currentYYYYMM() || yyyyMMFromDateStr(toISODateLocal(currentDateInTZ()));
    if (cur) monthInput.value = cur;
    syncMonthLabel();
    reloadAll();
  };

  const openMonthPickerInline = () => {
    if (!monthInput) return;
    try {
      if (typeof monthInput.showPicker === "function") {
        monthInput.showPicker();
        return;
      }
    } catch {}
    monthInput.focus({ preventScroll: true });
    monthInput.click();
  };

  btnEmail.addEventListener("click", async () => {
    try {
      setAuthMessage("Entrando...");
      const email = $("email").value.trim().toLowerCase();
      const pass = $("pass").value;

      if (!ALLOWED_EMAILS.has(email)) throw new Error("Este e-mail não está autorizado.");

      await signInWithEmailAndPassword(auth, email, pass);
      setAuthMessage("Login OK.");
    } catch (e) {
      const msg = e?.message ?? String(e);
      const friendly = msg.toLowerCase().includes("autoriz")
        ? msg
        : "Não foi possível entrar. Confira seus dados e tente novamente.";
      setAuthMessage(friendly, true);
    }
  });

  btnGoogle.addEventListener("click", async () => {
    try {
      setAuthMessage("Abrindo Google...");
      const provider = new GoogleAuthProvider();
      const result = await signInWithPopup(auth, provider);
      const email = (result.user.email ?? "").toLowerCase();

      if (!ALLOWED_EMAILS.has(email)) {
        await signOut(auth);
        throw new Error("Conta Google não autorizada.");
      }

      setAuthMessage("Login Google OK.");
    } catch (e) {
      const msg = e?.message ?? String(e);
      const friendly = msg.toLowerCase().includes("autoriz")
        ? msg
        : "Não foi possível entrar com Google agora. Tente novamente.";
      setAuthMessage(friendly, true);
    }
  });

  btnLogout.addEventListener("click", async () => {
    await signOut(auth);
  });

  walletSelect.addEventListener("change", refreshWalletContext);
  monthInput.addEventListener("change", reloadAll);
  monthInput.addEventListener("change", syncMonthLabel);

  if (btnMonthPrev) btnMonthPrev.addEventListener("click", () => shiftMonth(-1));
  if (btnMonthNext) btnMonthNext.addEventListener("click", () => shiftMonth(1));
  if (btnMonthPicker) btnMonthPicker.addEventListener("click", openMonthPickerCurrent);
  if (monthDisplay) monthDisplay.addEventListener("click", openMonthPickerInline);

  btnAddCat.addEventListener("click", addCategory);
  btnSeedCats.addEventListener("click", seedDefaultCategories);
  btnAddTxn.addEventListener("click", addTransaction);
  if (btnMigrateTxnV2) btnMigrateTxnV2.addEventListener("click", migrateTxnV2Defaults);
  txnType.addEventListener("change", syncOptionalFields);
  cbInstallment.addEventListener("change", syncOptionalFields);
  cbFinance.addEventListener("change", syncOptionalFields);
  if (txnPayment) txnPayment.addEventListener("change", syncCreditTxnFields);
  if (txnCard) txnCard.addEventListener("change", syncCreditTxnFields);
  if (txnPurchaseDate) txnPurchaseDate.addEventListener("change", syncCreditTxnFields);
  if (txnDate) txnDate.addEventListener("change", syncCreditTxnFields);
  if (planType) planType.addEventListener("change", syncPlanFields);
  if (planPaymentMethod) planPaymentMethod.addEventListener("change", syncPlanFields);
  if (planCreditCard) planCreditCard.addEventListener("change", syncPlanFields);
  if (planPurchaseDate) planPurchaseDate.addEventListener("change", syncPlanFields);
  if (btnCreatePlan) btnCreatePlan.addEventListener("click", createPlanAndGenerate);
  if (btnAddCard) btnAddCard.addEventListener("click", addCreditCard);
  if (statementCard) statementCard.addEventListener("change", loadStatements);

  navButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const target = btn.getAttribute("data-page-target");
      if (!target) return;
      showPage(target);
    });
  });
  if (sidebarToggle && appShell) {
    sidebarToggle.addEventListener("click", () => {
      const collapsed = appShell.classList.toggle("collapsed");
      sidebarToggle.setAttribute("aria-pressed", collapsed ? "true" : "false");
    });
  }

  coupleTabs.addEventListener("click", async (e) => {
    const btn = e.target?.closest?.("button[data-tab]");
    if (!btn) return;

    coupleTabs.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
    btn.classList.add("active");

    state.coupleTab = btn.getAttribute("data-tab") || "totals";
    syncCoupleTabs();
    await reloadAll();
  });

  (function initDates() {
    const cur = currentYYYYMM() || yyyyMMFromDateStr(toISODateLocal(currentDateInTZ()));
    const nowLocal = currentDateInTZ();
    if (cur) monthInput.value = cur;
    txnDate.value = toISODateLocal(nowLocal);
    if (txnPurchaseDate) txnPurchaseDate.value = toISODateLocal(nowLocal);
    if (planStartMonth && cur) planStartMonth.value = cur;
    if (planPurchaseDate) planPurchaseDate.value = toISODateLocal(nowLocal);
    if (planPaymentMethod) planPaymentMethod.value = "outro";
    syncMonthLabel();
    syncOptionalFields();
    syncCreditTxnFields();
    syncPlanFields();
  })();

  onAuthStateChanged(auth, async (user) => {
    try {
      setAuthMessage("");
      setAppError("");
      setOpsError("");

      if (!user) {
        btnLogout.style.display = "none";
        appGrid.style.display = "none";
        me.textContent = "Aguardando login";
        renderDashboardMovements([]);
        if (authCard) authCard.style.display = "";
        return;
      }

      const email = (user.email ?? "").toLowerCase();
      if (!ALLOWED_EMAILS.has(email)) {
        await signOut(auth);
        throw new Error("Usuário autenticado, mas não autorizado.");
      }

      state.user = user;
      state.email = email;
      state.uid = user.uid;
      state.displayName = user.displayName ?? (user.email?.split("@")[0] ?? "Usuário");

      btnLogout.style.display = "";
      appGrid.style.display = "";
      if (authCard) authCard.style.display = "none";

      me.textContent = state.displayName;

      await ensureUserProfile(user);
      await ensureWalletMetaIfOwner(user);
      await ensureMembershipShortcutsFromMembers(user);

      const wallets = await loadWalletOptions(user);
      selectDefaultWallet(wallets);

      await refreshWalletContext();
      showPage("dashboard");

      setAuthMessage("Sessão ativa.");
    } catch (e) {
      const raw = e?.message ?? "";
      const friendly = raw.includes("Firebase") ? "Não foi possível iniciar a sessão. Tente novamente." : (raw || "Não foi possível iniciar a sessão. Tente novamente.");
      setAppError(friendly);
    }
  });


</script>

</body>
</html>
