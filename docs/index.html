<!doctype html>
<!--
Manual tests:
- Criar recorrente dia 18 -> ocorrencias nos proximos meses no dia 18 (ou ultimo dia do mes quando nao existir).
- Lista do mes mostra ocorrencias corretas via monthKey.
- Recorrente agendado mostra icone e nao exibe texto "Recorrente | Agendado".
- Criar receita parcelada 4500 em 3x -> 3 ocorrencias income de 1500 nos meses seguintes.
-->
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VaultFlow</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='16' fill='%230f172a'/%3E%3Ctext x='50%25' y='54%25' text-anchor='middle' font-family='Space Grotesk,Arial' font-size='28' fill='%23ffffff'%3EVF%3C/text%3E%3C/svg%3E" />
  
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap");
    :root {
      color-scheme: light;
      --bg: #0f172a;
      --panel: #ffffff;
      --muted: #6b7280;
      --text: #0b1224;
      --border: #e5e7eb;
      --primary: #0f172a;
      --accent: #0ea5e9;
      --success: #0ea76b;
      --danger: #ef4444;
      --shadow: 0 16px 60px rgba(15, 23, 42, 0.12);
      --soft: #f8fafc;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1000px at 15% 20%, #e8f4ff, transparent),
        radial-gradient(900px at 80% 0%, #e2f5ed, transparent),
        #f8fafc;
      color: var(--text);
      min-height: 100vh;
    }
    h1,h2,h3 { margin: 0; }
    p { margin: 0; }
    .muted { color: var(--muted); }
    .err { color: var(--danger); white-space: pre-wrap; margin-top: 6px; }
    .ok { color: var(--success); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
    .app-shell {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 100vh;
      transition: grid-template-columns 0.25s ease;
    }
    .app-shell.collapsed { grid-template-columns: 80px 1fr; }
    .sidebar {
      background: linear-gradient(180deg, #0f172a 0%, #0b1224 100%);
      color: #e2e8f0;
      padding: 22px 20px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      position: sticky;
      top: 0;
      height: 100vh;
      border-right: 1px solid rgba(255, 255, 255, 0.04);
      width: 100%;
      overflow: hidden;
    }
    .sidebar-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .sidebar-toggle { margin-left: auto; }
    .brand-row {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: space-between;
    }
    .brand { display: flex; align-items: center; gap: 10px; }
    .logo {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      background: linear-gradient(135deg, #0ea5e9, #22d3ee);
      display: grid;
      place-items: center;
      font-weight: 700;
      color: #0b1224;
      letter-spacing: -0.5px;
      flex-shrink: 0;
    }
    .brand-text { display: grid; gap: 2px; }
    .brand-name { font-weight: 700; letter-spacing: -0.2px; }
    .brand-sub { font-size: 12px; color: #94a3b8; }
    .icon-btn {
      width: 36px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.06);
      color: #e2e8f0;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
      padding: 0;
      line-height: 0;
    }
    .icon-btn svg { width: 18px; height: 18px; display: block; }
    .icon-btn:hover { transform: translateY(-1px); background: rgba(255, 255, 255, 0.1); }
    .nav { display: grid; gap: 6px; }
    .nav-item {
      position: relative;
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: transparent;
      color: #e2e8f0;
      font-weight: 600;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 10px;
      white-space: nowrap;
      overflow: hidden;
    }
    .nav-icon { width: 22px; height: 22px; display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .nav-icon svg { width: 22px; height: 22px; display: block; }
    .nav-label { line-height: 1; }
    .nav-item:hover { background: rgba(255, 255, 255, 0.05); }
    .nav-item.active { border-color: rgba(255, 255, 255, 0.16); background: rgba(255, 255, 255, 0.08); }
    .sidebar-footer {
      margin-top: auto;
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.04);
      display: grid;
      gap: 8px;
    }
    .session-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .sidebar-footer .label { font-size: 12px; color: #94a3b8; }
    .sidebar-footer .strong { font-weight: 600; }
    .main-area { background: transparent; }
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 28px 32px 10px;
    }
    .eyebrow { text-transform: uppercase; font-size: 11px; letter-spacing: 0.1em; color: var(--muted); margin-bottom: 6px; }
    .top-actions { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .wallet-select {
      min-width: 120px;
      padding: 9px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      font-weight: 700;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.06);
      cursor: pointer;
      appearance: none;
      background-image: linear-gradient(45deg, transparent 50%, var(--text) 50%), linear-gradient(135deg, var(--text) 50%, transparent 50%);
      background-position: calc(100% - 18px) 50%, calc(100% - 12px) 50%;
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;
      padding-right: 32px;
    }
    .wallet-select:focus { border-color: var(--accent); box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.12); }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f8fafc;
      color: var(--text);
      font-size: 12px;
      font-weight: 600;
    }
    .month-control {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fff;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
      font-weight: 700;
      color: var(--text);
    }
    .month-control .mc-btn { border: none; background: transparent; padding: 6px; border-radius: 10px; cursor: pointer; display: grid; place-items: center; color: var(--text); }
    .month-control .mc-btn:hover { background: #f1f5f9; }
    .month-control .mc-label { white-space: nowrap; cursor: pointer; user-select: none; }
    .month-control .mc-btn svg path { fill: currentColor; }
    .month-input {
      position: absolute;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
      border: 0;
      padding: 0;
      margin: 0;
    }
    .content { padding: 0 32px 32px; display: grid; gap: 16px; }
    .card, .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
    }
    .card { padding: 20px; }
    .panel { padding: 18px 18px 16px; }
    .panel-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 10px; margin-bottom: 14px; }
    .panel-footer { margin-top: 12px; display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .auth-card { display: grid; gap: 12px; border: 1px solid #dbeafe; background: linear-gradient(135deg, #ffffff, #f8fbff); }
    .auth-grid { display: grid; gap: 10px; }
    [hidden] { display: none !important; }
    .view { display: none; min-height: 100vh; }
    .view.active { display: block; }
    .view.auth-view.active { display: grid; }
    .auth-view { place-items: center; min-height: 100vh; padding: 36px 20px; }
    .auth-shell { width: min(520px, 100%); display: grid; gap: 18px; }
    .auth-panel { padding: 24px; }
    .auth-brand { display: flex; align-items: center; gap: 12px; }
    .auth-title { font-size: 26px; font-weight: 700; letter-spacing: -0.4px; }
    .auth-sub { color: var(--muted); font-size: 14px; }
    .auth-form { display: grid; gap: 12px; }
    .auth-actions { display: grid; gap: 10px; margin-top: 0; }
    .auth-links { display: flex; justify-content: space-between; align-items: center; margin-top: 4px; font-size: 13px; }
    .link-btn {
      background: none;
      border: none;
      padding: 0;
      color: var(--accent);
      cursor: pointer;
      font: inherit;
      font-weight: 600;
    }
    .link-btn:disabled { color: var(--muted); cursor: not-allowed; }
    .auth-loading { display: inline-flex; align-items: center; gap: 8px; font-size: 13px; color: var(--muted); }
    .auth-loading[hidden] { display: none !important; }
    .loading-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 18px 20px;
      display: grid;
      place-items: center;
      gap: 10px;
    }
    .spinner {
      width: 18px;
      height: 18px;
      border: 2px solid #cbd5f5;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
    input, select, textarea {
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #fff;
      min-width: 200px;
      font: inherit;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    input:focus, select:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.12); }
    button {
      padding: 11px 14px;
      border-radius: 12px;
      border: 1px solid var(--primary);
      background: var(--primary);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
      letter-spacing: -0.2px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 30px rgba(15, 23, 42, 0.12); }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    button.secondary { background: #fff; color: var(--primary); border-color: var(--border); }
    button.ghost { background: #f8fafc; color: var(--text); border-color: var(--border); }
    button svg { width: 18px; height: 18px; display: block; }
    #btnLogout { padding: 0; width: 28px; height: 28px; min-width: 0; display: inline-grid; place-items: center; color: #000; }
    #btnLogout svg { width: 24px; height: 24px; }
    .app-grid { display: grid; gap: 16px; }
    .page { display: none; }
    .page.active { display: grid; gap: 14px; }
    .filters { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; align-items: end; }
    .kpi-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin: 10px 0 6px; }
    .metric-card { padding: 14px; border-radius: 14px; border: 1px solid var(--border); background: linear-gradient(150deg, #ffffff, #f8fafc); display: grid; gap: 6px; }
    .metric-card .label { font-size: 13px; color: var(--muted); }
    .metric-card .value { font-size: 24px; font-weight: 700; letter-spacing: -0.3px; }
    .metric-card.income { border-color: rgba(14, 167, 107, 0.2); background: linear-gradient(135deg, #f0fdf4, #f8fffb); }
    .metric-card.expense { border-color: rgba(239, 68, 68, 0.2); background: linear-gradient(135deg, #fff1f2, #fff7f7); }
    .metric-card.balance { background: linear-gradient(135deg, #e0f2fe, #f8fbff); border-color: rgba(14, 165, 233, 0.2); }
    .mini-label { font-size: 12px; color: var(--muted); }
    .kpi { padding: 12px; border-radius: 12px; border: 1px solid var(--border); background: #f8fafc; }
    .kpi .label { font-size: 12px; color: var(--muted); }
    .kpi .value { font-size: 18px; font-weight: 700; }
    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 10px; background: var(--soft); border: 1px solid var(--border); font-size: 12px; color: var(--text); }
    .tabs { display: inline-flex; gap: 8px; background: #f8fafc; padding: 6px; border-radius: 12px; border: 1px solid var(--border); margin: 8px 0 4px; }
    .tab { padding: 8px 12px; border-radius: 10px; border: 1px solid transparent; background: transparent; cursor: pointer; font-size: 13px; color: var(--text); font-weight: 600; }
    .tab.active { background: #fff; border-color: var(--border); box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08); }
    .info-note { background: #f8fafc; border: 1px dashed var(--border); border-radius: 12px; padding: 10px 12px; color: var(--muted); margin: 6px 0 2px; }
    .table-shell { border: 1px solid var(--border); border-radius: 14px; overflow: hidden; background: #fff; position: relative; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 12px 12px; border-bottom: 1px solid var(--border); text-align: left; }
    th { font-size: 12px; letter-spacing: 0.05em; text-transform: uppercase; color: var(--muted); }
    td { font-size: 14px; }
    td .muted { font-size: 12px; }
    .right { text-align: right; }
    .nowrap { white-space: nowrap; }
    .table-shell.large { max-height: 420px; overflow: auto; }
    .table-shell thead th {
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 2;
    }
    .sort-btn {
      background: none;
      border: 0;
      padding: 0;
      font: inherit;
      color: inherit;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .sort-btn:hover { transform: none; box-shadow: none; }
    th .sort-btn { width: 100%; justify-content: flex-start; }
    th.right .sort-btn { justify-content: flex-end; }
    .sort-indicator { font-size: 11px; color: var(--muted); min-width: 24px; text-align: right; display: inline-flex; align-items: center; justify-content: flex-end; }
    .sort-indicator svg { width: 16px; height: 16px; display: block; }
    .sort-btn.active .sort-indicator { color: var(--text); }
    .recurring-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: 6px;
      vertical-align: middle;
    }
    .recurring-icon svg { width: 18px; height: 18px; display: block; }
    .installment-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f8fafc;
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      margin-left: 6px;
      white-space: nowrap;
    }
    .gallery-head {
      display: grid;
      grid-template-columns: 1.5fr 0.8fr 0.7fr;
      gap: 8px;
      align-items: center;
      padding: 6px 4px;
      color: var(--muted);
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.08em;
    }
    .gallery-sort { justify-content: flex-start; text-transform: uppercase; letter-spacing: 0.08em; font-size: 11px; }
    .category-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 10px;
    }
    .category-card {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #fff;
      padding: 12px;
      display: grid;
      gap: 8px;
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.05);
    }
    .category-head { display: flex; align-items: flex-start; justify-content: space-between; gap: 10px; }
    .category-title { font-weight: 700; }
    .category-actions { display: flex; gap: 6px; }
    .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; align-items: end; }
    .login-fields {
      grid-template-columns: 1fr 1fr;
      column-gap: 16px;
      row-gap: 12px;
    }
    .login-fields > div { min-width: 0; }
    .login-fields input { width: 100%; min-width: 0; }
    .chip-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .divider { height: 1px; background: var(--border); margin: 14px 0; }
    .list-panel { padding-bottom: 10px; grid-column: 1 / -1; }
    .stack-list { display: grid; gap: 10px; }
    .move-card { padding: 12px; border-radius: 12px; border: 1px solid var(--border); background: #fff; display: grid; gap: 4px; box-shadow: 0 10px 30px rgba(15, 23, 42, 0.05); }
    .move-meta { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--muted); }
    .move-amount { font-weight: 700; }
    .actions { display: flex; gap: 6px; justify-content: flex-end; }
    .split-panels { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; }
    .mini-panel { padding: 12px; border: 1px solid var(--border); border-radius: 12px; background: #fff; box-shadow: 0 8px 24px rgba(15, 23, 42, 0.06); display: grid; gap: 6px; }
    .mini-panel h3 { margin: 0; font-size: 16px; }
    .statement-overview { margin-top: 8px; }
    .statement-overview .metric-card { padding: 12px; }
    .statement-overview .metric-card .value { font-size: 18px; }
    .statement-row.is-active { background: #f1f5f9; }
    .statement-row.is-active td { font-weight: 600; }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; border: 1px solid var(--border); background: var(--soft); font-size: 12px; font-weight: 600; }
    .section-heading { display: flex; align-items: center; justify-content: space-between; gap: 8px; flex-wrap: wrap; }
    .section-heading h2, .section-heading h3 { margin: 0; }
    .icon-action { border: 1px solid var(--border); background: var(--soft); border-radius: 10px; padding: 8px 10px; cursor: pointer; color: #000; }
    .icon-action:hover { background: #fff; }
    .optional-block { margin-top: 10px; padding: 12px; border-radius: 12px; border: 1px dashed var(--border); background: #f8fafc; display: grid; gap: 10px; }
    .optional-title { font-size: 12px; text-transform: uppercase; letter-spacing: 0.06em; color: var(--muted); margin: 0; }
    .optional-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; align-items: start; }
    .option-card { border: 1px solid var(--border); border-radius: 12px; background: #fff; box-shadow: 0 4px 12px rgba(15, 23, 42, 0.05); padding: 10px; display: grid; gap: 8px; }
    .option-head { display: flex; align-items: center; gap: 10px; }
    .option-head input[type="checkbox"] { width: 16px; height: 16px; }
    .option-text { display: grid; gap: 2px; }
    .option-label { font-weight: 700; }
    .option-sub { font-size: 12px; color: var(--muted); }
    .option-fields { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; }
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.45);
      display: grid;
      place-items: center;
      padding: 20px;
      z-index: 60;
    }
    .modal-card {
      width: min(560px, 100%);
      border-radius: 16px;
      border: 1px solid var(--border);
      background: #fff;
      box-shadow: var(--shadow);
      padding: 20px;
      display: grid;
      gap: 12px;
    }
    .modal-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; }
    .modal-actions { display: flex; align-items: center; justify-content: flex-end; gap: 10px; flex-wrap: wrap; }
    @media (max-width: 1180px) {
      .app-shell { grid-template-columns: 1fr; }
      .sidebar { position: relative; height: auto; border-right: none; }
      .app-grid { grid-template-columns: 1fr; }
      .page.active { grid-template-columns: 1fr; }
    }
    @media (max-width: 720px) {
      .topbar, .panel-header { flex-direction: column; align-items: flex-start; }
      .content { padding: 0 18px 24px; }
      .card, .panel { padding: 16px; }
    }
    @media (max-width: 640px) {
      .login-fields { grid-template-columns: 1fr; }
    }
    .app-shell.collapsed .brand-text,
    .app-shell.collapsed .nav-item .nav-label,
    .app-shell.collapsed .sidebar-footer .label,
    .app-shell.collapsed .sidebar-footer .strong,
    .app-shell.collapsed .sidebar-footer .mono { display: none; }
    .app-shell.collapsed .session-row { justify-content: center; }
    .app-shell.collapsed .sidebar { padding: 16px 10px; align-items: center; }
    .app-shell.collapsed .sidebar-top { flex-direction: column; justify-content: center; gap: 12px; }
    .app-shell.collapsed .sidebar-toggle { margin-left: 0; }
    .app-shell.collapsed .brand-row { justify-content: center; }
    .app-shell.collapsed .brand { justify-content: center; }
    .app-shell.collapsed .icon-btn { width: 36px; height: 36px; }
    .app-shell.collapsed .nav { gap: 10px; width: 56px; margin: 0 auto; }
    .app-shell.collapsed .nav-item {
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 6px;
      text-align: center;
      padding: 10px;
      min-height: 44px;
      width: 56px;
      margin: 0 auto;
    }
    .app-shell.collapsed .nav-item .nav-label { display: none; }
    .app-shell.collapsed .nav-item .nav-icon { margin: 0; }
    .app-shell.collapsed .nav-item::after { content: none; }
  </style>

</head>
<body>
<section id="view-loading" class="view auth-view active">
  <div class="loading-card">
    <div class="spinner"></div>
    <div class="muted">Carregando...</div>
  </div>
</section>

<section id="view-login" class="view auth-view" hidden>
  <div class="auth-shell">
    <section class="card auth-card auth-panel" id="authCard">
      <div class="auth-brand">
        <div class="logo">VF</div>
        <div>
          <div class="brand-name">VaultFlow</div>
          <div class="brand-sub">Fintech control</div>
        </div>
      </div>
      <div class="auth-head">
        <div class="auth-title">Entrar</div>
        <div class="auth-sub">Acesse sua conta para continuar.</div>
      </div>
      <form id="loginForm" class="auth-form">
        <div class="form-grid login-fields">
          <div>
            <label for="email">E-mail</label>
            <input id="email" type="email" placeholder="seu@email.com" autocomplete="username" />
          </div>
          <div>
            <label for="pass">Senha</label>
            <input id="pass" type="password" placeholder="********" autocomplete="current-password" />
          </div>
        </div>
        <div class="auth-actions">
          <button id="btnEmail" type="submit">Entrar com email e senha</button>
          <button id="btnGoogle" class="secondary" type="button">Entrar com Google</button>
        </div>
      </form>
      <div class="auth-links">
        <button id="btnForgot" class="link-btn" type="button">Esqueci minha senha</button>
        <button id="btnCreate" class="link-btn" type="button" disabled hidden>Criar conta</button>
      </div>
      <div class="auth-loading" id="authLoading" hidden>
        <div class="spinner"></div>
        <div id="authLoadingText">Entrando...</div>
      </div>
      <p id="authStatus" class="muted"></p>
      <p id="authError" class="err"></p>
    </section>
  </div>
</section>

<section id="view-app" class="view" hidden>
<div class="app-shell">
  <aside class="sidebar">
    <div class="sidebar-top">
      <div class="brand-row">
        <div class="brand">
          <div class="logo">VF</div>
          <div class="brand-text">
            <div class="brand-name">VaultFlow</div>
            <div class="brand-sub">Fintech control</div>
          </div>
        </div>
      </div>
      <button class="icon-btn sidebar-toggle" id="sidebarToggle" aria-label="Recolher menu" type="button">
        <svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2 6a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM2 18a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM3 11a1 1 0 1 0 0 2h18a1 1 0 1 0 0-2H3Z" fill="#ffffff"/></svg>
      </button>
    </div>

    <nav class="nav">
      <button class="nav-item active" type="button" data-page-target="dashboard">
        <span class="nav-icon" aria-hidden="true"><svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11.499 9.5 11.5 21H6.25a3.25 3.25 0 0 1-3.245-3.065L3 17.752V9.499h8.499Zm1.5 5.999H21.5v2.253a3.25 3.25 0 0 1-3.25 3.25L13 21l-.001-5.502Zm5.252-13a3.25 3.25 0 0 1 3.245 3.065l.005.184-.001 8.251h-8.501L13 2.498h5.251ZM11.5 2.497 11.499 8H3V5.748a3.25 3.25 0 0 1 3.25-3.25h5.25Z" fill="#ffffff"/></svg></span>
        <span class="nav-label">Dashboard</span>
      </button>
      <button class="nav-item" type="button" data-page-target="transactions">
        <span class="nav-icon" aria-hidden="true"><svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6.5 2a1 1 0 0 0-1 1v.112A4.502 4.502 0 0 0 2 7.5v.384a4.883 4.883 0 0 0 2.796 4.415l.704.332v6.14A2.5 2.5 0 0 1 4 16.48v-.845a1 1 0 1 0-2 0v.845a4.502 4.502 0 0 0 3.5 4.389v.124a1 1 0 0 0 2 0v-.124a4.502 4.502 0 0 0 3.5-4.389v-.372A4.875 4.875 0 0 0 8.209 11.7l-.709-.335V5.208A2.5 2.5 0 0 1 9 7.5v.865a1 1 0 1 0 2 0V7.5a4.502 4.502 0 0 0-3.5-4.388V3a1 1 0 0 0-1-1ZM4 7.5a2.5 2.5 0 0 1 1.5-2.292v5.206A2.884 2.884 0 0 1 4 7.884V7.5Zm3.5 11.271v-5.189c.92.501 1.5 1.468 1.5 2.525v.372a2.5 2.5 0 0 1-1.5 2.292Z" fill="#ffffff"/><path d="M15 12c0-.332.015-.657.043-.975H16a1 1 0 0 0 0-2h-.577a7.898 7.898 0 0 1 .979-2.125c.85-1.268 1.916-1.9 2.962-1.9.378 0 .785.117 1.067.31a1 1 0 1 0 1.13-1.65C20.904 3.21 20.09 3 19.364 3c-1.917 0-3.533 1.159-4.623 2.786-.619.923-1.094 2.025-1.39 3.239H12a1 1 0 1 0 0 2h1.036c-.024.32-.036.646-.036.975v.027h-1a1 1 0 1 0 0 2h1.16c.255 1.588.804 3.03 1.58 4.187C15.832 19.84 17.448 21 19.364 21c.697 0 1.535-.174 2.222-.67a1 1 0 0 0-1.172-1.621c-.254.183-.644.291-1.05.291-1.046 0-2.112-.632-2.962-1.9-.553-.824-.98-1.876-1.212-3.075H16a1 1 0 0 0 0-2h-1V12Z" fill="#ffffff"/></svg></span>
        <span class="nav-label">Transações</span>
      </button>
      <button class="nav-item" type="button" data-page-target="categories">
        <span class="nav-icon" aria-hidden="true"><svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2 6a2 2 0 0 1 2-2h1v7.174a6.488 6.488 0 0 0-3 1.636V6ZM16 8.5h-4a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5V9a.5.5 0 0 0-.5-.5Z" fill="#ffffff"/><path d="M12.502 20H20a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6.5v7a6.5 6.5 0 0 1 6.002 9ZM10 9a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v1a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2V9Z" fill="#ffffff"/><path d="M6.5 12a5.5 5.5 0 1 1 0 11 5.5 5.5 0 0 1 0-11Zm.501 8.503V18h2.496a.5.5 0 0 0 0-1H7v-2.5a.5.5 0 1 0-1 0V17H3.496a.5.5 0 0 0 0 1H6v2.503a.5.5 0 1 0 1 0Z" fill="#ffffff"/></svg></span>
        <span class="nav-label">Categorias</span>
      </button>
      <button class="nav-item" type="button" data-page-target="settings">
        <span class="nav-icon" aria-hidden="true"><svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2 6a1 1 0 0 1 1-1h15a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM2 18a1 1 0 0 1 1-1h11a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM3 11a1 1 0 1 0 0 2h18a1 1 0 1 0 0-2H3Z" fill="#ffffff"/></svg></span>
        <span class="nav-label">Preferências</span>
      </button>
    </nav>

    <div class="sidebar-footer">
      <div class="label">Sessão</div>
      <div class="session-row">
        <div class="strong" id="me">Aguardando login</div>
        <button id="btnLogout" class="ghost" style="display:none;" aria-label="Sair" title="Sair"><svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 4.354v6.651l7.442-.001L17.72 9.28a.75.75 0 0 1-.073-.976l.073-.084a.75.75 0 0 1 .976-.073l.084.073 2.997 2.997a.75.75 0 0 1 .073.976l-.073.084-2.996 3.004a.75.75 0 0 1-1.134-.975l.072-.085 1.713-1.717-7.431.001L12 19.25a.75.75 0 0 1-.88.739l-8.5-1.502A.75.75 0 0 1 2 17.75V5.75a.75.75 0 0 1 .628-.74l8.5-1.396a.75.75 0 0 1 .872.74ZM8.502 11.5a1.002 1.002 0 1 0 0 2.004 1.002 1.002 0 0 0 0-2.004Z" fill="currentColor"/><path d="M13 18.501h.765l.102-.006a.75.75 0 0 0 .648-.745l-.007-4.25H13v5.001ZM13.002 10 13 8.725V5h.745a.75.75 0 0 1 .743.647l.007.102.007 4.251h-1.5Z" fill="currentColor"/></svg></button>
      </div>
    </div>
  </aside>

  <div class="main-area">
    <header class="topbar">
      <div>
        <p class="eyebrow">VaultFlow</p>
        <h1 id="pageTitle">Dashboard</h1>
      </div>
      <div class="top-actions">
        <select id="walletSelect" class="wallet-select" aria-label="Selecionar carteira"></select>
        <div class="month-control">
          <button class="mc-btn" id="btnMonthPrev" type="button" aria-label="Mês anterior">◀</button>
          <span class="mc-label" id="monthDisplay">Mês atual</span>
          <button class="mc-btn" id="btnMonthNext" type="button" aria-label="Próximo mês">▶</button>
          <button class="mc-btn" id="btnMonthPicker" type="button" aria-label="Escolher mês">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17 4a1 1 0 0 1 1 1v1h1a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h1V5a1 1 0 1 1 2 0v1h6V5a1 1 0 0 1 1-1Zm2 7H5v7h14v-7Zm-4-5v1a1 1 0 1 1-2 0V6h-4v1a1 1 0 1 1-2 0V6H6v2h12V6h-1Zm-8.5 7a1 1 0 1 1 0 2h-1a1 1 0 1 1 0-2h1Zm5 0a1 1 0 1 1 0 2h-1a1 1 0 1 1 0-2h1Zm5 0a1 1 0 1 1 0 2h-1a1 1 0 1 1 0-2h1Z" fill="currentColor"/></svg>
          </button>
        </div>
        <input id="month" type="month" class="month-input" />
      </div>
    </header>

    <main class="content">
      <section class="app-grid" id="appGrid">
        <section class="page active" id="page-dashboard">
          <p class="err" id="appError"></p>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Carteira</p>
                <h2>Dashboard</h2>
              </div>
            </div>

            <div class="kpi-row" id="kpis">
              <div class="metric-card income">
                <div class="label">Receitas</div>
                <div class="value" id="kpiIncome">R$ 0,00</div>
                <div class="mini-label">Entradas no período</div>
              </div>
              <div class="metric-card expense">
                <div class="label">Despesas</div>
                <div class="value" id="kpiExpense">R$ 0,00</div>
                <div class="mini-label">Saídas no período</div>
              </div>
              <div class="metric-card balance">
                <div class="label">Saldo</div>
                <div class="value" id="kpiBalance">R$ 0,00</div>
                <div class="mini-label">Resultado consolidado</div>
              </div>
            </div>

            <div class="tabs" id="coupleTabs" style="display:none;">
              <button class="tab active" data-tab="totals">Totais</button>
              <button class="tab" data-tab="details">Detalhes</button>
            </div>

            <div id="coupleHint" class="info-note" style="display:none;">
              Visão consolidada: sincronizada automaticamente a partir das carteiras individuais.
            </div>

            <div id="coupleBreakdown" style="display:none; margin-top:10px;"></div>
          </div>

          <div class="panel list-panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Movimentações</p>
                <h2>Receitas e Despesas</h2>
              </div>
            </div>
            <div class="split-panels">
              <div class="mini-panel">
                <div class="section-heading"><h3>Receitas</h3><span class="pill">Mês selecionado</span></div>
                <div id="incomeList" class="stack-list"></div>
              </div>
              <div class="mini-panel">
                <div class="section-heading"><h3>Despesas</h3><span class="pill">Mês selecionado</span></div>
                <div id="expenseList" class="stack-list"></div>
              </div>
            </div>
            <p class="muted" id="dashboardStatus"></p>
          </div>
        </section>

        <section class="page" id="page-transactions">
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Fluxo</p>
                <h3>Transacoes</h3>
              </div>
            </div>
            <div class="form-grid">
              <div>
                <label for="txnDate">Data</label>
                <input id="txnDate" type="date" />
              </div>
              <div>
                <label for="txnType">Tipo</label>
                <select id="txnType">
                  <option value="expense">Despesa</option>
                  <option value="income">Receita</option>
                  <option value="reserve">Reserva</option>
                </select>
              </div>
              <div>
                <label for="txnNote">Descricao</label>
                <input id="txnNote" placeholder="Observacao" />
              </div>
            </div>

            <div class="form-grid" style="margin-top:10px;">
              <div>
                <label for="txnAmount">Valor</label>
                <input id="txnAmount" placeholder="Ex.: 35,90" />
              </div>
              <div>
                <label for="txnPayment">Forma de pagamento</label>
                <select id="txnPayment">
                  <option value="">Selecione</option>
                  <option value="pix">Pix</option>
                  <option value="credit_card">Cartao de credito</option>
                  <option value="debito">Cartao de debito</option>
                  <option value="dinheiro">Dinheiro</option>
                  <option value="transferencia">Transferencia</option>
                  <option value="boleto">Boleto</option>
                  <option value="outro">Outro</option>
                </select>
              </div>
              <div>
                <label for="txnCat">Categoria</label>
                <select id="txnCat"></select>
              </div>
            </div>
            <div class="form-grid" id="creditTxnFields" style="margin-top:6px;" hidden>
              <div>
                <label for="txnCard">Cartao</label>
                <select id="txnCard"></select>
              </div>
            </div>

            <div class="optional-block">
              <p class="optional-title">Opcionais</p>
              <div class="optional-cards">
                <div class="option-card" id="cardRecurring">
                  <div class="option-head">
                    <input type="checkbox" id="cbRecurring" />
                    <div class="option-text">
                      <span class="option-label">Tornar recorrente</span>
                      <span class="option-sub">Mensal</span>
                    </div>
                  </div>
                </div>

                <div class="option-card" id="cardInstallment" hidden>
                  <div class="option-head">
                    <input type="checkbox" id="cbInstallment" />
                    <div class="option-text">
                      <span class="option-label">Parcelado(a)</span>
                      <span class="option-sub">Controlar parcelas</span>
                    </div>
                  </div>
                  <div class="option-fields" id="installmentFields" hidden>
                    <div>
                      <label for="installmentTotal">Total de parcelas</label>
                      <input id="installmentTotal" type="number" min="1" step="1" placeholder="Ex.: 12" />
                    </div>
                    <div>
                      <label for="installmentCurrent">Parcela atual</label>
                      <input id="installmentCurrent" type="number" min="1" step="1" placeholder="Ex.: 3" />
                    </div>
                  </div>
                  <p class="muted" id="installmentHint" hidden>Serão criadas parcelas retroativas para meses anteriores.</p>
                </div>

                <div class="option-card" id="cardFinance" hidden>
                  <div class="option-head">
                    <input type="checkbox" id="cbFinance" />
                    <div class="option-text">
                      <span class="option-label">Financiamento</span>
                      <span class="option-sub">Detalhar parcelas</span>
                    </div>
                  </div>
                  <div class="option-fields" id="financeFields" hidden>
                    <div>
                      <label for="financeTotal">Total de parcelas</label>
                      <input id="financeTotal" type="number" min="1" step="1" placeholder="Ex.: 48" />
                    </div>
                    <div>
                      <label for="financeCurrent">Parcela atual</label>
                      <input id="financeCurrent" type="number" min="1" step="1" placeholder="Ex.: 10" />
                    </div>
                  </div>
                  <p class="muted" id="financeHint" hidden>Serão criadas parcelas retroativas para meses anteriores.</p>
                </div>
              </div>
            </div>

            <div style="display:flex; align-items:flex-end; justify-content:flex-start; margin-top:12px;">
              <button id="btnAddTxn">Adicionar</button>
            </div>
            <p class="muted" id="txnStatus" style="margin-top:10px;"></p>
            <p class="err" id="opsError"></p>
          </div>

          <div class="panel list-panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Movimentacoes</p>
                <h2>Lista do mes</h2>
              </div>
            </div>
            <div class="table-shell large">
              <table>
                <thead>
                  <tr>
                    <th>
                      <button class="sort-btn" type="button" data-sort-table="transactions" data-sort-key="description">
                        <span class="sort-label">Descricao</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th>
                      <button class="sort-btn" type="button" data-sort-table="transactions" data-sort-key="payment">
                        <span class="sort-label">Pagamento (Forma)</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th>
                      <button class="sort-btn" type="button" data-sort-table="transactions" data-sort-key="category">
                        <span class="sort-label">Categoria</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th class="nowrap">
                      <button class="sort-btn" type="button" data-sort-table="transactions" data-sort-key="date">
                        <span class="sort-label">Data</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th class="right nowrap">
                      <button class="sort-btn" type="button" data-sort-table="transactions" data-sort-key="amount">
                        <span class="sort-label">Valor</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th class="right nowrap">Acoes</th>
                  </tr>
                </thead>
                <tbody id="txnTable"></tbody>
              </table>
            </div>
          </div>
        </section>

        <section class="page" id="page-categories">
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Organizacao</p>
                <h3>Categorias</h3>
              </div>
            </div>

            <div class="form-grid">
              <div>
                <label for="catName">Nome</label>
                <input id="catName" placeholder="Ex.: Alimentacao" />
              </div>
              <div>
                <label for="catKind">Tipo</label>
                <select id="catKind">
                  <option value="expense">Despesa</option>
                  <option value="income">Receita</option>
                  <option value="both">Ambos</option>
                </select>
              </div>
              <div class="row">
                <button id="btnAddCat">Adicionar</button>
                <button id="btnSeedCats" class="ghost">Categorias padrao</button>
              </div>
            </div>
            <div class="muted" id="catStatus" style="margin-top:6px;"></div>
            <div class="gallery-head" style="margin-top:10px;">
              <button class="sort-btn gallery-sort" type="button" data-sort-table="categories" data-sort-key="name">
                <span class="sort-label">Nome</span>
                <span class="sort-indicator"></span>
              </button>
              <button class="sort-btn gallery-sort" type="button" data-sort-table="categories" data-sort-key="kind">
                <span class="sort-label">Tipo</span>
                <span class="sort-indicator"></span>
              </button>
              <div class="gallery-head-actions right">Acoes</div>
            </div>
            <div id="catGrid" class="category-grid"></div>
          </div>
        </section>

        <section class="page" id="page-settings">
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Sessao</p>
                <h3>Preferencias</h3>
              </div>
            </div>
            <p class="muted">Use o menu para navegar. Seus dados sincronizam automaticamente.</p>
          </div>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Ferramentas</p>
                <h3>Transacoes v2</h3>
              </div>
            </div>
            <p class="muted">Aplica defaults v2 em transacoes pessoais e no consolidado.</p>
            <div class="row">
              <button id="btnMigrateTxnV2" class="ghost">Aplicar defaults (Transactions v2)</button>
            </div>
            <div class="muted" id="migrateStatus" style="margin-top:6px;"></div>
          </div>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Automacao</p>
                <h3>Planos</h3>
              </div>
            </div>
            <p class="muted">Planos sao criados em Transacoes ao marcar recorrente, parcelado ou financiamento.</p>
            <div class="muted" id="planStatus" style="margin-top:6px;"></div>
            <div class="table-shell" style="margin-top:12px; max-height: 260px; overflow:auto;">
              <table>
                <thead>
                  <tr>
                    <th>
                      <button class="sort-btn" type="button" data-sort-table="plans" data-sort-key="title">
                        <span class="sort-label">Plano</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th>
                      <button class="sort-btn" type="button" data-sort-table="plans" data-sort-key="type">
                        <span class="sort-label">Tipo</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th class="right nowrap">
                      <button class="sort-btn" type="button" data-sort-table="plans" data-sort-key="amount">
                        <span class="sort-label">Valor</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th class="right nowrap">
                      <button class="sort-btn" type="button" data-sort-table="plans" data-sort-key="start">
                        <span class="sort-label">Inicio</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th>
                      <button class="sort-btn" type="button" data-sort-table="plans" data-sort-key="status">
                        <span class="sort-label">Status</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th class="right">Acoes</th>
                  </tr>
                </thead>
                <tbody id="planTable"></tbody>
              </table>
            </div>
          </div>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Cartoes</p>
                <h3>Cadastro</h3>
              </div>
            </div>
            <div class="form-grid">
              <div>
                <label for="cardName">Nome</label>
                <input id="cardName" placeholder="Ex.: Nubank" />
              </div>
              <div>
                <label for="cardClosingDay">Fechamento</label>
                <input id="cardClosingDay" type="number" min="1" max="31" step="1" placeholder="Ex.: 10" />
              </div>
              <div>
                <label for="cardDueDay">Vencimento</label>
                <input id="cardDueDay" type="number" min="1" max="31" step="1" placeholder="Ex.: 20" />
              </div>
            </div>
            <div class="row">
              <button id="btnAddCard" class="ghost">Adicionar cartao</button>
            </div>
            <div class="muted" id="cardStatus" style="margin-top:6px;"></div>
            <div class="table-shell" style="margin-top:12px; max-height: 220px; overflow:auto;">
              <table>
                <thead>
                  <tr>
                    <th>
                      <button class="sort-btn" type="button" data-sort-table="cards" data-sort-key="name">
                        <span class="sort-label">Cartao</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th class="right">
                      <button class="sort-btn" type="button" data-sort-table="cards" data-sort-key="closing">
                        <span class="sort-label">Fechamento</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th class="right">
                      <button class="sort-btn" type="button" data-sort-table="cards" data-sort-key="due">
                        <span class="sort-label">Vencimento</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th>
                      <button class="sort-btn" type="button" data-sort-table="cards" data-sort-key="status">
                        <span class="sort-label">Status</span>
                        <span class="sort-indicator"></span>
                      </button>
                    </th>
                    <th class="right">Acoes</th>
                  </tr>
                </thead>
                <tbody id="cardTable"></tbody>
              </table>
            </div>
          </div>
          <div class="panel">
            <div class="panel-header">
              <div>
                <p class="eyebrow">Cartao</p>
                <h3>Faturas</h3>
              </div>
            </div>
            <div class="form-grid">
              <div>
                <label for="statementCard">Cartao</label>
                <select id="statementCard"></select>
              </div>
            </div>
            <div class="muted" id="statementMeta" style="margin-top:6px;"></div>
            <div class="info-note" id="statementStatus" style="margin-top:8px; display:none;"></div>
            <div class="kpi-row statement-overview">
              <div class="metric-card">
                <div class="label">Fatura selecionada</div>
                <div class="value" id="statementSummaryMonth">-</div>
              </div>
              <div class="metric-card">
                <div class="label">Total</div>
                <div class="value" id="statementSummaryTotal">-</div>
              </div>
              <div class="metric-card">
                <div class="label">Status</div>
                <div class="value" id="statementSummaryStatus">-</div>
              </div>
              <div class="metric-card">
                <div class="label">Itens</div>
                <div class="value" id="statementSummaryCount">-</div>
              </div>
            </div>
            <div class="split-panels" style="margin-top:12px;">
              <div class="mini-panel">
                <div class="section-heading"><h3>Faturas</h3><span class="pill">Resumo</span></div>
                <div class="table-shell" style="max-height: 260px; overflow:auto;">
                  <table>
                    <thead>
                      <tr>
                        <th>
                          <button class="sort-btn" type="button" data-sort-table="statements" data-sort-key="month">
                            <span class="sort-label">Mes</span>
                            <span class="sort-indicator"></span>
                          </button>
                        </th>
                        <th class="right">
                          <button class="sort-btn" type="button" data-sort-table="statements" data-sort-key="total">
                            <span class="sort-label">Total</span>
                            <span class="sort-indicator"></span>
                          </button>
                        </th>
                        <th>
                          <button class="sort-btn" type="button" data-sort-table="statements" data-sort-key="status">
                            <span class="sort-label">Status</span>
                            <span class="sort-indicator"></span>
                          </button>
                        </th>
                        <th class="right">Acoes</th>
                      </tr>
                    </thead>
                    <tbody id="statementTable"></tbody>
                  </table>
                </div>
              </div>
              <div class="mini-panel">
                <div class="section-heading"><h3>Itens</h3><span class="pill" id="statementItemsMonth">Selecionado</span></div>
                <div class="table-shell" style="max-height: 260px; overflow:auto;">
                  <table>
                    <thead>
                      <tr>
                        <th>
                          <button class="sort-btn" type="button" data-sort-table="statementItems" data-sort-key="date">
                            <span class="sort-label">Data</span>
                            <span class="sort-indicator"></span>
                          </button>
                        </th>
                        <th>
                          <button class="sort-btn" type="button" data-sort-table="statementItems" data-sort-key="category">
                            <span class="sort-label">Categoria</span>
                            <span class="sort-indicator"></span>
                          </button>
                        </th>
                        <th>
                          <button class="sort-btn" type="button" data-sort-table="statementItems" data-sort-key="description">
                            <span class="sort-label">Descricao</span>
                            <span class="sort-indicator"></span>
                          </button>
                        </th>
                        <th class="right">
                          <button class="sort-btn" type="button" data-sort-table="statementItems" data-sort-key="amount">
                            <span class="sort-label">Valor</span>
                            <span class="sort-indicator"></span>
                          </button>
                        </th>
                      </tr>
                    </thead>
                    <tbody id="statementItemsTable"></tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </section>

      </section>
    </main>
  </div>
</div>

  <div id="editModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="editModalTitle" aria-describedby="editHelper" hidden>
    <div class="modal-card">
      <div class="modal-header">
        <div>
          <h3 id="editModalTitle">Editar transacao</h3>
          <p class="muted" id="editHelper">Atualize os dados da transacao.</p>
        </div>
      </div>
      <div class="form-grid">
        <div>
          <label for="editTxnDate">Data</label>
          <input id="editTxnDate" type="date" />
        </div>
        <div>
          <label for="editTxnType">Tipo</label>
          <select id="editTxnType">
            <option value="expense">Despesa</option>
            <option value="income">Receita</option>
            <option value="reserve">Reserva</option>
          </select>
        </div>
        <div>
          <label for="editTxnCat">Categoria</label>
          <select id="editTxnCat"></select>
        </div>
      </div>
      <div class="form-grid">
        <div>
          <label for="editTxnAmount">Valor</label>
          <input id="editTxnAmount" placeholder="Ex.: 35,90" />
        </div>
        <div>
          <label for="editTxnNote">Descricao</label>
          <input id="editTxnNote" placeholder="Observacao" />
        </div>
      </div>
      <div class="modal-actions">
        <button id="btnCloseEdit" class="secondary" type="button">Cancelar</button>
        <button id="btnSaveEdit" type="button">Salvar alteracoes</button>
      </div>
      <p class="muted" id="editStatus"></p>
      <p class="err" id="editError"></p>
    </div>
  </div>
  <div id="editCardModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="editCardTitle" aria-describedby="editCardHelper" hidden>
    <div class="modal-card">
      <div class="modal-header">
        <div>
          <h3 id="editCardTitle">Editar cartao</h3>
          <p class="muted" id="editCardHelper">Atualize os dados do cartao e a fatura futura.</p>
        </div>
      </div>
      <div class="form-grid">
        <div>
          <label for="editCardName">Nome do cartao</label>
          <input id="editCardName" placeholder="Ex.: Nubank" />
        </div>
        <div>
          <label for="editCardClosingDay">Fechamento</label>
          <input id="editCardClosingDay" type="number" min="1" max="31" step="1" placeholder="Ex.: 10" />
        </div>
        <div>
          <label for="editCardDueDay">Vencimento</label>
          <input id="editCardDueDay" type="number" min="1" max="31" step="1" placeholder="Ex.: 20" />
        </div>
      </div>
      <div class="modal-actions">
        <button id="btnCloseCardEdit" class="secondary" type="button">Cancelar</button>
        <button id="btnSaveCardEdit" type="button">Salvar alteracoes</button>
      </div>
      <p class="muted" id="editCardStatus"></p>
      <p class="err" id="editCardError"></p>
    </div>
  </div>
</section>

<script type="module">


  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js";

  import {
    getAuth,
    onAuthStateChanged,
    signInWithEmailAndPassword,
    GoogleAuthProvider,
    signInWithPopup,
    signOut,
    sendPasswordResetEmail
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

  import {
    getFirestore,
    Timestamp,
    doc,
    getDoc,
    setDoc,
    deleteDoc,
    collection,
    getDocs,
    addDoc,
    query,
    where,
    orderBy,
    serverTimestamp,
    runTransaction
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

  // Firebase Config (VaultFlow-Dev / vaultflow-dev-marc35)
  const firebaseConfig = {
    apiKey: "AIzaSyDIXLjoqxDQrDr7rhxfBjCBzsXZUycTWD0",
    authDomain: "vaultflow-dev-marc35.firebaseapp.com",
    projectId: "vaultflow-dev-marc35",
    storageBucket: "vaultflow-dev-marc35.firebasestorage.app",
    messagingSenderId: "806046110940",
    appId: "1:806046110940:web:aab0a3245bb304e14b9019",
    measurementId: "G-CMZTW66KS9"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Allowlist (somente vocês 3)
  const ALLOWED_EMAILS = new Set([
    "hbmarc35@gmail.com",
    "lzmarc25@gmail.com",
    "herbertmarck@gmail.com"
  ]);

  const COUPLE_WALLET_ID = "w_casal";
  const PERSONAL_WALLETS = new Set(["w_marcelino", "w_luiza"]);
  const KNOWN_WALLETS = ["w_marcelino", "w_luiza", "w_casal"];
  const FRIENDLY_WALLET_NAMES = {
    w_marcelino: "Marcelino",
    w_luiza: "Luiza",
    w_casal: "Casal"
  };
  const USER_PERSONAL_WALLET = {
    "hbmarc35@gmail.com": "w_marcelino",
    "lzmarc25@gmail.com": "w_luiza",
    "herbertmarck@gmail.com": "w_marcelino"
  };

  const $ = (id) => document.getElementById(id);

  const viewLogin = $("view-login");
  const viewApp = $("view-app");
  const viewLoading = $("view-loading");
  const btnEmail = $("btnEmail");
  const btnGoogle = $("btnGoogle");
  const btnLogout = $("btnLogout");
  const btnForgot = $("btnForgot");
  const btnCreate = $("btnCreate");
  const loginForm = $("loginForm");
  const authCard = $("authCard");
  const authStatus = $("authStatus");
  const authError = $("authError");
  const authLoading = $("authLoading");
  const authLoadingText = $("authLoadingText");

  const appGrid = $("appGrid");
  const pageTitle = $("pageTitle");
  const navButtons = Array.from(document.querySelectorAll("[data-page-target]"));
  const pages = {
    dashboard: $("page-dashboard"),
    transactions: $("page-transactions"),
    categories: $("page-categories"),
    settings: $("page-settings")
  };

  const me = $("me");

  const walletSelect = $("walletSelect");
  const monthInput = $("month");
  const monthDisplay = $("monthDisplay");
  const btnMonthPrev = $("btnMonthPrev");
  const btnMonthNext = $("btnMonthNext");
  const btnMonthPicker = $("btnMonthPicker");

  const kpiIncome = $("kpiIncome");
  const kpiExpense = $("kpiExpense");
  const kpiBalance = $("kpiBalance");
  const coupleBreakdown = $("coupleBreakdown");

  const coupleTabs = $("coupleTabs");
  const coupleHint = $("coupleHint");

  const incomeList = $("incomeList");
  const expenseList = $("expenseList");
  const dashboardStatus = $("dashboardStatus");

  const catName = $("catName");
  const catKind = $("catKind");
  const btnAddCat = $("btnAddCat");
  const btnSeedCats = $("btnSeedCats");
  const catStatus = $("catStatus");
  const catGrid = $("catGrid");

  const txnDate = $("txnDate");
  const txnType = $("txnType");
  const txnPayment = $("txnPayment");
  const txnCat = $("txnCat");
  const txnAmount = $("txnAmount");
  const txnNote = $("txnNote");
  const btnAddTxn = $("btnAddTxn");
  const creditTxnFields = $("creditTxnFields");
  const txnCard = $("txnCard");

  const cbRecurring = $("cbRecurring");
  const cbInstallment = $("cbInstallment");
  const cbFinance = $("cbFinance");
  const installmentFields = $("installmentFields");
  const financeFields = $("financeFields");
  const cardInstallment = $("cardInstallment");
  const cardFinance = $("cardFinance");
  const installmentTotal = $("installmentTotal");
  const installmentCurrent = $("installmentCurrent");
  const installmentHint = $("installmentHint");
  const financeTotal = $("financeTotal");
  const financeCurrent = $("financeCurrent");
  const financeHint = $("financeHint");

  const txnTable = $("txnTable");
  const txnStatus = $("txnStatus");

  const appError = $("appError");
  const opsError = $("opsError");
  const appShell = document.querySelector(".app-shell");
  const sidebarToggle = $("sidebarToggle");

  const diagWallet = $("diagWallet");
  const diagRole = $("diagRole");
  const diagType = $("diagType");
  const diagMemberStatus = $("diagMemberStatus");
  const diagMembershipStatus = $("diagMembershipStatus");
  const diagActionStatus = $("diagActionStatus");
  const diagError = $("diagError");
  const btnRunDiag = $("btnRunDiag");
  const btnReconcile = $("btnReconcile");
  const btnMigrateTxnV2 = $("btnMigrateTxnV2");
  const migrateStatus = $("migrateStatus");

  const planTitle = $("planTitle");
  const planType = $("planType");
  const planTxnType = $("planTxnType");
  const planCategory = $("planCategory");
  const planAmountEach = $("planAmountEach");
  const planAmountTotal = $("planAmountTotal");
  const planMonthsTotal = $("planMonthsTotal");
  const planStartMonth = $("planStartMonth");
  const planPaymentMethod = $("planPaymentMethod");
  const planCreditCard = $("planCreditCard");
  const planPurchaseDate = $("planPurchaseDate");
  const planAmountEachWrap = $("planAmountEachWrap");
  const planAmountTotalWrap = $("planAmountTotalWrap");
  const planMonthsWrap = $("planMonthsWrap");
  const planPaymentWrap = $("planPaymentWrap");
  const planCardWrap = $("planCardWrap");
  const planPurchaseWrap = $("planPurchaseWrap");
  const btnCreatePlan = $("btnCreatePlan");
  const planStatus = $("planStatus");
  const planTable = $("planTable");

  const cardName = $("cardName");
  const cardClosingDay = $("cardClosingDay");
  const cardDueDay = $("cardDueDay");
  const btnAddCard = $("btnAddCard");
  const cardStatus = $("cardStatus");
  const cardTable = $("cardTable");

  const statementCard = $("statementCard");
  const statementMeta = $("statementMeta");
  const statementStatus = $("statementStatus");
  const statementTable = $("statementTable");
  const statementItemsTable = $("statementItemsTable");
  const statementItemsMonth = $("statementItemsMonth");
  const statementSummaryMonth = $("statementSummaryMonth");
  const statementSummaryTotal = $("statementSummaryTotal");
  const statementSummaryStatus = $("statementSummaryStatus");
  const statementSummaryCount = $("statementSummaryCount");

  const editModal = $("editModal");
  const editHelper = $("editHelper");
  const editTxnDate = $("editTxnDate");
  const editTxnType = $("editTxnType");
  const editTxnCat = $("editTxnCat");
  const editTxnAmount = $("editTxnAmount");
  const editTxnNote = $("editTxnNote");
  const btnCloseEdit = $("btnCloseEdit");
  const btnSaveEdit = $("btnSaveEdit");
  const editStatus = $("editStatus");
  const editError = $("editError");
  const editCardModal = $("editCardModal");
  const editCardName = $("editCardName");
  const editCardClosingDay = $("editCardClosingDay");
  const editCardDueDay = $("editCardDueDay");
  const btnCloseCardEdit = $("btnCloseCardEdit");
  const btnSaveCardEdit = $("btnSaveCardEdit");
  const editCardStatus = $("editCardStatus");
  const editCardError = $("editCardError");

  const state = {
    user: null,
    email: null,
    uid: null,
    displayName: "",
    walletId: null,
    walletRole: null,
    walletType: null,
    walletName: null,
    walletLabels: new Map(),
    coupleTab: "totals",
    categories: new Map(), // catId -> {name, kind}
    creditCards: new Map(), // cardId -> {name, closingDay, dueDay, status}
    creditCardsCollectionName: null,
    plans: new Map(), // planId -> plan data
    currentRows: [],
    txnCache: new Map(),
    statementEntries: [],
    statementEntriesByMonth: new Map(),
    activeStatementMonth: null,
    statementItemsCache: [],
    statementItemsMonth: null,
    editingTxnId: null,
    editingCardId: null,
    sort: {
      transactions: { key: "date", dir: "desc" },
      categories: { key: "name", dir: "asc" },
      plans: { key: "title", dir: "asc" },
      cards: { key: "name", dir: "asc" },
      statements: { key: "month", dir: "asc" },
      statementItems: { key: "date", dir: "asc" }
    }
  };
  let authReady = false;
  let appReady = false;
  let lastAppHash = "#/app/dashboard";
  Object.entries(FRIENDLY_WALLET_NAMES).forEach(([id, label]) => state.walletLabels.set(id, label));

  function setAuthMessage(msg, isError = false) {
    if (authStatus) authStatus.textContent = isError ? "" : msg;
    if (authError) authError.textContent = isError ? msg : "";
  }
  function setAppError(msg = "") { appError.textContent = msg; }
  function setOpsError(msg = "") { opsError.textContent = msg; }

  function formatMonthKey(date) {
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) return "";
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    return `${y}-${m}`;
  }

  function alignDateToMonthKey(baseDate, monthKey) {
    if (!(baseDate instanceof Date) || Number.isNaN(baseDate.getTime())) return baseDate;
    if (!monthKey) return baseDate;
    const [yearStr, monthStr] = monthKey.split("-");
    const year = Number(yearStr);
    const month = Number(monthStr);
    if (!year || !month) return baseDate;
    const day = baseDate.getDate();
    const lastDay = new Date(year, month, 0).getDate();
    return new Date(year, month - 1, Math.min(day, lastDay));
  }

  function addMonthsPreserveDay(baseDate, offset) {
    if (!(baseDate instanceof Date) || Number.isNaN(baseDate.getTime())) return baseDate;
    const day = baseDate.getDate();
    const target = new Date(baseDate.getFullYear(), baseDate.getMonth() + offset, 1);
    const lastDay = new Date(target.getFullYear(), target.getMonth() + 1, 0).getDate();
    target.setDate(Math.min(day, lastDay));
    return target;
  }

  function addMonthsToMonthKey(monthKey, offset) {
    if (!monthKey) return "";
    const [yearStr, monthStr] = monthKey.split("-");
    const year = Number(yearStr);
    const month = Number(monthStr);
    if (!year || !month) return "";
    const target = new Date(year, month - 1 + Number(offset || 0), 1);
    return formatMonthKey(target);
  }

  function splitCents(totalCents, count) {
    const total = Number(totalCents || 0);
    const qty = Math.max(1, Number(count || 1));
    const base = Math.floor(total / qty);
    const remainder = total - base * qty;
    return Array.from({ length: qty }, (_, idx) => base + (idx < remainder ? 1 : 0));
  }

  function normalizeTxn(txn) {
    const normalized = normalizeTxnV2(txn);
    if (!normalized || typeof normalized !== "object") return normalized;
    if (normalized.monthKey) return normalized;
    const dateVal = normalized.date?.toDate?.() ?? normalized.date;
    if (dateVal instanceof Date && !Number.isNaN(dateVal.getTime())) {
      normalized.monthKey = formatMonthKey(dateVal);
      return normalized;
    }
    if (normalized.invoiceMonth || normalized.statementMonth) {
      normalized.monthKey = normalized.invoiceMonth || normalized.statementMonth;
    }
    return normalized;
  }

  function withMonthKey(txnData) {
    if (!txnData || typeof txnData !== "object") return txnData;
    if (txnData.monthKey) return txnData;
    const dateVal = txnData.date?.toDate?.() ?? txnData.date;
    if (dateVal instanceof Date && !Number.isNaN(dateVal.getTime())) {
      return { ...txnData, monthKey: formatMonthKey(dateVal) };
    }
    return { ...txnData };
  }

  function getPlanBaseDate(plan) {
    if (!plan || typeof plan !== "object") return null;
    const startDate = plan.startDate?.toDate?.() ?? plan.startDate;
    if (startDate instanceof Date && !Number.isNaN(startDate.getTime())) return startDate;
    const startMonth = plan.startMonth || "";
    const startDay = Number(plan.startDay || 1);
    if (!startMonth) return null;
    const [yearStr, monthStr] = startMonth.split("-");
    const year = Number(yearStr);
    const month = Number(monthStr);
    if (!year || !month) return null;
    const lastDay = new Date(year, month, 0).getDate();
    return new Date(year, month - 1, Math.min(startDay || 1, lastDay));
  }

  function setView(viewKey) {
    const map = { login: viewLogin, app: viewApp, loading: viewLoading };
    Object.entries(map).forEach(([key, el]) => {
      if (!el) return;
      const active = key === viewKey;
      el.hidden = !active;
      el.classList.toggle("active", active);
    });
  }

  function navigate(hash, { replace = false } = {}) {
    const next = hash.startsWith("#") ? hash : `#${hash}`;
    if (location.hash === next) return;
    if (replace) {
      location.replace(next);
    } else {
      location.hash = next;
    }
  }

  function parseRoute() {
    const hash = location.hash || "";
    if (hash === "#/app" || hash === "#/app/") {
      return { view: "app", page: "dashboard" };
    }
    if (hash.startsWith("#/app/")) {
      const parts = hash.split("/");
      return { view: "app", page: parts[2] || "dashboard" };
    }
    if (hash.startsWith("#/login")) return { view: "login" };
    return { view: "login" };
  }

  function renderRoute() {
    if (!authReady) {
      setView("loading");
      return;
    }
    const route = parseRoute();
    if (!state.user) {
      if (route.view !== "login") {
        navigate("#/login", { replace: true });
        return;
      }
      setView("login");
      setAuthLoading(false);
      return;
    }
    if (route.view !== "app") {
      navigate(lastAppHash || "#/app/dashboard", { replace: true });
      return;
    }
    const pageKey = pages?.[route.page] ? route.page : "dashboard";
    if (route.page !== pageKey) {
      navigate(`#/app/${pageKey}`, { replace: true });
      return;
    }
    lastAppHash = `#/app/${pageKey}`;
    setView("app");
    showPage(pageKey);
  }

  function setAuthLoading(isLoading, message = "") {
    if (btnEmail) btnEmail.disabled = isLoading;
    if (btnGoogle) btnGoogle.disabled = isLoading;
    if (btnForgot) btnForgot.disabled = isLoading;
    if (authLoading) authLoading.hidden = !isLoading;
    if (authLoadingText && message) authLoadingText.textContent = message;
    if (message) setAuthMessage(message, false);
  }

  function getAuthErrorMessage(err) {
    const code = err?.code || "";
    if (code === "auth/user-not-found") return "Usuario nao encontrado.";
    if (code === "auth/wrong-password") return "Senha incorreta.";
    if (code === "auth/invalid-credential") return "Credenciais invalidas.";
    if (code === "auth/invalid-email") return "E-mail invalido.";
    if (code === "auth/too-many-requests") return "Muitas tentativas. Aguarde e tente novamente.";
    if (code === "auth/popup-blocked") return "Popup bloqueado. Permita popups e tente novamente.";
    if (code === "auth/popup-closed-by-user") return "Popup fechado antes de concluir.";
    if (code === "auth/cancelled-popup-request") return "Popup cancelado. Tente novamente.";
    return "Nao foi possivel entrar. Confira seus dados e tente novamente.";
  }

  function getDisplayName(user) {
    const fallback = (user?.email || "").split("@")[0] || "Usuario";
    return user?.displayName || fallback;
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function toBRL(cents) {
    const v = (Number(cents || 0) / 100);
    return v.toLocaleString("pt-BR", { style: "currency", currency: "BRL" });
  }

  function parseAmountToCents(text) {
    const clean = (text ?? "").trim().replace(/\./g, "").replace(",", ".");
    const n = Number(clean);
    if (!Number.isFinite(n)) return null;
    return Math.round(n * 100);
  }

  function formatCentsToInputValue(cents) {
    const v = Number(cents || 0) / 100;
    return v.toFixed(2).replace(".", ",");
  }

  function parsePositiveInt(value) {
    const n = Number(value);
    if (!Number.isFinite(n) || n <= 0) return null;
    return Math.trunc(n);
  }

  function buildTxnV2Defaults(type = "expense", originalType = null) {
    const baseType = type || "expense";
    return {
      originalType: originalType || baseType,
      paymentMethod: "outro",
      recurring: { isRecurring: false, cadence: "none" },
      installment: { isInstallment: false, total: null, current: null },
      finance: { isFinance: false, total: null, current: null }
    };
  }

  function normalizeTxnV2(txn = {}) {
    const baseType = txn.type ?? "expense";
    const defaults = buildTxnV2Defaults(baseType, txn.originalType ?? baseType);
    const paymentRaw = (txn.paymentMethod ?? "").trim();

    return {
      ...txn,
      type: baseType,
      originalType: txn.originalType ?? defaults.originalType,
      paymentMethod: paymentRaw || defaults.paymentMethod,
      recurring: {
        isRecurring: Boolean(txn.recurring?.isRecurring),
        cadence: txn.recurring?.cadence ?? (txn.recurring?.isRecurring ? "monthly" : defaults.recurring.cadence)
      },
      installment: {
        isInstallment: Boolean(txn.installment?.isInstallment),
        total: txn.installment?.total ?? defaults.installment.total,
        current: txn.installment?.current ?? defaults.installment.current
      },
      finance: {
        isFinance: Boolean(txn.finance?.isFinance),
        total: txn.finance?.total ?? defaults.finance.total,
        current: txn.finance?.current ?? defaults.finance.current
      }
    };
  }

  function buildTxnV2Payload(rawType, type) {
    const defaults = buildTxnV2Defaults(type, rawType || type);
    const paymentRaw = (txnPayment?.value ?? "").trim();
    const paymentMethod = paymentRaw || defaults.paymentMethod;

    const isRecurring = !!cbRecurring?.checked;
    const recurring = {
      isRecurring,
      cadence: isRecurring ? "monthly" : defaults.recurring.cadence
    };

    const isInstallment = !!cbInstallment?.checked;
    const installment = {
      isInstallment,
      total: isInstallment ? parsePositiveInt(installmentTotal?.value) : defaults.installment.total,
      current: isInstallment ? parsePositiveInt(installmentCurrent?.value) : defaults.installment.current
    };

    const isFinance = !!cbFinance?.checked;
    const finance = {
      isFinance,
      total: isFinance ? parsePositiveInt(financeTotal?.value) : defaults.finance.total,
      current: isFinance ? parsePositiveInt(financeCurrent?.value) : defaults.finance.current
    };

    return {
      originalType: defaults.originalType,
      paymentMethod,
      recurring,
      installment,
      finance
    };
  }

  function buildTxnV2MergePatch(txn = {}) {
    const baseType = txn.type ?? "expense";
    const patch = {};

    if (!txn.originalType) patch.originalType = baseType;

    const paymentRaw = (txn.paymentMethod ?? "").trim();
    if (!paymentRaw) patch.paymentMethod = "outro";

    const recurringPatch = {};
    if (txn.recurring?.isRecurring == null) recurringPatch.isRecurring = false;
    if (txn.recurring?.cadence == null) recurringPatch.cadence = "none";
    if (Object.keys(recurringPatch).length) patch.recurring = recurringPatch;

    const installmentPatch = {};
    if (txn.installment?.isInstallment == null) installmentPatch.isInstallment = false;
    if (txn.installment?.total == null) installmentPatch.total = null;
    if (txn.installment?.current == null) installmentPatch.current = null;
    if (Object.keys(installmentPatch).length) patch.installment = installmentPatch;

    const financePatch = {};
    if (txn.finance?.isFinance == null) financePatch.isFinance = false;
    if (txn.finance?.total == null) financePatch.total = null;
    if (txn.finance?.current == null) financePatch.current = null;
    if (Object.keys(financePatch).length) patch.finance = financePatch;

    return patch;
  }

  function parseYYYYMM(yyyyMM) {
    if (!/^\d{4}-\d{2}$/.test(yyyyMM || "")) return null;
    const [y, m] = yyyyMM.split("-").map(Number);
    if (!y || !m || m < 1 || m > 12) return null;
    return { y, m };
  }

  function formatYYYYMM(y, m) {
    const mm = String(m).padStart(2, "0");
    return `${y}-${mm}`;
  }

  function addMonthsYYYYMM(yyyyMM, delta) {
    const parsed = parseYYYYMM(yyyyMM);
    if (!parsed) return null;
    const total = parsed.y * 12 + (parsed.m - 1) + delta;
    const y = Math.floor(total / 12);
    const m = (total % 12) + 1;
    return formatYYYYMM(y, m);
  }

  function compareYYYYMM(a, b) {
    const pa = parseYYYYMM(a);
    const pb = parseYYYYMM(b);
    if (!pa || !pb) return 0;
    const va = pa.y * 12 + (pa.m - 1);
    const vb = pb.y * 12 + (pb.m - 1);
    return va === vb ? 0 : (va < vb ? -1 : 1);
  }

  function monthDiff(startYYYYMM, endYYYYMM) {
    const start = parseYYYYMM(startYYYYMM);
    const end = parseYYYYMM(endYYYYMM);
    if (!start || !end) return 0;
    return (end.y - start.y) * 12 + (end.m - start.m);
  }

  function firstDateOfMonth(yyyyMM) {
    const parsed = parseYYYYMM(yyyyMM);
    if (!parsed) return null;
    return new Date(parsed.y, parsed.m - 1, 1, 0, 0, 0);
  }

  function timestampFromYYYYMM(yyyyMM) {
    const date = firstDateOfMonth(yyyyMM);
    return date ? Timestamp.fromDate(date) : null;
  }

  function splitAmountByMonths(totalCents, monthsTotal) {
    const total = Number(totalCents || 0);
    const months = Number(monthsTotal || 0);
    if (!Number.isFinite(total) || !Number.isFinite(months) || months <= 0) return [];
    const base = Math.floor(total / months);
    const remainder = total - base * months;
    const amounts = [];
    for (let i = 1; i <= months; i += 1) {
      amounts.push(base + (i <= remainder ? 1 : 0));
    }
    return amounts;
  }

  function normalizeClosingDay(value, fallback = 31) {
    const n = Number(value);
    if (Number.isFinite(n) && n >= 1 && n <= 31) return n;
    return fallback;
  }

  function computeInvoiceMonth(purchaseDate, closingDay) {
    const d = purchaseDate instanceof Date ? purchaseDate : new Date(purchaseDate || Date.now());
    if (!(d instanceof Date) || Number.isNaN(d.getTime())) return "";
    const closing = normalizeClosingDay(closingDay);
    const monthOffset = d.getDate() <= closing ? 1 : 2;
    const totalMonths = (d.getFullYear() * 12) + (d.getMonth()) + monthOffset;
    const y = Math.floor(totalMonths / 12);
    const m = (totalMonths % 12) + 1;
    return formatYYYYMM(y, m);
  }

  function yyyyMMFromMonthInput(value) {
    if (!value || !/^\d{4}-\d{2}$/.test(value)) return null;
    return value;
  }

  function yyyyMMFromDateStr(dateStr) {
    if (!dateStr || dateStr.length < 7) return null;
    return dateStr.slice(0, 7);
  }

  function yyyyMMFromTimestamp(ts) {
    try {
      const d = ts?.toDate?.();
      if (!d) return null;
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      return `${d.getFullYear()}-${mm}`;
    } catch { return null; }
  }

  function startEndForMonth(yyyyMM) {
    const [y, m] = yyyyMM.split("-").map(Number);
    const start = new Date(Date.UTC(y, m - 1, 1, 0, 0, 0));
    const end = new Date(Date.UTC(y, m, 1, 0, 0, 0));
    return { start, end };
  }

  function toISODateLocal(d) {
    const pad = (x) => String(x).padStart(2, "0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  }

  function currentDateInTZ(timeZone = "America/Sao_Paulo") {
    try {
      const iso = new Date().toLocaleString("en-US", { timeZone, hour12: false });
      return new Date(iso);
    } catch {
      return new Date();
    }
  }

  function currentYYYYMM(timeZone = "America/Sao_Paulo") {
    const d = currentDateInTZ(timeZone);
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    return `${d.getFullYear()}-${mm}`;
  }

  function monthLabelFromYYYYMM(yyyyMM) {
    if (!yyyyMMFromMonthInput(yyyyMM)) return "Mês";
    const [y, m] = yyyyMM.split("-").map(Number);
    // usa data local (não UTC) para evitar regressão de mês ao aplicar timezone
    const d = new Date(y, m - 1, 1);
    const raw = d.toLocaleString("pt-BR", { month: "long", timeZone: "America/Sao_Paulo" }) || "";
    return raw ? raw.charAt(0).toUpperCase() + raw.slice(1) : "Mês";
  }

  function renderKPIs(incomeCents, expenseCents) {
    const bal = Number(incomeCents || 0) - Number(expenseCents || 0);
    kpiIncome.textContent = toBRL(incomeCents);
    kpiExpense.textContent = toBRL(expenseCents);
    kpiBalance.textContent = toBRL(bal);
  }

  function syncMonthLabel() {
    if (monthDisplay) monthDisplay.textContent = monthLabelFromYYYYMM(monthInput.value) || "Mês";
  }

  function shiftMonth(delta) {
    const current = yyyyMMFromMonthInput(monthInput.value)
      || currentYYYYMM()
      || yyyyMMFromDateStr(toISODateLocal(currentDateInTZ()));
    if (!current) return;
    const [y, m] = current.split("-").map(Number);
    const nextDate = new Date(Date.UTC(y, m - 1 + delta, 1));
    const mm = String(nextDate.getUTCMonth() + 1).padStart(2, "0");
    const yyyyMM = `${nextDate.getUTCFullYear()}-${mm}`;
    monthInput.value = yyyyMM;
    syncMonthLabel();
    reloadAll();
  }

  function renderMovementList(target, rows) {
    if (!target) return;
    target.innerHTML = "";
    if (!rows || rows.length === 0) {
      target.innerHTML = `<p class="muted">Sem lançamentos.</p>`;
      return;
    }
    const limited = rows.slice(0, 6);
    for (const r of limited) {
      const dateToShow = (isCreditCardPayment(r.paymentMethod) && r.purchaseDate) ? r.purchaseDate : r.date;
      const dt = dateToShow ? toISODateLocal(dateToShow) : "-";
      const label = occurrenceCounterLabel(r);
      const showRecurringIcon = shouldShowRecurringIcon(r);
      const descBase = (r.note || "").trim();
      const descText = descBase || (label || showRecurringIcon ? "(sem descricao)" : "");
      const labelHtml = label ? ` <span class="installment-badge">${escapeHtml(label)}</span>` : "";
      const recurringHtml = showRecurringIcon ? `<span class="recurring-icon" aria-label="Recorrente">${ICON_RECURRING}</span>` : "";
      const card = document.createElement("div");
      card.className = "move-card";
      card.innerHTML = `
        <div class="move-meta">
          <span>${escapeHtml(dt)} - ${escapeHtml(r.categoryName || "-")}</span>
          <span class="move-amount">${toBRL(Math.abs(r.amountCents))}</span>
        </div>
        <div class="muted">${escapeHtml(descText)}${labelHtml}${recurringHtml}${r.sourceLabel ? ` - ${escapeHtml(r.sourceLabel)}` : ""}</div>
      `;
      target.appendChild(card);
    }
  }

  function renderDashboardMovements(rows) {
    const incomeRows = [];
    const expenseRows = [];
    for (const r of rows || []) {
      if (r.type === "income") incomeRows.push(r);
      else expenseRows.push(r);
    }
    renderMovementList(incomeList, incomeRows);
    renderMovementList(expenseList, expenseRows);
  }

  function syncOptionalFields() {
    const isExpense = txnType.value === "expense";
    const isIncome = txnType.value === "income";
    const allowInstallment = isExpense || isIncome;

    if (cardInstallment) cardInstallment.hidden = !allowInstallment;
    if (cardFinance) cardFinance.hidden = !isExpense;

    if (!allowInstallment && cbInstallment) cbInstallment.checked = false;
    if (!isExpense && cbFinance) cbFinance.checked = false;

    const showInstallment = allowInstallment && cbInstallment.checked;
    const showFinance = isExpense && cbFinance.checked;

    if (installmentFields) installmentFields.hidden = !showInstallment;
    if (financeFields) financeFields.hidden = !showFinance;

    [installmentTotal, installmentCurrent].forEach((el) => { if (el) el.disabled = !showInstallment; });
    [financeTotal, financeCurrent].forEach((el) => { if (el) el.disabled = !showFinance; });

    const currentInstallment = parsePositiveInt(installmentCurrent?.value) || 1;
    if (installmentHint) {
      installmentHint.hidden = !showInstallment || currentInstallment <= 1;
    }
    const currentFinance = parsePositiveInt(financeCurrent?.value) || 1;
    if (financeHint) {
      financeHint.hidden = !showFinance || currentFinance <= 1;
    }
  }

  function syncCreditTxnFields() {
    if (!creditTxnFields) return;
    const isCredit = isCreditCardPayment(txnPayment?.value);
    creditTxnFields.hidden = !isCredit;
  }

  function syncPlanFields() {
    if (!planType) return;
    const type = planType.value;
    const isRecurring = type === "recurring";
    const isCredit = type === "credit_installment";

    if (planAmountEachWrap) planAmountEachWrap.hidden = !isRecurring;
    if (planAmountTotalWrap) planAmountTotalWrap.hidden = isRecurring;
    if (planMonthsWrap) planMonthsWrap.hidden = isRecurring;

    if (planPaymentWrap) planPaymentWrap.hidden = isCredit;
    if (planPaymentMethod) {
      if (isCredit) {
        planPaymentMethod.value = "credit_card";
        planPaymentMethod.disabled = true;
      } else {
        planPaymentMethod.disabled = false;
        if (!planPaymentMethod.value) planPaymentMethod.value = "outro";
      }
    }

    if (planCardWrap) planCardWrap.hidden = !isCredit;
    if (planPurchaseWrap) planPurchaseWrap.hidden = !isCredit;
  }

  function syncCoupleTabs() {
    if (!coupleTabs) return;
    coupleTabs.querySelectorAll(".tab").forEach((btn) => {
      const tab = btn.getAttribute("data-tab");
      btn.classList.toggle("active", tab === state.coupleTab);
    });
  }

  function isCoupleWallet() {
    return state.walletId === COUPLE_WALLET_ID && state.walletType === "aggregate";
  }

  function isPersonalWalletId(walletId) {
    return PERSONAL_WALLETS.has(walletId);
  }

  function friendlyWalletLabel(walletId, fallbackName = "") {
    if (FRIENDLY_WALLET_NAMES[walletId]) return FRIENDLY_WALLET_NAMES[walletId];
    if (fallbackName) {
      const trimmed = fallbackName.includes("(") ? fallbackName.split("(")[0].trim() : fallbackName.trim();
      if (trimmed) return trimmed;
    }
    if (walletId?.startsWith("w_")) {
      const slug = walletId.slice(2).replace(/_/g, " ");
      return slug ? slug.charAt(0).toUpperCase() + slug.slice(1) : walletId;
    }
    return walletId || fallbackName || "";
  }

  function showPage(key) {
    const titles = {
      dashboard: "Dashboard",
      transactions: "Transações",
      categories: "Categorias",
      settings: "Preferências"
    };

    Object.entries(pages).forEach(([pageKey, el]) => {
      if (!el) return;
      const active = pageKey === key;
      el.classList.toggle("active", active);
      el.style.display = active ? "grid" : "none";
    });

    navButtons.forEach((btn) => {
      const target = btn.getAttribute("data-page-target");
      btn.classList.toggle("active", target === key);
    });

    if (pageTitle) pageTitle.textContent = titles[key] ?? "VaultFlow";
  }

  async function loginEmailPassword() {
    try {
      setAuthMessage("");
      const email = ($("email")?.value ?? "").trim().toLowerCase();
      const pass = $("pass")?.value ?? "";
      if (!email || !pass) {
        setAuthMessage("Informe email e senha.", true);
        return;
      }
      if (!ALLOWED_EMAILS.has(email)) {
        setAuthMessage("Este email nao esta autorizado.", true);
        return;
      }
      setAuthLoading(true, "Entrando...");
      await signInWithEmailAndPassword(auth, email, pass);
      setAuthMessage("Login OK.");
    } catch (e) {
      setAuthMessage(getAuthErrorMessage(e), true);
    } finally {
      setAuthLoading(false);
    }
  }

  async function loginGoogle() {
    try {
      setAuthMessage("");
      setAuthLoading(true, "Abrindo Google...");
      const provider = new GoogleAuthProvider();
      const result = await signInWithPopup(auth, provider);
      const email = (result.user.email ?? "").toLowerCase();
      if (!ALLOWED_EMAILS.has(email)) {
        await signOut(auth);
        throw new Error("Email nao autorizado.");
      }
      setAuthMessage("Login Google OK.");
    } catch (e) {
      const msg = e?.message?.toLowerCase?.() || "";
      if (msg.includes("autoriz")) {
        setAuthMessage("Conta Google nao autorizada.", true);
      } else {
        setAuthMessage(getAuthErrorMessage(e), true);
      }
    } finally {
      setAuthLoading(false);
    }
  }

  async function resetPassword() {
    try {
      setAuthMessage("");
      const email = ($("email")?.value ?? "").trim().toLowerCase();
      if (!email) {
        setAuthMessage("Informe seu email para recuperar a senha.", true);
        return;
      }
      if (!ALLOWED_EMAILS.has(email)) {
        setAuthMessage("Este email nao esta autorizado.", true);
        return;
      }
      setAuthLoading(true, "Enviando link...");
      await sendPasswordResetEmail(auth, email);
      setAuthMessage("Email de recuperacao enviado.");
    } catch (e) {
      setAuthMessage("Nao foi possivel enviar o link. Tente novamente.", true);
    } finally {
      setAuthLoading(false);
    }
  }

  async function logout() {
    await signOut(auth);
    navigate("#/login", { replace: true });
  }

  function resetSessionState() {
    state.user = null;
    state.email = null;
    state.uid = null;
    state.displayName = "";
    state.editingTxnId = null;
    appReady = false;
    if (btnLogout) btnLogout.style.display = "none";
    if (me) me.textContent = "Aguardando login";
    renderDashboardMovements([]);
    if (editModal) editModal.hidden = true;
  }

  async function bootstrapUser(user) {
    if (!user) return;
    const email = (user.email ?? "").toLowerCase();
    if (!ALLOWED_EMAILS.has(email)) {
      await signOut(auth);
      throw new Error("Email nao autorizado.");
    }

    if (appReady && state.uid === user.uid) return;

    state.user = user;
    state.email = email;
    state.uid = user.uid;
    state.displayName = getDisplayName(user);
    if (me) me.textContent = state.displayName;
    if (btnLogout) btnLogout.style.display = "";

    await ensureUserProfile(user);
    await ensureWalletMetaIfOwner(user);
    await ensureMembershipShortcutsFromMembers(user);

    const wallets = await loadWalletOptions(user);
    selectDefaultWallet(wallets);
    await refreshWalletContext();
    appReady = true;
  }

  // ===== Bootstrap =====

  async function ensureUserProfile(user) {
    const ref = doc(db, "users", user.uid);
    const snap = await getDoc(ref);
    if (!snap.exists()) {
      await setDoc(ref, {
        displayName: user.displayName ?? (user.email?.split("@")[0] ?? "Usuário"),
        email: (user.email ?? "").toLowerCase(),
        createdAt: Timestamp.now()
      }, { merge: true });
    } else {
      await setDoc(ref, {
        email: (user.email ?? "").toLowerCase(),
        displayName: snap.data().displayName ?? user.displayName ?? "Usuário"
      }, { merge: true });
    }
  }

  async function ensureWalletMetaIfOwner(user) {
    const email = (user.email ?? "").toLowerCase();
    const uid = user.uid;

    const isMarcelino = email === "hbmarc35@gmail.com";
    const isLuiza = email === "lzmarc25@gmail.com";

    async function upsertWallet(walletId, dataIfCreate, dataMerge) {
      const wRef = doc(db, "wallets", walletId);
      const wSnap = await getDoc(wRef);
      if (!wSnap.exists()) {
        await setDoc(wRef, dataIfCreate, { merge: false });
      } else {
        await setDoc(wRef, dataMerge, { merge: true });
      }
    }

    if (isMarcelino) {
      await upsertWallet(
        "w_marcelino",
        { name: "Marcelino", type: "personal", createdBy: uid, createdAt: Timestamp.now() },
        { name: "Marcelino", type: "personal" }
      );
    }

    if (isLuiza) {
      await upsertWallet(
        "w_luiza",
        { name: "Luiza", type: "personal", createdBy: uid, createdAt: Timestamp.now() },
        { name: "Luiza", type: "personal" }
      );
    }

    if (isMarcelino || isLuiza) {
      const srcRefs = [
        doc(db, "wallets", "w_marcelino"),
        doc(db, "wallets", "w_luiza")
      ];
      await upsertWallet(
        "w_casal",
        {
          name: "Casal",
          type: "aggregate",
          createdBy: uid,
          createdAt: Timestamp.now(),
          sources: srcRefs
        },
        {
          name: "Casal",
          type: "aggregate",
          sources: srcRefs
        }
      );
    }
  }

  async function ensureMembershipShortcutsFromMembers(user) {
    const membershipCol = collection(db, "users", user.uid, "memberships");
    const existing = await getDocs(membershipCol);
    if (existing.size > 0) return;

    for (const walletId of KNOWN_WALLETS) {
      try {
        const mRef = doc(db, "wallets", walletId, "members", user.uid);
        const mSnap = await getDoc(mRef);
        if (!mSnap.exists()) continue;

        const role = mSnap.data().role;
        await setDoc(doc(db, "users", user.uid, "memberships", walletId), {
          role,
          createdAt: Timestamp.now()
        }, { merge: true });
      } catch {
        // ignore
      }
    }
  }

  async function loadWalletOptions(user) {
    const membershipCol = collection(db, "users", user.uid, "memberships");
    const snaps = await getDocs(membershipCol);
    const list = snaps.docs.map(d => ({ walletId: d.id, role: d.data().role }));

    const personalId = USER_PERSONAL_WALLET[state.email];

    // mantém só a carteira pessoal do usuário e o casal (se existirem); se nada sobrar, usa a lista original
    const filtered = list.filter(w => w.walletId === personalId || w.walletId === COUPLE_WALLET_ID);
    const effectiveList = filtered.length ? filtered : list;

    // Ordena priorizando pessoais antes das agregadas
    effectiveList.sort((a, b) => {
      const aPersonal = PERSONAL_WALLETS.has(a.walletId);
      const bPersonal = PERSONAL_WALLETS.has(b.walletId);
      if (aPersonal !== bPersonal) return aPersonal ? -1 : 1;
      return (state.walletLabels.get(a.walletId) || a.walletId).localeCompare(state.walletLabels.get(b.walletId) || b.walletId);
    });

    walletSelect.innerHTML = "";
    state.walletLabels.clear();
    for (const item of effectiveList) {
      let label = item.walletId;
      let type = "?";
      try {
        const wSnap = await getDoc(doc(db, "wallets", item.walletId));
        if (wSnap.exists()) {
          label = wSnap.data().name ?? item.walletId;
          type = wSnap.data().type ?? "?";
        }
      } catch {}

      let friendly = friendlyWalletLabel(item.walletId, label);
      if (item.walletId === personalId) friendly = "Pessoal";
      if (item.walletId === COUPLE_WALLET_ID) friendly = "Casal";
      state.walletLabels.set(item.walletId, friendly);

      const opt = document.createElement("option");
      opt.value = item.walletId;
      opt.textContent = friendly;
      opt.dataset.type = type;
      walletSelect.appendChild(opt);
    }
    return effectiveList;
  }

  function selectDefaultWallet(wallets) {
    const current = walletSelect.value;
    const hasCurrent = wallets.some(w => w.walletId === current);
    if (hasCurrent && isPersonalWalletId(current)) return;

    const preferredId = USER_PERSONAL_WALLET[state.email];
    if (preferredId && wallets.some(w => w.walletId === preferredId)) {
      walletSelect.value = preferredId;
      return;
    }

    const casal = wallets.find(w => w.walletId === COUPLE_WALLET_ID);
    if (casal) {
      walletSelect.value = casal.walletId;
      return;
    }

    if (hasCurrent) {
      walletSelect.value = current;
      return;
    }

    if (wallets.length > 0) {
      walletSelect.value = wallets[0].walletId;
    }
  }

  async function refreshWalletContext() {
    setAppError("");
    setOpsError("");

    const walletId = walletSelect.value;
    if (!walletId) {
      setAppError("Nenhuma carteira disponível para sua conta.");
      return;
    }

    let role = null;
    try {
      const mSnap = await getDoc(doc(db, "users", state.uid, "memberships", walletId));
      role = mSnap.exists() ? mSnap.data().role : null;
    } catch {}

    let name = walletId;
    let type = "?";
    try {
      const wSnap = await getDoc(doc(db, "wallets", walletId));
      if (wSnap.exists()) {
        name = wSnap.data().name ?? walletId;
        type = wSnap.data().type ?? "?";
      }
    } catch (e) {
      setAppError("Não foi possível carregar a carteira. Tente novamente.");
    }

    state.walletId = walletId;
    state.walletRole = role ?? "-";
    state.walletType = type;
    state.walletName = friendlyWalletLabel(walletId, name);
    state.walletLabels.set(walletId, state.walletName);
    state.creditCardsCollectionName = null;

    const couple = isCoupleWallet();
    state.coupleTab = couple ? "details" : "totals";
    syncCoupleTabs();
    coupleTabs.style.display = couple ? "" : "none";
    coupleHint.style.display = couple ? "" : "none";
    coupleBreakdown.style.display = couple ? "" : "none";

    const disablePersonal = couple;
    [catName, catKind, btnAddCat, btnSeedCats].forEach((el) => el && (el.disabled = disablePersonal));
    [txnDate, txnType, txnCat, txnAmount, txnNote, txnPayment, txnCard, btnAddTxn].forEach((el) => el && (el.disabled = disablePersonal));
    [
      planTitle, planType, planTxnType, planCategory, planAmountEach, planAmountTotal, planMonthsTotal,
      planStartMonth, planPaymentMethod, planCreditCard, planPurchaseDate, btnCreatePlan
    ].forEach((el) => el && (el.disabled = disablePersonal));
    [cardName, cardClosingDay, cardDueDay, btnAddCard, statementCard].forEach((el) => el && (el.disabled = disablePersonal));
    if (catStatus) catStatus.textContent = disablePersonal ? "Categorias não disponíveis nesta visão." : "";
    if (disablePersonal && txnStatus) txnStatus.textContent = "Visão consolidada em modo leitura.";
    if (disablePersonal && planStatus) planStatus.textContent = "Planos não disponíveis nesta visão.";
    if (disablePersonal && cardStatus) cardStatus.textContent = "Cartões não disponíveis nesta visão.";

    const now = new Date();
    txnDate.value = toISODateLocal(now);

    await loadCreditCards();
    await reloadAll();
    await loadPlans();
  }

  async function runDiagnostics() {
    if (!diagError || !diagWallet || !diagRole || !diagType || !diagMemberStatus || !diagMembershipStatus) {
      return;
    }
    diagError.textContent = "";

    if (!state.walletId) {
      diagError.textContent = "Selecione uma wallet para avaliar.";
      return;
    }

    diagWallet.textContent = `${state.walletName} (${state.walletId})`;
    diagRole.textContent = state.walletRole ?? "-";
    diagType.textContent = state.walletType ?? "-";

    try {
      const memberRef = doc(db, "wallets", state.walletId, "members", state.uid);
      const memberSnap = await getDoc(memberRef);
      const memberRole = memberSnap.exists() ? (memberSnap.data()?.role ?? "-") : null;

      const membershipRef = doc(db, "users", state.uid, "memberships", state.walletId);
      const membershipSnap = await getDoc(membershipRef);
      const membershipRole = membershipSnap.exists() ? (membershipSnap.data()?.role ?? "-") : null;

      if (memberSnap.exists()) {
        diagMemberStatus.textContent = `OK: wallets/${state.walletId}/members/${state.uid} (role: ${memberRole})`;
      } else {
        diagMemberStatus.textContent = `FALHA: wallets/${state.walletId}/members/${state.uid} ausente.`;
      }

      if (!membershipSnap.exists()) {
        diagMembershipStatus.textContent = `FALHA: users/${state.uid}/memberships/${state.walletId} ausente.`;
      } else if (memberRole && membershipRole && memberRole !== membershipRole) {
        diagMembershipStatus.textContent = `FALHA: role divergente (members=${memberRole}, membership=${membershipRole}).`;
      } else if (!memberSnap.exists() && membershipSnap.exists()) {
        diagMembershipStatus.textContent = `FALHA: membership existe, mas usuário não está em members.`;
      } else {
        diagMembershipStatus.textContent = `OK: membership consistente (role: ${membershipRole ?? "-"}).`;
      }
    } catch (e) {
      diagError.textContent = e?.message ?? String(e);
    }
  }

  async function reconcileMembershipsFromMembers() {
    if (!btnReconcile || !diagActionStatus || !diagError) {
      return;
    }
    diagError.textContent = "";
    diagActionStatus.textContent = "Reconhecendo memberships...";
    btnReconcile.disabled = true;

    try {
      for (const walletId of KNOWN_WALLETS) {
        const memberRef = doc(db, "wallets", walletId, "members", state.uid);
        const memberSnap = await getDoc(memberRef);
        const membershipRef = doc(db, "users", state.uid, "memberships", walletId);
        const membershipSnap = await getDoc(membershipRef);

        if (!memberSnap.exists()) {
          try { await deleteDoc(membershipRef); } catch {}
          continue;
        }

        const role = memberSnap.data()?.role;
        const payload = {
          role,
          updatedAt: serverTimestamp()
        };

        if (!membershipSnap.exists()) payload.createdAt = serverTimestamp();

        await setDoc(membershipRef, payload, { merge: true });
      }

      diagActionStatus.textContent = "Reconciliado com base em wallets/*/members.";
    } catch (e) {
      diagError.textContent = e?.message ?? String(e);
    } finally {
      btnReconcile.disabled = false;
    }
  }

  // ===== Categories =====

  function setCategoryOptions(selectEl, selectedId = "", fallbackLabel = "") {
    if (!selectEl) return;
    selectEl.innerHTML = "";
    const entries = Array.from(state.categories.entries())
      .map(([id, c]) => ({ id, ...c }))
      .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));

    if (entries.length == 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "Sem categorias";
      selectEl.appendChild(opt);
      return;
    }

    let hasSelected = false;
    for (const c of entries) {
      const opt = document.createElement("option");
      opt.value = c.id;
      opt.textContent = c.name;
      if (selectedId && selectedId == c.id) hasSelected = true;
      selectEl.appendChild(opt);
    }

    if (selectedId && hasSelected) {
      selectEl.value = selectedId;
    } else if (fallbackLabel) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = fallbackLabel;
      selectEl.appendChild(opt);
      selectEl.value = "";
    }
  }

  async function loadCategories() {
    state.categories.clear();
    if (txnCat) txnCat.innerHTML = "";
    if (editTxnCat) editTxnCat.innerHTML = "";
    if (planCategory) planCategory.innerHTML = "";

    if (isCoupleWallet()) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "-";
      if (txnCat) txnCat.appendChild(opt);
      if (editTxnCat) editTxnCat.appendChild(opt.cloneNode(true));
      if (planCategory) planCategory.appendChild(opt.cloneNode(true));
      if (catGrid) catGrid.innerHTML = "";
      if (catStatus) catStatus.textContent = "Categorias nao disponiveis nesta carteira.";
      return;
    }

    const colRef = collection(db, "wallets", state.walletId, "categories");
    const snaps = await getDocs(colRef);

    for (const d of snaps.docs) {
      const data = d.data();
      state.categories.set(d.id, { name: data.name, kind: data.kind });
    }

    setCategoryOptions(txnCat);
    if (editTxnCat) setCategoryOptions(editTxnCat, editTxnCat.value);
    if (planCategory) setCategoryOptions(planCategory, planCategory.value);

    renderCategoriesTable();
    if (catStatus) catStatus.textContent = `Categorias carregadas: ${state.categories.size}`;
  }

function renderCategoriesTable() {
    if (!catGrid) return;
    catGrid.innerHTML = "";
    updateSortIndicators("categories");
    const entries = Array.from(state.categories.entries())
      .map(([id, c]) => ({ id, ...c }));
    const sorted = sortCollection("categories", entries);

    if (!sorted.length) {
      catGrid.innerHTML = `<p class="muted">Nenhuma categoria cadastrada.</p>`;
      return;
    }

    for (const c of sorted) {
      const kindLabel = c.kind === "income" ? "Receita" : (c.kind === "expense" ? "Despesa" : "Ambos");
      const card = document.createElement("div");
      card.className = "category-card";
      card.innerHTML = `
        <div class="category-head">
          <div>
            <div class="category-title">${escapeHtml(c.name)}</div>
            <span class="badge">${escapeHtml(kindLabel)}</span>
          </div>
          <div class="category-actions">
            <button class="icon-action" data-edit-cat="${c.id}" aria-label="Editar" title="Editar">${ICON_EDIT}</button>
            <button class="icon-action" data-del-cat="${c.id}" aria-label="Excluir" title="Excluir">${ICON_DELETE}</button>
          </div>
        </div>
      `;
      catGrid.appendChild(card);
    }

    catGrid.querySelectorAll("button[data-edit-cat]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-edit-cat");
        await editCategory(id);
      });
    });

    catGrid.querySelectorAll("button[data-del-cat]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-del-cat");
        if (!confirm("Excluir esta categoria?")) return;
        try {
          await deleteDoc(doc(db, "wallets", state.walletId, "categories", id));
          await loadCategories();
        } catch (e) {
          catStatus.textContent = "Nao foi possivel excluir a categoria.";
        }
      });
    });
  }

  async function addCategory() {
    setOpsError("");
    catStatus.textContent = "";
    const name = (catName.value ?? "").trim();
    const kind = catKind.value;

    if (!name) {
      catStatus.textContent = "Informe o nome da categoria.";
      return;
    }

    try {
      await addDoc(collection(db, "wallets", state.walletId, "categories"), {
        name,
        kind,
        createdAt: serverTimestamp(),
        createdBy: state.uid
      });
      catName.value = "";
      await loadCategories();
    } catch (e) {
      catStatus.textContent = "Não foi possível adicionar a categoria.";
    }
  }

  async function editCategory(catId) {
    setOpsError("");
    const current = state.categories.get(catId);
    const nextName = prompt("Editar nome da categoria", current?.name ?? "");
    if (nextName == null) return;
    const trimmed = nextName.trim();
    if (!trimmed) return;

    try {
      await setDoc(doc(db, "wallets", state.walletId, "categories", catId), { name: trimmed }, { merge: true });
      await loadCategories();
    } catch (e) {
      catStatus.textContent = "Não foi possível atualizar a categoria.";
    }
  }

  async function seedDefaultCategories() {
    setOpsError("");
    if (!confirm("Criar categorias padrão nesta carteira?")) return;

    const defaults = [
      { name: "Alimentação", kind: "expense" },
      { name: "Transporte", kind: "expense" },
      { name: "Moradia", kind: "expense" },
      { name: "Saúde", kind: "expense" },
      { name: "Lazer", kind: "expense" },
      { name: "Compras", kind: "expense" },
      { name: "Salário", kind: "income" },
      { name: "Outras receitas", kind: "income" }
    ];

    try {
      for (const c of defaults) {
        await addDoc(collection(db, "wallets", state.walletId, "categories"), {
          ...c,
          createdAt: serverTimestamp(),
          createdBy: state.uid
        });
      }
      await loadCategories();
      catStatus.textContent = "Categorias padrão criadas.";
    } catch (e) {
      catStatus.textContent = "Não foi possível criar categorias padrão agora.";
    }
  }

  // ===== Auto-sync Casal (corrigido: reads antes de writes) =====

  function clampNonNegative(n) {
    n = Number(n || 0);
    return n < 0 ? 0 : n;
  }

  function computeCoupleSourceNext(repData, sourceWalletId, deltaIncomeCents, deltaExpenseCents) {
    const sources = repData?.sources ?? {};
    const cur = sources?.[sourceWalletId] ?? {};
    const curIncome = Number(cur.incomeCents || 0);
    const curExpense = Number(cur.expenseCents || 0);

    const nextIncome = clampNonNegative(curIncome + Number(deltaIncomeCents || 0));
    const nextExpense = clampNonNegative(curExpense + Number(deltaExpenseCents || 0));

    return { nextIncome, nextExpense };
  }

  function friendlyPlanType(type) {
    switch (type) {
      case "recurring": return "Recorrente";
      case "installment": return "Parcelado";
      case "finance": return "Financiamento";
      case "credit_installment": return "Cartao parcelado";
      default: return "Plano";
    }
  }

  function isInstallmentTxn(txn) {
    if (!txn) return false;
    const hasInstallmentFlag = Boolean(txn.installment?.isInstallment);
    const hasInstallmentPlan = txn.planType === "installment" || txn.planType === "credit_installment";
    const hasInstallmentData = Number(txn.installment?.total) && Number(txn.installment?.current);
    return hasInstallmentFlag || hasInstallmentPlan || hasInstallmentData;
  }

  function isFinanceTxn(txn) {
    if (!txn) return false;
    const hasFinanceFlag = Boolean(txn.finance?.isFinance);
    const hasFinancePlan = txn.planType === "finance";
    const hasFinanceData = Number(txn.finance?.total) && Number(txn.finance?.current);
    return hasFinanceFlag || hasFinancePlan || hasFinanceData;
  }

  function occurrenceCounterLabel(txn) {
    if (!txn) return "";
    const isInstallment = isInstallmentTxn(txn);
    const isFinance = isFinanceTxn(txn);
    if (!isInstallment && !isFinance) return "";
    const total = Number((isInstallment ? txn.installment?.total : txn.finance?.total) ?? txn.occurrenceTotal ?? 0);
    const current = Number((isInstallment ? txn.installment?.current : txn.finance?.current) ?? txn.occurrenceIndex ?? 0);
    if (!Number.isFinite(total) || !Number.isFinite(current)) return "";
    if (total < 2 || current < 1) return "";
    return `${current}/${total}`;
  }

  function installmentLabel(txn) {
    return occurrenceCounterLabel(txn);
  }

  function shouldShowRecurringIcon(txn) {
    if (!txn) return false;
    const isRecurring = Boolean(txn.recurring?.isRecurring || txn.planType === "recurring");
    if (!isRecurring) return false;
    const status = (txn.status ?? "").toString().toLowerCase();
    return !status || status === "scheduled";
  }

  function friendlyPlanStatus(status) {
    switch (status) {
      case "active": return "Ativo";
      case "paused": return "Pausado";
      case "canceled": return "Cancelado";
      case "completed": return "Concluido";
      default: return "Ativo";
    }
  }

  function friendlyTxnStatus(status) {
    if (status === "paid") return "Pago";
    if (status === "skipped") return "Pulado";
    if (status === "scheduled") return "Agendado";
    return "";
  }

  function isCreditCardPayment(method) {
    return method === "credit_card" || method === "credito";
  }

  function friendlyPaymentMethod(method) {
    switch (method) {
      case "pix": return "Pix";
      case "credito":
      case "credit_card": return "Cartao de credito";
      case "debito": return "Cartao de debito";
      case "dinheiro": return "Dinheiro";
      case "transferencia": return "Transferencia";
      case "boleto": return "Boleto";
      case "outro": return "Outro";
      default: return "-";
    }
  }

  function getTxnInvoiceMonth(txn = {}) {
    const direct = txn.invoiceMonth || txn.statementMonth;
    if (direct) return direct;
    if (!isCreditCardPayment(txn.paymentMethod)) return "";
    const purchaseRaw = txn.purchaseDate;
    const purchaseDate = purchaseRaw instanceof Date ? purchaseRaw : purchaseRaw?.toDate?.();
    const dateRaw = txn.date;
    const dateObj = dateRaw instanceof Date ? dateRaw : dateRaw?.toDate?.();
    const baseDate = purchaseDate || dateObj;
    if (!(baseDate instanceof Date) || Number.isNaN(baseDate.getTime())) return "";
    const closingDay = txn.creditCardId ? getCardClosingDay(txn.creditCardId) : 31;
    return computeInvoiceMonth(baseDate, closingDay);
  }

  function creditCardTag(txn = {}) {
    if (!isCreditCardPayment(txn.paymentMethod)) return "";
    const month = getTxnInvoiceMonth(txn);
    if (!month) return "";
    const cardName = txn.creditCardNameSnapshot
      || (txn.creditCardId ? state.creditCards.get(txn.creditCardId)?.name : "");
    if (!cardName) return "";
    return `${cardName} | ${month}`;
  }

  const SORT_ICON_ASC = '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.034 2a1 1 0 0 1 .945.673l2.793 8.069a1 1 0 0 1-1.89.654l-.412-1.19H5.597l-.411 1.19a1 1 0 0 1-1.89-.654l2.793-8.07A1 1 0 0 1 7.034 2Zm0 4.057-.744 2.15h1.488l-.744-2.15ZM4.749 13a1 1 0 1 0 0 2H8l-4.05 5.4a1 1 0 0 0 .8 1.6H10a1 1 0 1 0 0-2H6.75l4.05-5.4A1 1 0 0 0 10 13H4.75Zm7.544 3.293a1 1 0 0 1 1.414 0l2.292 2.292V3a1 1 0 1 1 2 0v15.586l2.294-2.293a1 1 0 0 1 1.414 1.414l-4 4a1 1 0 0 1-1.414 0l-4-4a1 1 0 0 1 0-1.414Z" fill="#222F3D"/></svg>';
  const SORT_ICON_DESC = '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4.75 2a1 1 0 1 0 0 2H8L3.95 9.4a1 1 0 0 0 .8 1.6H10a1 1 0 1 0 0-2H6.75l4.05-5.4A1 1 0 0 0 10 2H4.75Zm2.284 10a1 1 0 0 1 .945.673l2.794 8.069a1 1 0 0 1-1.89.654l-.412-1.189H5.598l-.412 1.19a1 1 0 0 1-1.89-.655l2.793-8.07A1 1 0 0 1 7.034 12Zm0 4.057-.744 2.15h1.488l-.744-2.15Zm5.26.236a1 1 0 0 1 1.413 0L16 18.586V3a1 1 0 1 1 2 0v15.586l2.294-2.293a1 1 0 0 1 1.414 1.414l-4 4a1 1 0 0 1-1.415 0l-4-4a1 1 0 0 1 0-1.414Z" fill="#222F3D"/></svg>';
  const ICON_EDIT = '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.94 5 19 10.06 9.062 20a2.25 2.25 0 0 1-.999.58l-5.116 1.395a.75.75 0 0 1-.92-.921l1.395-5.116a2.25 2.25 0 0 1 .58-.999L13.938 5Zm7.09-2.03a3.578 3.578 0 0 1 0 5.06l-.97.97L15 3.94l.97-.97a3.578 3.578 0 0 1 5.06 0Z" fill="#222F3D"/></svg>';
  const ICON_DELETE = '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.5 6a1 1 0 0 1-.883.993L20.5 7h-.845l-1.231 12.52A2.75 2.75 0 0 1 15.687 22H8.313a2.75 2.75 0 0 1-2.737-2.48L4.345 7H3.5a1 1 0 0 1 0-2h5a3.5 3.5 0 1 1 7 0h5a1 1 0 0 1 1 1Zm-7.25 3.25a.75.75 0 0 0-.743.648L13.5 10v7l.007.102a.75.75 0 0 0 1.486 0L15 17v-7l-.007-.102a.75.75 0 0 0-.743-.648Zm-4.5 0a.75.75 0 0 0-.743.648L9 10v7l.007.102a.75.75 0 0 0 1.486 0L10.5 17v-7l-.007-.102a.75.75 0 0 0-.743-.648ZM12 3.5A1.5 1.5 0 0 0 10.5 5h3A1.5 1.5 0 0 0 12 3.5Z" fill="#C0382B"/></svg>';
  const ICON_RECURRING = '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16.052 5.029a1 1 0 0 0 .189 1.401 7.002 7.002 0 0 1-3.157 12.487l.709-.71a1 1 0 0 0-1.414-1.414l-2.5 2.5a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 1.414-1.414l-.843-.842A9.001 9.001 0 0 0 17.453 4.84a1 1 0 0 0-1.401.189Zm-1.93-1.736-2.5-2.5a1 1 0 0 0-1.498 1.32l.083.094.843.843a9.001 9.001 0 0 0-4.778 15.892A1 1 0 0 0 7.545 17.4a7.002 7.002 0 0 1 3.37-12.316l-.708.709a1 1 0 0 0 1.32 1.497l.094-.083 2.5-2.5a1 1 0 0 0 .083-1.32l-.083-.094Z" fill="#212121"/></svg>';

  const SORT_ACCESSORS = {
    transactions: {
      description: (r) => (r.note || ""),
      payment: (r) => friendlyPaymentMethod(r.paymentMethod || ""),
      category: (r) => (r.categoryName || ""),
      date: (r) => (r.date ? r.date.getTime() : 0),
      amount: (r) => Math.abs(Number(r.amountCents || 0))
    },
    categories: {
      name: (c) => (c.name || ""),
      kind: (c) => (c.kind || "")
    },
    plans: {
      title: (p) => (p.title || ""),
      type: (p) => friendlyPlanType(p.type || ""),
      amount: (p) => (p.type === "recurring" ? Number(p.amountEachCents || 0) : Number(p.amountTotalCents || 0)),
      start: (p) => (p.startMonth || ""),
      status: (p) => (p.status || "")
    },
    cards: {
      name: (c) => (c.name || ""),
      closing: (c) => Number(c.closingDay || 0),
      due: (c) => Number(c.dueDay || 0),
      status: (c) => (c.status || "")
    },
    statements: {
      month: (s) => (s.month || ""),
      total: (s) => Number(s.totalCents || 0),
      status: (s) => (s.status || "")
    },
    statementItems: {
      date: (i) => (i.date || ""),
      category: (i) => (i.categoryName || ""),
      description: (i) => (i.note || ""),
      amount: (i) => Math.abs(Number(i.amountCents || 0))
    }
  };

  function normalizeSortValue(value) {
    if (value == null) return "";
    if (value instanceof Date) return value.getTime();
    if (typeof value === "string") return value.toLowerCase();
    return value;
  }

  function compareSortValues(a, b) {
    const av = normalizeSortValue(a);
    const bv = normalizeSortValue(b);
    if (av === bv) return 0;
    return av > bv ? 1 : -1;
  }

  function getSortState(tableId) {
    return state.sort?.[tableId] || { key: null, dir: "asc" };
  }

  function setSortState(tableId, key) {
    const current = getSortState(tableId);
    const nextDir = current.key === key && current.dir === "asc" ? "desc" : "asc";
    if (!state.sort) state.sort = {};
    state.sort[tableId] = { key, dir: nextDir };
  }

  function sortCollection(tableId, rows = []) {
    const { key, dir } = getSortState(tableId);
    const accessor = SORT_ACCESSORS[tableId]?.[key];
    if (!accessor) return rows.slice();
    const factor = dir === "desc" ? -1 : 1;
    return rows.slice().sort((a, b) => compareSortValues(accessor(a), accessor(b)) * factor);
  }

  function updateSortIndicators(tableId) {
    const { key, dir } = getSortState(tableId);
    document.querySelectorAll(`[data-sort-table=\"${tableId}\"][data-sort-key]`).forEach((btn) => {
      const btnKey = btn.getAttribute("data-sort-key");
      const indicator = btn.querySelector(".sort-indicator");
      const isActive = btnKey === key;
      btn.classList.toggle("active", isActive);
      if (indicator) indicator.innerHTML = isActive ? (dir === "asc" ? SORT_ICON_ASC : SORT_ICON_DESC) : "";
    });
  }

  function refreshTableForSort(tableId) {
    switch (tableId) {
      case "transactions":
        renderTxnRows(state.currentRows, { allowDelete: !isCoupleWallet(), isCoupleView: isCoupleWallet() && state.coupleTab === "details", allowEdit: !isCoupleWallet() });
        break;
      case "categories":
        renderCategoriesTable();
        break;
      case "plans":
        renderPlansTable();
        break;
      case "cards":
        renderCardTable();
        break;
      case "statements":
        renderStatementsTable(state.statementEntries || [], { preserveSelection: true });
        break;
      case "statementItems":
        if (state.statementItemsCache?.length && state.statementItemsMonth) {
          renderStatementItems(state.statementItemsCache, state.statementItemsMonth);
        } else if (state.activeStatementMonth && statementCard?.value) {
          loadStatementItems(statementCard.value, state.activeStatementMonth);
        }
        break;
      default:
        break;
    }
  }

  function initSortControls() {
    document.querySelectorAll("[data-sort-table][data-sort-key]").forEach((btn) => {
      btn.addEventListener("click", () => {
        const tableId = btn.getAttribute("data-sort-table");
        const key = btn.getAttribute("data-sort-key");
        if (!tableId || !key) return;
        setSortState(tableId, key);
        updateSortIndicators(tableId);
        refreshTableForSort(tableId);
      });
    });
    Object.keys(state.sort || {}).forEach((tableId) => updateSortIndicators(tableId));
  }

  function statementSignedAmount(amountCents, type) {
    const amt = Number(amountCents || 0);
    return (type === "income") ? -amt : amt;
  }

  function getCreditCardCollectionName() {
    return state.creditCardsCollectionName || "creditCards";
  }

  function getCreditCardCollectionRef(walletId = state.walletId) {
    return collection(db, "wallets", walletId, getCreditCardCollectionName());
  }

  function getCreditCardDocRef(walletId, cardId) {
    return doc(db, "wallets", walletId, getCreditCardCollectionName(), cardId);
  }

  function getCreditCardStatementsRef(walletId, cardId) {
    return collection(db, "wallets", walletId, getCreditCardCollectionName(), cardId, "statements");
  }

  function getStatementKey(txn = {}) {
    if (!isCreditCardPayment(txn.paymentMethod)) return null;
    const month = txn.invoiceMonth || txn.statementMonth;
    if (!txn.creditCardId || !month) return null;
    return { cardId: txn.creditCardId, month };
  }

  function getStatementRef(walletId, cardId, month) {
    return doc(db, "wallets", walletId, getCreditCardCollectionName(), cardId, "statements", month);
  }

  function getCardClosingDay(cardId) {
    const card = state.creditCards.get(cardId);
    return normalizeClosingDay(card?.closingDay, 31);
  }

  function setStatementStatus(msg = "") {
    if (!statementStatus) return;
    statementStatus.textContent = msg || "";
    statementStatus.style.display = msg ? "" : "none";
  }

  const STATEMENT_MONTH_LABELS = ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"];

  function formatStatementMonth(yyyyMM) {
    if (!yyyyMMFromMonthInput(yyyyMM)) return "-";
    const [year, month] = yyyyMM.split("-");
    const idx = Number(month) - 1;
    const label = STATEMENT_MONTH_LABELS[idx] || month;
    return `${label} ${year}`;
  }

  function statementStatusLabel(status) {
    if (status === "paid") return "Paga";
    if (status === "computed") return "Calculada";
    if (status === "open") return "Aberta";
    return status ? String(status) : "-";
  }

  function cacheStatementEntries(entries = []) {
    state.statementEntries = entries;
    state.statementEntriesByMonth = new Map();
    for (const entry of entries) {
      if (!entry?.month) continue;
      state.statementEntriesByMonth.set(entry.month, entry);
    }
  }

  function getStatementEntry(month) {
    if (!month) return null;
    return state.statementEntriesByMonth?.get(month) || null;
  }

  function updateStatementSummary({ month, totalCents, status, itemsCount } = {}) {
    if (statementSummaryMonth) statementSummaryMonth.textContent = formatStatementMonth(month);
    if (statementSummaryTotal) statementSummaryTotal.textContent = totalCents == null ? "-" : toBRL(totalCents);
    if (statementSummaryStatus) statementSummaryStatus.textContent = statementStatusLabel(status);
    if (statementSummaryCount) statementSummaryCount.textContent = Number.isFinite(itemsCount) ? String(itemsCount) : "-";
  }

  function resetStatementSummary() {
    updateStatementSummary({ month: null, totalCents: null, status: null, itemsCount: null });
  }

  function highlightStatementRow(month) {
    if (!statementTable) return;
    statementTable.querySelectorAll("tr.statement-row").forEach((row) => {
      const rowMonth = row.getAttribute("data-statement-row");
      row.classList.toggle("is-active", rowMonth === month);
    });
  }

  // ===== Credit Cards =====

  async function fetchCreditCardSnapshots(walletId) {
    const preferred = state.creditCardsCollectionName || "creditCards";
    const fallback = preferred === "creditCards" ? "credit_cards" : "creditCards";
    let preferredSnaps = null;
    let preferredError = null;

    try {
      preferredSnaps = await getDocs(collection(db, "wallets", walletId, preferred));
    } catch (e) {
      preferredError = e;
    }

    if (preferredSnaps && !preferredSnaps.empty) {
      state.creditCardsCollectionName = preferred;
      return preferredSnaps;
    }

    let fallbackSnaps = null;
    let fallbackError = null;
    try {
      fallbackSnaps = await getDocs(collection(db, "wallets", walletId, fallback));
    } catch (e) {
      fallbackError = e;
    }

    if (fallbackSnaps && !fallbackSnaps.empty) {
      state.creditCardsCollectionName = fallback;
      return fallbackSnaps;
    }

    if (preferredSnaps) {
      state.creditCardsCollectionName = preferred;
      return preferredSnaps;
    }
    if (fallbackSnaps) {
      state.creditCardsCollectionName = fallback;
      return fallbackSnaps;
    }

    throw preferredError || fallbackError || new Error("Nao foi possivel carregar cartoes.");
  }

  async function loadCreditCards() {
    state.creditCards.clear();
    if (txnCard) txnCard.innerHTML = "";
    if (planCreditCard) planCreditCard.innerHTML = "";
    if (statementCard) statementCard.innerHTML = "";

    if (isCoupleWallet()) {
      setCreditCardOptions(txnCard, "", "Nao disponivel");
      setCreditCardOptions(planCreditCard, "", "Nao disponivel");
      setCreditCardOptions(statementCard, "", "Nao disponivel");
      if (cardTable) cardTable.innerHTML = "";
      if (cardStatus) cardStatus.textContent = "Cartoes nao disponiveis nesta carteira.";
      return;
    }

    try {
      const snaps = await fetchCreditCardSnapshots(state.walletId);
      for (const d of snaps.docs) {
        const data = d.data();
        state.creditCards.set(d.id, {
          name: data.name ?? "Cartao",
          closingDay: Number(data.closingDay || 0),
          dueDay: Number(data.dueDay || 0),
          status: data.status ?? "active"
        });
      }
      setCreditCardOptions(txnCard, txnCard?.value || "");
      setCreditCardOptions(planCreditCard, planCreditCard?.value || "");
      setCreditCardOptions(statementCard, statementCard?.value || "");
      renderCardTable();
      if (cardStatus) cardStatus.textContent = state.creditCards.size ? "" : "Nenhum cartao cadastrado.";
      syncCreditTxnFields();
      syncPlanFields();
      if (statementCard) await loadStatements();
    } catch (e) {
      if (cardStatus) cardStatus.textContent = "Nao foi possivel carregar cartoes.";
    }
  }

  function renderCardTable() {
    if (!cardTable) return;
    cardTable.innerHTML = "";
    updateSortIndicators("cards");
    const entries = Array.from(state.creditCards.entries())
      .map(([id, c]) => ({ id, ...c }));
    const sorted = sortCollection("cards", entries);

    for (const c of sorted) {
      const statusLabel = c.status === "active" ? "Ativo" : "Inativo";
      const actionLabel = c.status === "active" ? "Desativar" : "Ativar";
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(c.name)}</td>
        <td class="right">${c.closingDay || "-"}</td>
        <td class="right">${c.dueDay || "-"}</td>
        <td><span class="badge">${statusLabel}</span></td>
        <td class="right actions">
          <button class="ghost" data-edit-card="${c.id}" aria-label="Editar" title="Editar">${ICON_EDIT}</button>
          <button class="ghost" data-toggle-card="${c.id}">${actionLabel}</button>
          <button class="ghost" data-del-card="${c.id}" aria-label="Excluir" title="Excluir">${ICON_DELETE}</button>
        </td>
      `;
      cardTable.appendChild(tr);
    }

    cardTable.querySelectorAll("button[data-toggle-card]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-toggle-card");
        await toggleCardStatus(id);
      });
    });
    cardTable.querySelectorAll("button[data-edit-card]").forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-edit-card");
        openEditCardModal(id);
      });
    });
    cardTable.querySelectorAll("button[data-del-card]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-del-card");
        await deleteCreditCard(id);
      });
    });
  }

  function openEditCardModal(cardId) {
    if (!editCardModal) return;
    const card = state.creditCards.get(cardId);
    if (!card) return;
    state.editingCardId = cardId;
    if (editCardName) editCardName.value = card.name || "";
    if (editCardClosingDay) editCardClosingDay.value = card.closingDay || "";
    if (editCardDueDay) editCardDueDay.value = card.dueDay || "";
    if (editCardStatus) editCardStatus.textContent = "";
    if (editCardError) editCardError.textContent = "";
    editCardModal.hidden = false;
  }

  function closeEditCardModal() {
    if (!editCardModal) return;
    editCardModal.hidden = true;
    state.editingCardId = null;
  }

  async function updateFutureCreditCardTransactions(cardId, closingDay, cardNameSnapshot = "") {
    if (!cardId || !isPersonalWalletId(state.walletId)) return { scanned: 0, updated: 0 };
    const start = currentDateInTZ();
    start.setHours(0, 0, 0, 0);
    const startTS = Timestamp.fromDate(start);
    const baseQuery = (method) => query(
      collection(db, "wallets", state.walletId, "transactions"),
      where("creditCardId", "==", cardId),
      where("paymentMethod", "==", method),
      where("purchaseDate", ">=", startTS)
    );

    const methods = ["credit_card", "credito"];
    const txnMap = new Map();
    for (const method of methods) {
      try {
        const snaps = await getDocs(baseQuery(method));
        snaps.docs.forEach((snap) => txnMap.set(snap.id, snap));
      } catch (e) {
        console.error("fetch future card txns failed", e);
      }
    }

    let scanned = 0;
    let updated = 0;
    for (const snap of txnMap.values()) {
      scanned += 1;
      const data = normalizeTxn(snap.data());
      const purchaseDate = data.purchaseDate?.toDate?.() ?? null;
      if (!(purchaseDate instanceof Date) || Number.isNaN(purchaseDate.getTime())) continue;
      const newInvoiceMonth = computeInvoiceMonth(purchaseDate, closingDay);
      const oldInvoiceMonth = data.invoiceMonth || data.statementMonth || "";
      if (!newInvoiceMonth || newInvoiceMonth === oldInvoiceMonth) continue;
      const alignedDate = alignDateToMonthKey(purchaseDate, newInvoiceMonth);
      const updates = {
        date: Timestamp.fromDate(alignedDate),
        monthKey: newInvoiceMonth,
        invoiceMonth: newInvoiceMonth,
        statementMonth: newInvoiceMonth,
        creditCardNameSnapshot: cardNameSnapshot || data.creditCardNameSnapshot || null
      };
      await updateTxnWithDerivations(snap.id, updates, { walletId: state.walletId });
      updated += 1;
    }
    return { scanned, updated };
  }

  async function saveCardEdits() {
    if (!editCardModal || !editCardName || !editCardClosingDay || !editCardDueDay || !btnSaveCardEdit) return;
    if (editCardError) editCardError.textContent = "";
    if (editCardStatus) editCardStatus.textContent = "";

    const cardId = state.editingCardId;
    if (!cardId) { if (editCardError) editCardError.textContent = "Nenhum cartao selecionado."; return; }

    const name = (editCardName.value ?? "").trim();
    const closingDay = parsePositiveInt(editCardClosingDay.value);
    const dueDay = parsePositiveInt(editCardDueDay.value);

    if (!name) { if (editCardError) editCardError.textContent = "Informe o nome do cartao."; return; }
    if (!closingDay || closingDay < 1 || closingDay > 31) { if (editCardError) editCardError.textContent = "Fechamento invalido."; return; }
    if (!dueDay || dueDay < 1 || dueDay > 31) { if (editCardError) editCardError.textContent = "Vencimento invalido."; return; }

    btnSaveCardEdit.disabled = true;
    btnSaveCardEdit.textContent = "Salvando...";

    try {
      await setDoc(getCreditCardDocRef(state.walletId, cardId), {
        name,
        closingDay,
        dueDay,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });

      if (editCardStatus) editCardStatus.textContent = "Atualizando faturas futuras...";
      const result = await updateFutureCreditCardTransactions(cardId, closingDay, name);
      const suffix = result.updated ? `Faturas ajustadas: ${result.updated}.` : "Nenhuma fatura futura ajustada.";
      if (editCardStatus) editCardStatus.textContent = `Cartao atualizado. ${suffix}`;

      await loadCreditCards();
    } catch (e) {
      console.error("saveCardEdits failed", e);
      if (editCardError) editCardError.textContent = "Nao foi possivel atualizar o cartao.";
    } finally {
      btnSaveCardEdit.disabled = false;
      btnSaveCardEdit.textContent = "Salvar alteracoes";
    }
  }

  async function addCreditCard() {
    if (!cardName || !cardClosingDay || !cardDueDay || !cardStatus) return;
    cardStatus.textContent = "";
    if (!isPersonalWalletId(state.walletId)) {
      cardStatus.textContent = "Selecione uma carteira pessoal.";
      return;
    }

    const name = (cardName.value ?? "").trim();
    const closingDay = parsePositiveInt(cardClosingDay.value);
    const dueDay = parsePositiveInt(cardDueDay.value);

    if (!name) { cardStatus.textContent = "Informe o nome do cartao."; return; }
    if (!closingDay || closingDay < 1 || closingDay > 31) { cardStatus.textContent = "Fechamento invalido."; return; }
    if (!dueDay || dueDay < 1 || dueDay > 31) { cardStatus.textContent = "Vencimento invalido."; return; }

    try {
      await addDoc(getCreditCardCollectionRef(state.walletId), {
        name,
        closingDay,
        dueDay,
        status: "active",
        createdAt: serverTimestamp(),
        createdBy: state.uid,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      });
      cardName.value = "";
      cardClosingDay.value = "";
      cardDueDay.value = "";
      await loadCreditCards();
    } catch (e) {
      console.error("addCreditCard failed", e);
      cardStatus.textContent = "Nao foi possivel salvar o cartao. Verifique sua permissao.";
    }
  }

  async function toggleCardStatus(cardId) {
    if (!cardId) return;
    const current = state.creditCards.get(cardId);
    const nextStatus = current?.status === "active" ? "inactive" : "active";
    try {
      await setDoc(getCreditCardDocRef(state.walletId, cardId), {
        status: nextStatus,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
      await loadCreditCards();
    } catch {
      if (cardStatus) cardStatus.textContent = "Nao foi possivel atualizar o cartao.";
    }
  }

  async function deleteCreditCard(cardId) {
    if (!cardId) return;
    if (!isPersonalWalletId(state.walletId)) {
      if (cardStatus) cardStatus.textContent = "Selecione uma carteira pessoal.";
      return;
    }

    let hasTxns = false;
    try {
      const qRef = query(
        collection(db, "wallets", state.walletId, "transactions"),
        where("creditCardId", "==", cardId)
      );
      const snaps = await getDocs(qRef);
      hasTxns = !snaps.empty;
    } catch {}

    const msg = hasTxns
      ? "Este cartao tem transacoes. Excluir nao remove essas transacoes. Deseja continuar?"
      : "Excluir este cartao?";
    if (!confirm(msg)) return;

    if (cardStatus) cardStatus.textContent = "Excluindo cartao...";

    try {
      const stmtCol = getCreditCardStatementsRef(state.walletId, cardId);
      const stmtSnaps = await getDocs(stmtCol);
      for (const d of stmtSnaps.docs) {
        await deleteDoc(d.ref);
      }
      await deleteDoc(getCreditCardDocRef(state.walletId, cardId));
      await loadCreditCards();
      if (cardStatus) cardStatus.textContent = "Cartao excluido.";
    } catch (e) {
      console.error("deleteCreditCard failed", e);
      if (cardStatus) cardStatus.textContent = "Nao foi possivel excluir o cartao.";
    }
  }

  async function computeStatementTotalsFromTransactions(cardId) {
    if (!cardId) return [];
    try {
      const qRef = query(
        collection(db, "wallets", state.walletId, "transactions"),
        where("creditCardId", "==", cardId)
      );
      const snaps = await getDocs(qRef);
      const byMonth = new Map();

      for (const d of snaps.docs) {
        const t = normalizeTxn(d.data());
        let month = getTxnInvoiceMonth(t);
        if (!month) continue;
        const delta = statementSignedAmount(t.amountCents, t.type);
        const current = byMonth.get(month) || 0;
        byMonth.set(month, current + delta);
      }

      return Array.from(byMonth.entries())
        .map(([month, totalCents]) => ({ month, totalCents, status: "computed", computed: true }))
        .sort((a, b) => compareYYYYMM(a.month, b.month));
    } catch (e) {
      return [];
    }
  }

  async function createStatementSummary(cardId, month, totalCents) {
    if (!cardId || !month) return;
    try {
      await setDoc(getStatementRef(state.walletId, cardId, month), {
        month,
        totalCents: Number(totalCents || 0),
        status: "open",
        paidAt: null,
        createdAt: serverTimestamp(),
        createdBy: state.uid,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
      await loadStatements();
    } catch {
      setStatementStatus("Nao foi possivel criar o resumo da fatura.");
    }
  }

  function renderStatementsTable(entries, { preserveSelection = false, cardId = null } = {}) {
    if (!statementTable) return;
    statementTable.innerHTML = "";
    updateSortIndicators("statements");
    const sorted = sortCollection("statements", entries);

    for (const s of sorted) {
      const statusLabel = statementStatusLabel(s.computed ? "computed" : s.status);
      const tr = document.createElement("tr");
      tr.classList.add("statement-row");
      tr.setAttribute("data-statement-row", s.month);
      tr.innerHTML = `
        <td>${escapeHtml(formatStatementMonth(s.month))}</td>
        <td class="right">${toBRL(s.totalCents)}</td>
        <td><span class="badge">${statusLabel}</span></td>
        <td class="right actions">
          <button class="ghost" data-view-statement="${s.month}">Ver itens</button>
          ${s.status !== "paid" ? `<button class="ghost" data-pay-statement="${s.month}" data-total="${s.totalCents}">Marcar paga</button>` : ""}
          ${s.status === "paid" ? `<button class="ghost" data-reopen-statement="${s.month}">Reabrir</button>` : ""}
          ${s.computed ? `<button class="ghost" data-create-statement="${s.month}" data-total="${s.totalCents}">Criar resumo</button>` : ""}
        </td>
      `;
      statementTable.appendChild(tr);
    }

    statementTable.querySelectorAll("button[data-view-statement]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const month = btn.getAttribute("data-view-statement");
        await loadStatementItems(cardId || statementCard?.value, month);
      });
    });

    statementTable.querySelectorAll("button[data-pay-statement]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const month = btn.getAttribute("data-pay-statement");
        const total = Number(btn.getAttribute("data-total") || 0);
        await markStatementPaid(cardId || statementCard?.value, month, total);
      });
    });

    statementTable.querySelectorAll("button[data-reopen-statement]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const month = btn.getAttribute("data-reopen-statement");
        await reopenStatement(cardId || statementCard?.value, month);
      });
    });

    statementTable.querySelectorAll("button[data-create-statement]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const month = btn.getAttribute("data-create-statement");
        const total = Number(btn.getAttribute("data-total") || 0);
        await createStatementSummary(cardId || statementCard?.value, month, total);
      });
    });

    if (sorted.length) {
      const targetMonth = preserveSelection && state.activeStatementMonth
        ? state.activeStatementMonth
        : sorted[0].month;
      if (targetMonth) loadStatementItems(cardId || statementCard?.value, targetMonth);
    }
  }

  function renderStatementItems(items, month) {
    if (!statementItemsTable) return;
    statementItemsTable.innerHTML = "";
    updateSortIndicators("statementItems");
    const sorted = sortCollection("statementItems", items);

    if (!sorted.length) {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="4" class="muted">Sem itens nesta fatura.</td>`;
      statementItemsTable.appendChild(tr);
      return;
    }

    for (const item of sorted) {
      const label = occurrenceCounterLabel(item);
      const showRecurringIcon = shouldShowRecurringIcon(item);
      const descBase = (item.note || "").trim();
      const descText = descBase || (label || showRecurringIcon ? "(sem descricao)" : "");
      const labelHtml = label ? ` <span class="installment-badge">${escapeHtml(label)}</span>` : "";
      const recurringHtml = showRecurringIcon ? `<span class="recurring-icon" aria-label="Recorrente">${ICON_RECURRING}</span>` : "";
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(item.date || "-")}</td>
        <td>${escapeHtml(item.categoryName || "-")}</td>
        <td>${escapeHtml(descText)}${labelHtml}${recurringHtml}</td>
        <td class="right">${toBRL(Math.abs(item.amountCents))}</td>
      `;
      statementItemsTable.appendChild(tr);
    }
  }

  async function loadStatements() {
    if (!statementTable || !statementItemsTable) return;
    statementTable.innerHTML = "";
    statementItemsTable.innerHTML = "";
    cacheStatementEntries([]);
    state.activeStatementMonth = null;
    state.statementItemsCache = [];
    state.statementItemsMonth = null;
    resetStatementSummary();
    setStatementStatus("");
    updateSortIndicators("statements");
    updateSortIndicators("statementItems");
    if (statementItemsMonth) statementItemsMonth.textContent = "Selecionado";

    const cardId = statementCard?.value;
    if (!cardId) {
      setStatementStatus("Selecione um cartao para ver as faturas.");
      if (statementMeta) statementMeta.textContent = "";
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="4" class="muted">Selecione um cartao para ver faturas.</td>`;
      statementTable.appendChild(tr);
      const itemsTr = document.createElement("tr");
      itemsTr.innerHTML = `<td colspan="4" class="muted">Selecione um cartao para ver itens.</td>`;
      statementItemsTable.appendChild(itemsTr);
      return;
    }

    const card = state.creditCards.get(cardId);
    if (statementMeta) {
      const name = card?.name || "Cartao";
      const closing = card?.closingDay ? `Fechamento: ${card.closingDay}` : "";
      const due = card?.dueDay ? `Vencimento: ${card.dueDay}` : "";
      const parts = [name, closing, due].filter(Boolean);
      statementMeta.textContent = parts.join(" | ");
    }

    let entries = [];
    let usedFallback = false;

    try {
      const colRef = getCreditCardStatementsRef(state.walletId, cardId);
      const snaps = await getDocs(colRef);
      entries = snaps.docs.map(d => {
        const data = d.data();
        return {
          id: d.id,
          month: data.month ?? d.id,
          totalCents: Number(data.totalCents || 0),
          status: data.status ?? "open",
          paidAt: data.paidAt ?? null,
          computed: false
        };
      }).sort((a, b) => compareYYYYMM(a.month, b.month));
    } catch {
      entries = await computeStatementTotalsFromTransactions(cardId);
      usedFallback = true;
    }

    if (!entries.length) {
      entries = await computeStatementTotalsFromTransactions(cardId);
      usedFallback = true;
    }

    if (!entries.length) {
      setStatementStatus("Sem faturas para este cartao.");
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="4" class="muted">Sem faturas registradas.</td>`;
      statementTable.appendChild(tr);
      const itemsTr = document.createElement("tr");
      itemsTr.innerHTML = `<td colspan="4" class="muted">Nenhuma fatura selecionada.</td>`;
      statementItemsTable.appendChild(itemsTr);
      return;
    }

    setStatementStatus(usedFallback ? "Resumo calculado a partir das transacoes." : "");
    cacheStatementEntries(entries);

    renderStatementsTable(entries, { preserveSelection: false, cardId });
  }

  async function fetchStatementTransactions(cardId, month) {
    if (!cardId || !month) return { items: [], computedTotal: 0 };
    const qRef = query(
      collection(db, "wallets", state.walletId, "transactions"),
      where("creditCardId", "==", cardId)
    );
    const snaps = await getDocs(qRef);
    const items = [];
    let computedTotal = 0;

    for (const d of snaps.docs) {
      const t = normalizeTxn(d.data());
      let statementMonth = getTxnInvoiceMonth(t);
      if (statementMonth !== month) continue;
      const displayDate = t.purchaseDate?.toDate?.() ?? t.date?.toDate?.();
      const dt = displayDate ? toISODateLocal(displayDate) : "-";
      const amountCents = Number(t.amountCents || 0);
      computedTotal += statementSignedAmount(amountCents, t.type ?? "expense");
      items.push({
        id: d.id,
        status: t.status ?? "",
        planId: t.planId ?? "",
        planType: t.planType ?? "",
        recurring: t.recurring ?? { isRecurring: false, cadence: "none" },
        installment: t.installment ?? { isInstallment: false, total: null, current: null },
        finance: t.finance ?? { isFinance: false, total: null, current: null },
        occurrenceIndex: t.occurrenceIndex ?? null,
        occurrenceTotal: t.occurrenceTotal ?? null,
        date: dt,
        categoryName: t.categoryName || "-",
        note: t.note || "",
        amountCents
      });
    }

    return { items, computedTotal };
  }

  async function updateStatementItemsStatus(cardId, month, shouldPay) {
    if (!isPersonalWalletId(state.walletId)) return;
    const { items } = await fetchStatementTransactions(cardId, month);
    if (!items.length) return;

    for (const item of items) {
      if (shouldPay) {
        if (item.status === "paid") continue;
        if (item.planId) {
          await markOccurrencePaid(item.id);
        } else {
          await updateTxnWithDerivations(item.id, {
            status: "paid",
            paidAt: serverTimestamp()
          }, { walletId: state.walletId });
        }
      } else {
        if (item.status !== "paid") continue;
        if (item.planId) {
          await markOccurrenceUnpaid(item.id);
        } else {
          await updateTxnWithDerivations(item.id, {
            status: null,
            paidAt: null
          }, { walletId: state.walletId });
        }
      }
    }
  }

  async function loadStatementItems(cardId, month) {
    if (!statementItemsTable) return;
    statementItemsTable.innerHTML = "";
    if (statementItemsMonth) statementItemsMonth.textContent = month ? formatStatementMonth(month) : "Selecionado";
    if (!cardId || !month) {
      resetStatementSummary();
      highlightStatementRow(null);
      state.statementItemsCache = [];
      state.statementItemsMonth = null;
      return;
    }

    state.activeStatementMonth = month;
    state.statementItemsMonth = month;

    try {
      const result = await fetchStatementTransactions(cardId, month);
      const items = result.items;
      const computedTotal = result.computedTotal;

      const entry = getStatementEntry(month);
      const summaryTotal = entry ? entry.totalCents : (items.length ? computedTotal : null);
      const summaryStatus = entry ? (entry.computed ? "computed" : entry.status) : (items.length ? "computed" : null);
      updateStatementSummary({ month, totalCents: summaryTotal, status: summaryStatus, itemsCount: items.length });
      highlightStatementRow(month);

      state.statementItemsCache = items;
      renderStatementItems(items, month);
    } catch {
      const entry = getStatementEntry(month);
      if (entry) {
        const summaryStatus = entry.computed ? "computed" : entry.status;
        updateStatementSummary({ month, totalCents: entry.totalCents, status: summaryStatus, itemsCount: 0 });
      } else {
        resetStatementSummary();
      }
      highlightStatementRow(month);
      state.statementItemsCache = [];
      state.statementItemsMonth = month;
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="4" class="muted">Nao foi possivel carregar os itens.</td>`;
      statementItemsTable.appendChild(tr);
    }
  }

  async function markStatementPaid(cardId, month, totalCents = null) {
    if (!cardId || !month) return;
    try {
      setStatementStatus("Atualizando itens da fatura...");
      await updateStatementItemsStatus(cardId, month, true);
      const patch = {
        status: "paid",
        paidAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      };
      if (totalCents != null) patch.totalCents = Number(totalCents || 0);
      await setDoc(getStatementRef(state.walletId, cardId, month), patch, { merge: true });
      await loadStatements();
    } catch {
      setStatementStatus("Nao foi possivel atualizar a fatura.");
    }
  }

  async function reopenStatement(cardId, month) {
    if (!cardId || !month) return;
    try {
      setStatementStatus("Reabrindo fatura...");
      await updateStatementItemsStatus(cardId, month, false);
      await setDoc(getStatementRef(state.walletId, cardId, month), {
        status: "open",
        paidAt: null,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
      await loadStatements();
    } catch {
      setStatementStatus("Nao foi possivel reabrir a fatura.");
    }
  }

  // ===== Plans =====

  async function loadPlans() {
    state.plans.clear();
    if (planTable) planTable.innerHTML = "";

    if (isCoupleWallet()) {
      if (planStatus) planStatus.textContent = "Planos disponiveis apenas em carteiras pessoais.";
      return;
    }

    try {
      const colRef = collection(db, "wallets", state.walletId, "plans");
      const snaps = await getDocs(colRef);
      for (const d of snaps.docs) {
        state.plans.set(d.id, d.data());
      }
      renderPlansTable();
      if (planStatus) planStatus.textContent = state.plans.size ? "" : "Nenhum plano cadastrado.";
    } catch {
      if (planStatus) planStatus.textContent = "Nao foi possivel carregar os planos.";
    }
  }

  function renderPlansTable() {
    if (!planTable) return;
    planTable.innerHTML = "";
    updateSortIndicators("plans");
    const entries = Array.from(state.plans.entries())
      .map(([id, p]) => ({ id, ...p }));
    const sorted = sortCollection("plans", entries);

    for (const p of sorted) {
      const typeLabel = friendlyPlanType(p.type);
      const statusKey = p.status || "active";
      const statusLabel = friendlyPlanStatus(statusKey);
      const amountLabel = p.type === "recurring"
        ? toBRL(p.amountEachCents || 0)
        : `${toBRL(p.amountTotalCents || 0)} / ${p.monthsTotal || "-"}`;
      const generated = p.generatedThrough ? `Gerado ate ${p.generatedThrough}` : "Sem geracao";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(p.title || "Plano")}${generated ? `<div class="muted" style="margin-top:4px;">${escapeHtml(generated)}</div>` : ""}</td>
        <td>${escapeHtml(typeLabel)}</td>
        <td class="right nowrap">${escapeHtml(amountLabel)}</td>
        <td class="right nowrap">${escapeHtml(p.startMonth || "-")}</td>
        <td><span class="badge">${escapeHtml(statusLabel)}</span></td>
        <td class="right actions">
          <button class="ghost" data-plan-generate="${p.id}">${p.type === "recurring" ? "Gerar +12" : "Gerar"}</button>
          ${statusKey === "paused" ? `<button class="ghost" data-plan-resume="${p.id}">Retomar</button>` : ""}
          ${statusKey === "active" ? `<button class="ghost" data-plan-pause="${p.id}">Pausar</button>` : ""}
          ${statusKey !== "canceled" ? `<button class="ghost" data-plan-cancel="${p.id}">Cancelar</button>` : ""}
          <button class="ghost" data-plan-delete="${p.id}" aria-label="Excluir" title="Excluir">${ICON_DELETE}</button>
        </td>
      `;
      planTable.appendChild(tr);
    }

    planTable.querySelectorAll("button[data-plan-generate]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-plan-generate");
        await generatePlanById(id);
      });
    });
    planTable.querySelectorAll("button[data-plan-resume]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-plan-resume");
        await updatePlanStatus(id, "active");
      });
    });
    planTable.querySelectorAll("button[data-plan-pause]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-plan-pause");
        await updatePlanStatus(id, "paused");
      });
    });
    planTable.querySelectorAll("button[data-plan-cancel]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-plan-cancel");
        if (!confirm("Cancelar este plano?")) return;
        await updatePlanStatus(id, "canceled");
      });
    });
    planTable.querySelectorAll("button[data-plan-delete]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-plan-delete");
        await confirmDeletePlan(id);
      });
    });
  }

  async function updatePlanStatus(planId, status) {
    if (!planId) return;
    try {
      await setDoc(doc(db, "wallets", state.walletId, "plans", planId), {
        status,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
      await loadPlans();
    } catch {
      if (planStatus) planStatus.textContent = "Nao foi possivel atualizar o plano.";
    }
  }

  async function deletePlanOnly(planId, statusEl = null) {
    if (!planId) return;
    const statusNode = statusEl || planStatus || txnStatus;
    if (statusNode) statusNode.textContent = "Excluindo plano...";
    try {
      await deleteDoc(doc(db, "wallets", state.walletId, "plans", planId));
      await loadPlans();
      if (statusNode) statusNode.textContent = "Plano excluido.";
    } catch (e) {
      console.error("deletePlanOnly failed", e);
      if (statusNode) statusNode.textContent = "Nao foi possivel excluir o plano.";
    }
  }

  async function deletePlanAndOccurrences(planId, { deletePlanDoc = true, statusEl = null } = {}) {
    if (!planId) return;
    if (!isPersonalWalletId(state.walletId)) return;
    const statusNode = statusEl || planStatus || txnStatus;
    if (statusNode) statusNode.textContent = "Excluindo parcelas...";

    try {
      const qRef = query(
        collection(db, "wallets", state.walletId, "transactions"),
        where("planId", "==", planId)
      );
      const snaps = await getDocs(qRef);
      for (const d of snaps.docs) {
        await deleteTxnWithDerivations(d.id, { walletId: state.walletId });
      }
      if (deletePlanDoc) {
        await deleteDoc(doc(db, "wallets", state.walletId, "plans", planId));
      }
      await loadPlans();
      await reloadAll();
      if (statusNode) statusNode.textContent = deletePlanDoc ? "Plano excluido." : "Parcelas excluidas.";
    } catch (e) {
      console.error("deletePlanAndOccurrences failed", e);
      if (statusNode) statusNode.textContent = "Nao foi possivel excluir o plano.";
    }
  }

  async function confirmDeletePlan(planId) {
    if (!planId) return;
    const onlyPlan = confirm("Excluir este plano? As parcelas ja geradas permanecem.\nOK = apenas o plano\nCancelar = outras opcoes");
    if (onlyPlan) {
      await deletePlanOnly(planId);
      return;
    }
    const removeAll = confirm("Excluir o plano e todas as parcelas geradas? Esta acao nao pode ser desfeita.");
    if (!removeAll) return;
    await deletePlanAndOccurrences(planId, { deletePlanDoc: true });
  }

  async function getPlan(planId) {
    const ref = doc(db, "wallets", state.walletId, "plans", planId);
    const snap = await getDoc(ref);
    if (!snap.exists()) return null;
    return { id: planId, ...snap.data() };
  }

  function buildPlanNote(plan, index, total) {
    const base = plan.title || plan.categoryName || "Plano";
    if (total && index) return `${base} (${index}/${total})`;
    return base;
  }

  function buildPlanV2Fields(plan, index, total) {
    const baseType = plan.txnType || "expense";
    const v2 = buildTxnV2Defaults(baseType, baseType);

    if (plan.type === "recurring") {
      v2.recurring = { isRecurring: true, cadence: "monthly" };
    } else if (plan.type === "installment" || plan.type === "credit_installment") {
      v2.installment = { isInstallment: true, total, current: index };
    } else if (plan.type === "finance") {
      v2.finance = { isFinance: true, total, current: index };
    }

    v2.paymentMethod = plan.paymentMethod || v2.paymentMethod;
    return v2;
  }

  async function createPlanFromTxnForm({
    planMode,
    dateStr,
    type,
    catId,
    categoryName,
    amountCents,
    note,
    paymentMethod
  }) {
    if (!planMode) return;
    if (txnStatus) txnStatus.textContent = "";
    if (!isPersonalWalletId(state.walletId)) {
      setOpsError("Planos so podem ser criados em carteiras pessoais.");
      return;
    }

    const title = note || categoryName || "Plano";
    let startMonth = yyyyMMFromDateStr(dateStr);
    if (!startMonth) {
      setOpsError("Informe um mes valido.");
      return;
    }

    let monthsTotal = null;
    let amountTotalCents = amountCents;
    let amountEachCents = amountCents;

    if (planMode === "installment" || planMode === "credit_installment") {
      monthsTotal = parsePositiveInt(installmentTotal?.value);
      if (!monthsTotal) {
        setOpsError("Informe o numero de parcelas.");
        return;
      }
      amountEachCents = Math.floor(amountTotalCents / monthsTotal);
    } else if (planMode === "finance") {
      monthsTotal = parsePositiveInt(financeTotal?.value);
      if (!monthsTotal) {
        setOpsError("Informe o numero de parcelas.");
        return;
      }
      amountEachCents = amountTotalCents;
    }

    if (planMode === "finance" && isCreditCardPayment(paymentMethod)) {
      setOpsError("Financiamento nao usa cartao de credito.");
      return;
    }

    let creditCardId = null;
    let purchaseDate = null;
    let statementStartMonth = null;

    if (planMode === "credit_installment" || (planMode === "recurring" && isCreditCardPayment(paymentMethod))) {
      creditCardId = txnCard?.value || "";
      if (!creditCardId) {
        setOpsError("Selecione um cartao.");
        return;
      }
      const purchaseDateStr = dateStr;
      const purchaseDateObj = new Date(purchaseDateStr + "T00:00:00");
      purchaseDate = Timestamp.fromDate(purchaseDateObj);
      statementStartMonth = computeInvoiceMonth(purchaseDateObj, getCardClosingDay(creditCardId));
      if (planMode === "credit_installment" && statementStartMonth) {
        startMonth = statementStartMonth;
      }
    }

    btnAddTxn.disabled = true;
    btnAddTxn.textContent = "Gerando...";

    try {
      const planRef = doc(collection(db, "wallets", state.walletId, "plans"));
      const planPayment = planMode === "credit_installment" ? "credit_card" : (paymentMethod || "outro");
      const payload = {
      type: planMode,
      txnType: type,
        title,
        walletId: state.walletId,
        txnType: type,
        categoryId: catId,
        categoryName,
        amountTotalCents,
        amountEachCents,
      startMonth,
      startDay: new Date(dateStr + "T00:00:00").getDate(),
      startDate: Timestamp.fromDate(new Date(dateStr + "T00:00:00")),
        monthsTotal: monthsTotal ?? null,
        generatedThrough: null,
        status: "active",
        paymentMethod: planPayment,
        creditCardId: creditCardId || null,
        statementStartMonth: statementStartMonth || null,
        purchaseDate: purchaseDate || null,
        paidCount: monthsTotal ? 0 : null,
        remainingCount: monthsTotal ? monthsTotal : null,
        createdAt: serverTimestamp(),
        createdBy: state.uid,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      };

      await setDoc(planRef, payload);

      if (planMode === "recurring") await generateRecurring(planRef.id, payload);
      else if (planMode === "installment") await generateInstallments(planRef.id, payload);
      else if (planMode === "finance") await generateFinance(planRef.id, payload);
      else if (planMode === "credit_installment") await generateCreditInstallments(planRef.id, payload);

      txnAmount.value = "";
      txnNote.value = "";
      if (txnPayment) txnPayment.value = "";
      if (txnCard) txnCard.value = "";
      cbRecurring.checked = false;
      cbInstallment.checked = false;
      cbFinance.checked = false;
      syncOptionalFields();
      syncCreditTxnFields();

      txnStatus.textContent = "Plano gerado com sucesso.";
      await loadPlans();
      await reloadAll();
    } catch (e) {
      console.error("createPlanFromTxnForm failed", e);
      setOpsError("Nao foi possivel gerar o plano. Verifique sua permissao.");
    } finally {
      btnAddTxn.disabled = false;
      btnAddTxn.textContent = "Adicionar";
    }
  }

  async function createPlanAndGenerate() {
    if (!btnCreatePlan || !planStatus) return;
    planStatus.textContent = "";

    if (!isPersonalWalletId(state.walletId)) {
      planStatus.textContent = "Planos so podem ser criados em carteiras pessoais.";
      return;
    }

    const type = planType?.value || "recurring";
    const title = (planTitle?.value ?? "").trim();
    const txnKind = planTxnType?.value || "expense";
    const categoryId = planCategory?.value || "";
    const cat = state.categories.get(categoryId);
    const categoryName = cat?.name ?? (planCategory?.options[planCategory.selectedIndex]?.textContent ?? "");

    if (!title) { planStatus.textContent = "Informe a descricao do plano."; return; }
    if (!categoryId) { planStatus.textContent = "Selecione uma categoria."; return; }

    let amountTotalCents = null;
    let amountEachCents = null;
    let monthsTotal = null;

    if (type === "recurring") {
      amountEachCents = parseAmountToCents(planAmountEach?.value);
      if (!amountEachCents || amountEachCents <= 0) { planStatus.textContent = "Informe o valor mensal."; return; }
      amountTotalCents = amountEachCents;
    } else {
      amountTotalCents = parseAmountToCents(planAmountTotal?.value);
      monthsTotal = parsePositiveInt(planMonthsTotal?.value);
      if (!amountTotalCents || amountTotalCents <= 0) { planStatus.textContent = "Informe o valor total."; return; }
      if (!monthsTotal || monthsTotal <= 0) { planStatus.textContent = "Informe o numero de meses."; return; }
      amountEachCents = type === "finance"
        ? amountTotalCents
        : Math.floor(amountTotalCents / monthsTotal);
    }

    let startMonth = yyyyMMFromMonthInput(planStartMonth?.value);
    if (!startMonth) startMonth = currentYYYYMM();
    if (!startMonth) { planStatus.textContent = "Informe o mes inicial."; return; }

    let paymentMethod = planPaymentMethod?.value || "outro";
    let creditCardId = null;
    let purchaseDate = null;
    let statementStartMonth = null;

    if (type === "credit_installment") {
      paymentMethod = "credit_card";
      creditCardId = planCreditCard?.value || "";
      if (!creditCardId) { planStatus.textContent = "Selecione um cartao."; return; }

      const purchaseDateStr = planPurchaseDate?.value || "";
      if (!purchaseDateStr) { planStatus.textContent = "Informe a data da compra."; return; }
      const purchaseDateObj = new Date(purchaseDateStr + "T00:00:00");
      purchaseDate = Timestamp.fromDate(purchaseDateObj);
      statementStartMonth = computeInvoiceMonth(purchaseDateObj, getCardClosingDay(creditCardId));
    }

    btnCreatePlan.disabled = true;
    btnCreatePlan.textContent = "Gerando...";

    try {
      const planRef = doc(collection(db, "wallets", state.walletId, "plans"));
      const payload = {
        type,
        title,
        walletId: state.walletId,
        txnType: txnKind,
        categoryId,
        categoryName,
        amountTotalCents,
        amountEachCents,
        startMonth,
        monthsTotal: monthsTotal ?? null,
        generatedThrough: null,
        status: "active",
        paymentMethod,
        creditCardId: creditCardId || null,
        statementStartMonth: statementStartMonth || null,
        purchaseDate: purchaseDate || null,
        paidCount: monthsTotal ? 0 : null,
        remainingCount: monthsTotal ? monthsTotal : null,
        createdAt: serverTimestamp(),
        createdBy: state.uid,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      };

      await setDoc(planRef, payload);

      if (type === "recurring") await generateRecurring(planRef.id, payload);
      else if (type === "installment") await generateInstallments(planRef.id, payload);
      else if (type === "finance") await generateFinance(planRef.id, payload);
      else if (type === "credit_installment") await generateCreditInstallments(planRef.id, payload);

      planTitle.value = "";
      planAmountEach.value = "";
      planAmountTotal.value = "";
      planMonthsTotal.value = "";
      syncPlanFields();
      planStatus.textContent = "Plano gerado com sucesso.";
      await loadPlans();
      await reloadAll();
    } catch (e) {
      console.error("createPlanAndGenerate failed", e);
      planStatus.textContent = "Nao foi possivel gerar o plano. Verifique sua permissao.";
    } finally {
      btnCreatePlan.disabled = false;
      btnCreatePlan.textContent = "Gerar agora";
    }
  }

  async function generatePlanById(planId) {
    if (!planId) return;
    const plan = await getPlan(planId);
    if (!plan) return;
    if (plan.status === "canceled") {
      if (planStatus) planStatus.textContent = "Plano cancelado.";
      return;
    }
    if (plan.status === "paused") {
      if (planStatus) planStatus.textContent = "Plano pausado.";
      return;
    }
    if (plan.type === "recurring") await generateRecurring(planId, plan);
    else if (plan.type === "installment") await generateInstallments(planId, plan);
    else if (plan.type === "finance") await generateFinance(planId, plan);
    else if (plan.type === "credit_installment") await generateCreditInstallments(planId, plan);
    await loadPlans();
    await reloadAll();
  }

  async function ensureGeneratedUpTo(planId, targetMonth) {
    const plan = await getPlan(planId);
    if (!plan || plan.type !== "recurring") return;

    if (plan.status !== "active") {
      if (planStatus) planStatus.textContent = "Plano pausado ou cancelado.";
      return;
    }

    let current = plan.generatedThrough ? addMonthsYYYYMM(plan.generatedThrough, 1) : plan.startMonth;
    if (!current || !targetMonth) return;

    let lastGenerated = null;
    while (compareYYYYMM(current, targetMonth) <= 0) {
      const index = monthDiff(plan.startMonth, current) + 1;
      const txnId = `r_${planId}_${current}`;
      const v2 = buildPlanV2Fields(plan, index, null);
      let creditFields = {};
      if (isCreditCardPayment(plan.paymentMethod) && plan.creditCardId) {
        const baseDay = plan.purchaseDate?.toDate?.().getDate?.() ?? 1;
        const parsed = parseYYYYMM(current);
        if (parsed) {
          const day = Math.min(baseDay, 28);
          const purchaseDateObj = new Date(parsed.y, parsed.m - 1, day);
          const invoiceMonth = computeInvoiceMonth(purchaseDateObj, getCardClosingDay(plan.creditCardId));
          creditFields = {
            creditCardId: plan.creditCardId,
            statementMonth: invoiceMonth || null,
            invoiceMonth: invoiceMonth || null,
            purchaseDate: Timestamp.fromDate(purchaseDateObj),
            creditCardNameSnapshot: state.creditCards.get(plan.creditCardId)?.name || null
          };
        }
      }
      const competenceMonth = creditFields.statementMonth || current;
      const payload = {
        date: timestampFromYYYYMM(competenceMonth),
        amountCents: plan.amountEachCents || 0,
        type: plan.txnType || "expense",
        categoryId: plan.categoryId,
        categoryName: plan.categoryName,
        note: buildPlanNote(plan, index, null),
        ...v2,
        planId,
        planType: plan.type,
        occurrenceIndex: index,
        occurrenceTotal: null,
        ...creditFields,
        status: "scheduled"
      };
      await createTxnWithDerivations(payload, { walletId: plan.walletId, txnId });
      lastGenerated = current;
      current = addMonthsYYYYMM(current, 1);
    }

    if (lastGenerated) {
      await setDoc(doc(db, "wallets", plan.walletId, "plans", planId), {
        generatedThrough: lastGenerated,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
    }
  }

  async function generateRecurring(planId, planOverride = null) {
    const plan = planOverride || await getPlan(planId);
    if (!plan) return;
    const start = plan.generatedThrough ? addMonthsYYYYMM(plan.generatedThrough, 1) : plan.startMonth;
    if (!start) return;
    const target = addMonthsYYYYMM(start, 11);
    await ensureGeneratedUpTo(planId, target);
  }

  async function generateInstallments(planId, planOverride = null) {
    const plan = planOverride || await getPlan(planId);
    if (!plan || !plan.monthsTotal) return;
    if (plan.status !== "active") return;

    const amounts = splitAmountByMonths(plan.amountTotalCents || 0, plan.monthsTotal);
    let lastMonth = null;

    for (let i = 1; i <= plan.monthsTotal; i += 1) {
      const month = addMonthsYYYYMM(plan.startMonth, i - 1);
      const txnId = `p_${planId}_${String(i).padStart(2, "0")}`;
      const v2 = buildPlanV2Fields(plan, i, plan.monthsTotal);
      const payload = {
        date: timestampFromYYYYMM(month),
        amountCents: amounts[i - 1] ?? plan.amountEachCents ?? 0,
        type: plan.txnType || "expense",
        categoryId: plan.categoryId,
        categoryName: plan.categoryName,
        note: buildPlanNote(plan, i, plan.monthsTotal),
        ...v2,
        planId,
        planType: plan.type,
        occurrenceIndex: i,
        occurrenceTotal: plan.monthsTotal,
        status: "scheduled"
      };
      await createTxnWithDerivations(payload, { walletId: plan.walletId, txnId });
      lastMonth = month;
    }

    if (lastMonth) {
      await setDoc(doc(db, "wallets", plan.walletId, "plans", planId), {
        generatedThrough: lastMonth,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
    }
  }

  async function generateFinance(planId, planOverride = null) {
    const plan = planOverride || await getPlan(planId);
    if (!plan || !plan.monthsTotal) return;
    if (plan.status !== "active") return;

    const baseDate = getPlanBaseDate(plan);
    if (!baseDate) return;
    const amountEachCents = Number(plan.amountEachCents ?? plan.amountTotalCents ?? 0);
    let lastMonthKey = null;

    for (let i = 1; i <= plan.monthsTotal; i += 1) {
      const occurrenceDate = addMonthsPreserveDay(baseDate, i - 1);
      const monthKey = formatMonthKey(occurrenceDate);
      const txnId = `f_${planId}_${String(i).padStart(2, "0")}`;
      const v2 = buildPlanV2Fields(plan, i, plan.monthsTotal);
      const payload = {
        date: Timestamp.fromDate(occurrenceDate),
        monthKey,
        amountCents: amountEachCents,
        type: plan.txnType || "expense",
        categoryId: plan.categoryId,
        categoryName: plan.categoryName,
        note: buildPlanNote(plan, i, plan.monthsTotal),
        ...v2,
        planId,
        planType: plan.type,
        occurrenceIndex: i,
        occurrenceTotal: plan.monthsTotal,
        status: "scheduled"
      };
      await createTxnWithDerivations(payload, { walletId: plan.walletId, txnId });
      lastMonthKey = monthKey;
    }

    if (lastMonthKey) {
      await setDoc(doc(db, "wallets", plan.walletId, "plans", planId), {
        generatedThrough: lastMonthKey,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
    }
  }

  async function generateCreditInstallments(planId, planOverride = null) {
    const plan = planOverride || await getPlan(planId);
    if (!plan || !plan.monthsTotal) return;
    if (plan.status !== "active") return;
    if (!plan.creditCardId) return;

    const amounts = splitAmountByMonths(plan.amountTotalCents || 0, plan.monthsTotal);
    let basePurchaseDate = plan.startDate?.toDate?.() ?? plan.purchaseDate?.toDate?.() ?? null;
    if (!basePurchaseDate) {
      const fallbackMonth = plan.startMonth || plan.statementStartMonth;
      basePurchaseDate = fallbackMonth ? firstDateOfMonth(fallbackMonth) : null;
    }
    if (!basePurchaseDate) return;

    const closingDay = getCardClosingDay(plan.creditCardId);
    let lastMonth = null;

    for (let i = 1; i <= plan.monthsTotal; i += 1) {
      const occurrencePurchaseDate = addMonthsPreserveDay(basePurchaseDate, i - 1);
      const invoiceMonth = computeInvoiceMonth(occurrencePurchaseDate, closingDay);
      if (!invoiceMonth) continue;
      const occurrenceDate = alignDateToMonthKey(occurrencePurchaseDate, invoiceMonth);
      const txnId = `cc_${planId}_${invoiceMonth}`;
      const v2 = buildPlanV2Fields(plan, i, plan.monthsTotal);
      v2.paymentMethod = "credit_card";
      const payload = {
        date: Timestamp.fromDate(occurrenceDate),
        monthKey: invoiceMonth,
        amountCents: amounts[i - 1] ?? plan.amountEachCents ?? 0,
        type: plan.txnType || "expense",
        categoryId: plan.categoryId,
        categoryName: plan.categoryName,
        note: buildPlanNote(plan, i, plan.monthsTotal),
        ...v2,
        planId,
        planType: plan.type,
        occurrenceIndex: i,
        occurrenceTotal: plan.monthsTotal,
        status: "scheduled",
        creditCardId: plan.creditCardId,
        creditCardNameSnapshot: state.creditCards.get(plan.creditCardId)?.name || null,
        invoiceMonth,
        statementMonth: invoiceMonth,
        purchaseDate: Timestamp.fromDate(occurrencePurchaseDate)
      };
      await createTxnWithDerivations(payload, { walletId: plan.walletId, txnId });
      lastMonth = invoiceMonth;
    }

    if (lastMonth) {
      await setDoc(doc(db, "wallets", plan.walletId, "plans", planId), {
        generatedThrough: lastMonth,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });
    }
  }

  // ===== Transactions write (derivations) =====

  async function createTxnWithDerivations(txnPayload, { walletId = state.walletId, txnId = null } = {}) {
    txnPayload = withMonthKey(txnPayload);
    if (isCreditCardPayment(txnPayload.paymentMethod)) {
      let invoiceMonth = txnPayload.invoiceMonth || txnPayload.statementMonth;
      if (!invoiceMonth) {
        const baseDate = txnPayload.purchaseDate?.toDate?.() ?? txnPayload.date?.toDate?.() ?? txnPayload.date;
        if (baseDate instanceof Date && !Number.isNaN(baseDate.getTime())) {
          const closingDay = txnPayload.creditCardId ? getCardClosingDay(txnPayload.creditCardId) : 31;
          invoiceMonth = computeInvoiceMonth(baseDate, closingDay);
        }
      }
      if (invoiceMonth && !txnPayload.invoiceMonth) txnPayload.invoiceMonth = invoiceMonth;
      if (invoiceMonth && !txnPayload.statementMonth) txnPayload.statementMonth = invoiceMonth;
      if (!txnPayload.creditCardNameSnapshot && txnPayload.creditCardId) {
        txnPayload.creditCardNameSnapshot = state.creditCards.get(txnPayload.creditCardId)?.name || null;
      }
    }
    const personalWalletId = walletId;
    const shouldSyncToCouple = isPersonalWalletId(personalWalletId);

    const personalCol = collection(db, "wallets", personalWalletId, "transactions");
    const personalRef = txnId ? doc(personalCol, txnId) : doc(personalCol);
    const realTxnId = personalRef.id;
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${personalWalletId}_${realTxnId}`);

    const month = txnPayload.monthKey || yyyyMMFromTimestamp(txnPayload.date);
    if (!month) throw new Error("Data invalida.");

    const reportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", month);

    const needsStatement = isCreditCardPayment(txnPayload.paymentMethod) && txnPayload.creditCardId && txnPayload.statementMonth;
    const statementRef = needsStatement ? getStatementRef(personalWalletId, txnPayload.creditCardId, txnPayload.statementMonth) : null;

    await runTransaction(db, async (tx) => {
      const txnSnap = await tx.get(personalRef);
      if (txnSnap.exists()) return;

      let repSnap = null;
      let repData = null;
      let repExists = false;
      let stmtSnap = null;

      if (shouldSyncToCouple) {
        repSnap = await tx.get(reportRef);
        repExists = repSnap.exists();
        repData = repExists ? repSnap.data() : null;
      }

      if (needsStatement && statementRef) {
        stmtSnap = await tx.get(statementRef);
      }

      const basePayload = {
        ...txnPayload,
        createdAt: serverTimestamp(),
        createdBy: state.uid
      };

      tx.set(personalRef, basePayload, { merge: true });

      if (shouldSyncToCouple) {
        tx.set(viewRef, {
          ...basePayload,
          sourceWalletId: personalWalletId,
          sourceTxnId: realTxnId,
          sourceUid: state.uid,
          syncedAt: serverTimestamp()
        }, { merge: true });

        const deltaIncome = (txnPayload.type === "income") ? Number(txnPayload.amountCents || 0) : 0;
        const deltaExpense = (txnPayload.type === "expense") ? Number(txnPayload.amountCents || 0) : 0;

        const { nextIncome, nextExpense } = computeCoupleSourceNext(repData, personalWalletId, deltaIncome, deltaExpense);

        const reportPatch = {
          month,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid,
          sources: {
            [personalWalletId]: {
              incomeCents: nextIncome,
              expenseCents: nextExpense,
              updatedAt: serverTimestamp(),
              updatedBy: state.uid
            }
          }
        };

        const mergeFields = ["month", "updatedAt", "updatedBy", `sources.${personalWalletId}`];
        if (!repExists) {
          reportPatch.createdAt = serverTimestamp();
          reportPatch.createdBy = state.uid;
          mergeFields.push("createdAt", "createdBy");
        }
        tx.set(reportRef, reportPatch, { mergeFields });
      }

      if (needsStatement && statementRef) {
        const currentTotal = Number(stmtSnap?.data()?.totalCents || 0);
        const delta = statementSignedAmount(txnPayload.amountCents, txnPayload.type);
        const nextTotal = currentTotal + delta;
        const patch = {
          month: txnPayload.statementMonth,
          totalCents: nextTotal,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid
        };
        if (!stmtSnap?.exists?.()) {
          patch.status = "open";
          patch.paidAt = null;
          patch.createdAt = serverTimestamp();
          patch.createdBy = state.uid;
        }
        tx.set(statementRef, patch, { merge: true });
      }
    });
  }

  async function updateTxnWithDerivations(txnId, updates, { walletId = state.walletId } = {}) {
    const personalWalletId = walletId;
    const shouldSyncToCouple = isPersonalWalletId(personalWalletId);
    const personalRef = doc(db, "wallets", personalWalletId, "transactions", txnId);
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${personalWalletId}_${txnId}`);

    await runTransaction(db, async (tx) => {
      const txnSnap = await tx.get(personalRef);
      if (!txnSnap.exists()) throw new Error("Transacao nao encontrada.");

      const existingRaw = txnSnap.data();
      const existing = normalizeTxnV2(existingRaw);
      const nextRaw = { ...existingRaw, ...updates };
      const next = normalizeTxnV2(nextRaw);

      const oldAmount = Number(existing.amountCents || 0);
      const newAmount = Number(next.amountCents || 0);
      const oldType = existing.type ?? "expense";
      const newType = next.type ?? "expense";
      const oldMonth = existing.monthKey || yyyyMMFromTimestamp(existing.date);
      const newMonth = next.monthKey || yyyyMMFromTimestamp(next.date);
      if (!oldMonth || !newMonth) throw new Error("Data invalida.");

      let oldRepSnap = null;
      let newRepSnap = null;
      let oldReportRef = null;
      let newReportRef = null;

      if (shouldSyncToCouple) {
        oldReportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", oldMonth);
        oldRepSnap = await tx.get(oldReportRef);
        if (newMonth === oldMonth) {
          newReportRef = oldReportRef;
          newRepSnap = oldRepSnap;
        } else {
          newReportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", newMonth);
          newRepSnap = await tx.get(newReportRef);
        }
      }

      const oldStmtKey = getStatementKey(existing);
      const newStmtKey = getStatementKey(next);
      let oldStmtSnap = null;
      let newStmtSnap = null;
      let oldStmtRef = null;
      let newStmtRef = null;

      if (oldStmtKey) {
        oldStmtRef = getStatementRef(personalWalletId, oldStmtKey.cardId, oldStmtKey.month);
        oldStmtSnap = await tx.get(oldStmtRef);
      }
      if (newStmtKey) {
        newStmtRef = getStatementRef(personalWalletId, newStmtKey.cardId, newStmtKey.month);
        if (!oldStmtKey || oldStmtKey.cardId !== newStmtKey.cardId || oldStmtKey.month !== newStmtKey.month) {
          newStmtSnap = await tx.get(newStmtRef);
        } else {
          newStmtSnap = oldStmtSnap;
        }
      }

      tx.set(personalRef, {
        ...updates,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });

      if (shouldSyncToCouple) {
        tx.set(viewRef, {
          ...next,
          sourceWalletId: personalWalletId,
          sourceTxnId: txnId,
          sourceUid: existing.sourceUid || state.uid,
          syncedAt: serverTimestamp()
        }, { merge: true });

        const oldIncome = oldType === "income" ? oldAmount : 0;
        const oldExpense = oldType === "expense" ? oldAmount : 0;
        const newIncome = newType === "income" ? newAmount : 0;
        const newExpense = newType === "expense" ? newAmount : 0;

        const applyReportUpdate = (repRef, repSnap, deltaIncome, deltaExpense) => {
          const repExists = repSnap?.exists?.() ?? false;
          const repData = repExists ? repSnap.data() : null;
          const { nextIncome, nextExpense } = computeCoupleSourceNext(repData, personalWalletId, deltaIncome, deltaExpense);

          const patch = {
            month: repRef.id,
            updatedAt: serverTimestamp(),
            updatedBy: state.uid,
            sources: {
              [personalWalletId]: {
                incomeCents: nextIncome,
                expenseCents: nextExpense,
                updatedAt: serverTimestamp(),
                updatedBy: state.uid
              }
            }
          };
          const mergeFields = ["month", "updatedAt", "updatedBy", `sources.${personalWalletId}`];
          if (!repExists) {
            patch.createdAt = serverTimestamp();
            patch.createdBy = state.uid;
            mergeFields.push("createdAt", "createdBy");
          }
          tx.set(repRef, patch, { mergeFields });
        };

        if (newMonth === oldMonth) {
          applyReportUpdate(oldReportRef, oldRepSnap, newIncome - oldIncome, newExpense - oldExpense);
        } else {
          applyReportUpdate(oldReportRef, oldRepSnap, -oldIncome, -oldExpense);
          applyReportUpdate(newReportRef, newRepSnap, newIncome, newExpense);
        }
      }

      const applyStatementUpdate = (stmtRef, stmtSnap, delta) => {
        if (!stmtRef || !delta) return;
        const currentTotal = Number(stmtSnap?.data()?.totalCents || 0);
        const nextTotal = currentTotal + delta;
        const patch = {
          month: stmtRef.id,
          totalCents: nextTotal,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid
        };
        if (!stmtSnap?.exists?.()) {
          patch.status = "open";
          patch.paidAt = null;
          patch.createdAt = serverTimestamp();
          patch.createdBy = state.uid;
        }
        tx.set(stmtRef, patch, { merge: true });
      };

      const oldSigned = statementSignedAmount(oldAmount, oldType);
      const newSigned = statementSignedAmount(newAmount, newType);

      if (oldStmtRef && newStmtRef && oldStmtRef.path === newStmtRef.path) {
        const delta = newSigned - oldSigned;
        applyStatementUpdate(oldStmtRef, oldStmtSnap, delta);
      } else {
        if (oldStmtRef) applyStatementUpdate(oldStmtRef, oldStmtSnap, -oldSigned);
        if (newStmtRef) applyStatementUpdate(newStmtRef, newStmtSnap, newSigned);
      }
    });
  }

  async function deleteTxnWithDerivations(txnId, { walletId = state.walletId } = {}) {
    const personalWalletId = walletId;
    if (!isPersonalWalletId(personalWalletId)) return;
    const personalRef = doc(db, "wallets", personalWalletId, "transactions", txnId);
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${personalWalletId}_${txnId}`);

    await runTransaction(db, async (tx) => {
      const txnSnap = await tx.get(personalRef);
      if (!txnSnap.exists()) return;

      const existing = normalizeTxn(txnSnap.data());
      const amount = Number(existing.amountCents || 0);
      const type = existing.type ?? "expense";
      const month = existing.monthKey || yyyyMMFromTimestamp(existing.date);
      if (!month) return;

      let repSnap = null;
      let repData = null;
      let repExists = false;
      const reportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", month);

      if (isPersonalWalletId(personalWalletId)) {
        repSnap = await tx.get(reportRef);
        repExists = repSnap.exists();
        repData = repExists ? repSnap.data() : null;
      }

      const stmtKey = getStatementKey(existing);
      const stmtRef = stmtKey ? getStatementRef(personalWalletId, stmtKey.cardId, stmtKey.month) : null;
      const stmtSnap = stmtRef ? await tx.get(stmtRef) : null;

      tx.delete(personalRef);
      tx.delete(viewRef);

      const deltaIncome = (type === "income") ? -amount : 0;
      const deltaExpense = (type === "expense") ? -amount : 0;

      if (repData || repExists) {
        const { nextIncome, nextExpense } = computeCoupleSourceNext(repData, personalWalletId, deltaIncome, deltaExpense);
        const reportPatch = {
          month,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid,
          sources: {
            [personalWalletId]: {
              incomeCents: nextIncome,
              expenseCents: nextExpense,
              updatedAt: serverTimestamp(),
              updatedBy: state.uid
            }
          }
        };
        const mergeFields = ["month", "updatedAt", "updatedBy", `sources.${personalWalletId}`];
        if (!repExists) {
          reportPatch.createdAt = serverTimestamp();
          reportPatch.createdBy = state.uid;
          mergeFields.push("createdAt", "createdBy");
        }
        tx.set(reportRef, reportPatch, { mergeFields });
      }

      if (stmtRef) {
        const currentTotal = Number(stmtSnap?.data()?.totalCents || 0);
        const delta = -statementSignedAmount(amount, type);
        const nextTotal = currentTotal + delta;
        const patch = {
          month: stmtRef.id,
          totalCents: nextTotal,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid
        };
        if (!stmtSnap?.exists?.()) {
          patch.status = "open";
          patch.paidAt = null;
          patch.createdAt = serverTimestamp();
          patch.createdBy = state.uid;
        }
        tx.set(stmtRef, patch, { merge: true });
      }
    });
  }

  async function markOccurrencePaid(txnId) {
    if (!isPersonalWalletId(state.walletId)) return;
    const personalRef = doc(db, "wallets", state.walletId, "transactions", txnId);
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${state.walletId}_${txnId}`);

    await runTransaction(db, async (tx) => {
      const txnSnap = await tx.get(personalRef);
      if (!txnSnap.exists()) return;
      const txn = txnSnap.data();
      if (txn.status === "paid") return;

      tx.set(personalRef, {
        status: "paid",
        paidAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });

      tx.set(viewRef, {
        status: "paid",
        paidAt: serverTimestamp(),
        syncedAt: serverTimestamp()
      }, { merge: true });

      if (txn.planId) {
        const planRef = doc(db, "wallets", state.walletId, "plans", txn.planId);
        const planSnap = await tx.get(planRef);
        if (planSnap.exists()) {
          const plan = planSnap.data();
          const monthsTotal = Number(plan.monthsTotal || 0);
          const paidCount = Number(plan.paidCount || 0) + 1;
          const patch = {
            paidCount,
            updatedAt: serverTimestamp(),
            updatedBy: state.uid
          };
          if (monthsTotal) {
            patch.remainingCount = Math.max(0, monthsTotal - paidCount);
            if (paidCount >= monthsTotal) patch.status = "completed";
          }
          tx.set(planRef, patch, { merge: true });
        }
      }
    });
  }

  async function markOccurrenceUnpaid(txnId) {
    if (!isPersonalWalletId(state.walletId)) return;
    const personalRef = doc(db, "wallets", state.walletId, "transactions", txnId);
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${state.walletId}_${txnId}`);

    await runTransaction(db, async (tx) => {
      const txnSnap = await tx.get(personalRef);
      if (!txnSnap.exists()) return;
      const txn = txnSnap.data();
      if (txn.status !== "paid") return;

      tx.set(personalRef, {
        status: "scheduled",
        paidAt: null,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      }, { merge: true });

      tx.set(viewRef, {
        status: "scheduled",
        paidAt: null,
        syncedAt: serverTimestamp()
      }, { merge: true });

      if (txn.planId) {
        const planRef = doc(db, "wallets", state.walletId, "plans", txn.planId);
        const planSnap = await tx.get(planRef);
        if (planSnap.exists()) {
          const plan = planSnap.data();
          const monthsTotal = Number(plan.monthsTotal || 0);
          const paidCount = Math.max(0, Number(plan.paidCount || 0) - 1);
          const patch = {
            paidCount,
            updatedAt: serverTimestamp(),
            updatedBy: state.uid
          };
          if (monthsTotal) {
            patch.remainingCount = Math.max(0, monthsTotal - paidCount);
            if (plan.status === "completed" && paidCount < monthsTotal) patch.status = "active";
          }
          tx.set(planRef, patch, { merge: true });
        }
      }
    });
  }

  function openEditModal(txnId) {
    if (!editModal) return;
    state.editingTxnId = txnId;
    editModal.hidden = false;
    if (editTxnDate) editTxnDate.focus({ preventScroll: true });
  }

  function closeEditModal() {
    if (!editModal) return;
    editModal.hidden = true;
    state.editingTxnId = null;
  }

  async function prepareEditModal(txnId) {
    if (!editModal || !editTxnDate || !editTxnType || !editTxnCat || !editTxnAmount || !editTxnNote || !editStatus || !editError) {
      return;
    }
    editError.textContent = "";
    editStatus.textContent = "";

    if (!isPersonalWalletId(state.walletId)) {
      editError.textContent = "Edição só é permitida em wallets pessoais.";
      return;
    }

    let txn = state.txnCache.get(txnId);
    if (!txn) {
      try {
        const snap = await getDoc(doc(db, "wallets", state.walletId, "transactions", txnId));
        if (snap.exists()) {
          const data = normalizeTxn(snap.data());
          txn = {
            id: txnId,
            date: data.date?.toDate?.() ?? null,
            purchaseDate: data.purchaseDate?.toDate?.() ?? null,
            amountCents: Number(data.amountCents || 0),
            type: data.type ?? "expense",
            categoryId: data.categoryId ?? "",
            categoryName: data.categoryName ?? "",
            note: data.note ?? "",
            paymentMethod: data.paymentMethod ?? ""
          };
        }
      } catch (e) {
        editError.textContent = e?.message ?? String(e);
        return;
      }
    }

    if (!txn) {
      editError.textContent = "Transação não encontrada para edição.";
      return;
    }

    const editBaseDate = (isCreditCardPayment(txn.paymentMethod) && txn.purchaseDate) ? txn.purchaseDate : txn.date;
    if (editBaseDate) editTxnDate.value = toISODateLocal(editBaseDate);
    editTxnType.value = txn.type || "expense";
    setCategoryOptions(editTxnCat, txn.categoryId || "", txn.categoryName || "Categoria removida");
    editTxnAmount.value = formatCentsToInputValue(txn.amountCents);
    editTxnNote.value = txn.note || "";

    openEditModal(txnId);
  }

  async function createPlanFromTxnFormV2({ planMode, dateStr, type, catId, categoryName, amountCents, note, paymentMethod }) {
    setOpsError("");

    if (!isPersonalWalletId(state.walletId)) {
      setOpsError("Planos so podem ser criados em carteiras pessoais.");
      return;
    }

    const inputDate = new Date(dateStr + "T00:00:00");
    if (Number.isNaN(inputDate.getTime())) {
      setOpsError("Informe uma data valida.");
      return;
    }

    let monthsTotal = 0;
    let currentInstallment = 1;
    if (planMode === "recurring") {
      monthsTotal = 12;
    } else if (planMode === "installment" || planMode === "credit_installment") {
      monthsTotal = Number(installmentTotal?.value || 0);
      currentInstallment = parsePositiveInt(installmentCurrent?.value) || 1;
    } else if (planMode === "finance") {
      monthsTotal = Number(financeTotal?.value || 0);
      currentInstallment = parsePositiveInt(financeCurrent?.value) || 1;
    }

    if (!monthsTotal || monthsTotal < 1) {
      setOpsError("Informe o total de parcelas.");
      return;
    }

    if ((planMode === "installment" || planMode === "credit_installment" || planMode === "finance")
      && currentInstallment > monthsTotal) {
      setOpsError("A parcela atual nao pode ser maior que o total.");
      return;
    }

    const usesCurrent = planMode === "installment" || planMode === "credit_installment" || planMode === "finance";
    const startDate = usesCurrent
      ? addMonthsPreserveDay(inputDate, -(currentInstallment - 1))
      : inputDate;
    const startMonth = formatMonthKey(startDate);
    const planTitleValue = (note || categoryName || "Plano").trim();
    const shouldSplit = planMode === "installment" || planMode === "credit_installment";
    const amounts = shouldSplit ? splitCents(amountCents, monthsTotal) : [];
    const amountEachCents = shouldSplit ? (amounts[0] ?? amountCents) : amountCents;

    let creditCardId = "";
    let cardClosingDay = null;
    let planPurchaseDate = null;
    let statementStartMonth = "";
    if (planMode === "finance" && isCreditCardPayment(paymentMethod)) {
      setOpsError("Financiamento nao usa cartao de credito.");
      return;
    }
    if (isCreditCardPayment(paymentMethod)) {
      creditCardId = txnCard?.value || "";
      if (!creditCardId) {
        setOpsError("Selecione um cartao.");
        return;
      }
      cardClosingDay = getCardClosingDay(creditCardId);
      planPurchaseDate = Timestamp.fromDate(startDate);
      statementStartMonth = computeInvoiceMonth(startDate, cardClosingDay);
    }

    btnAddTxn.disabled = true;
    btnAddTxn.textContent = "Gerando...";

    try {
      const planPayload = {
        type: planMode,
        txnType: type,
        title: planTitleValue,
        walletId: state.walletId,
        categoryId: catId,
        categoryName,
        amountTotalCents: amountCents,
        amountEachCents,
        startMonth,
        startDay: startDate.getDate(),
        startDate: Timestamp.fromDate(startDate),
        monthsTotal,
        generatedThrough: startMonth,
        status: "active",
        paymentMethod: isCreditCardPayment(paymentMethod) ? "credit_card" : (paymentMethod || "outro"),
        creditCardId: creditCardId || null,
        statementStartMonth: statementStartMonth || null,
        purchaseDate: planPurchaseDate || null,
        createdAt: serverTimestamp(),
        createdBy: state.uid,
        updatedAt: serverTimestamp(),
        updatedBy: state.uid
      };

      const planRef = await addDoc(collection(db, "wallets", state.walletId, "plans"), planPayload);
      const planId = planRef.id;
      const occurrenceTotal = monthsTotal;

      for (let idx = 0; idx < monthsTotal; idx += 1) {
        const occurrenceIndex = idx + 1;
        let occurrencePurchaseDate = addMonthsPreserveDay(startDate, idx);
        if (planMode === "installment" || planMode === "finance" || planMode === "credit_installment") {
          occurrencePurchaseDate = addMonthsPreserveDay(inputDate, occurrenceIndex - currentInstallment);
        }

        const isCreditPayment = isCreditCardPayment(paymentMethod) && creditCardId;
        const invoiceMonth = isCreditPayment
          ? computeInvoiceMonth(occurrencePurchaseDate, cardClosingDay)
          : "";
        const occurrenceDate = (isCreditPayment && invoiceMonth)
          ? alignDateToMonthKey(occurrencePurchaseDate, invoiceMonth)
          : occurrencePurchaseDate;
        const monthKey = invoiceMonth || formatMonthKey(occurrenceDate);
        const txnId = planMode === "recurring"
          ? `r_${planId}_${monthKey}`
          : planMode === "finance"
            ? `f_${planId}_${String(occurrenceIndex).padStart(2, "0")}`
            : planMode === "credit_installment"
              ? `cc_${planId}_${monthKey}`
              : `p_${planId}_${String(occurrenceIndex).padStart(2, "0")}`;

        const amountForOccurrence = shouldSplit
          ? (amounts[idx] ?? amountEachCents)
          : amountEachCents;

        const txnPayload = {
          date: Timestamp.fromDate(occurrenceDate),
          monthKey,
          amountCents: amountForOccurrence,
          type,
          categoryId: catId,
          categoryName,
          note,
          planId,
          planType: planMode,
          occurrenceIndex,
          occurrenceTotal,
          status: "scheduled",
          paymentMethod: isCreditPayment ? "credit_card" : (paymentMethod || "outro"),
          creditCardId: isCreditPayment ? creditCardId : null,
          creditCardNameSnapshot: isCreditPayment ? (state.creditCards.get(creditCardId)?.name || null) : null,
          invoiceMonth: invoiceMonth || null,
          statementMonth: invoiceMonth || null,
          purchaseDate: isCreditPayment ? Timestamp.fromDate(occurrencePurchaseDate) : null,
          originalType: type,
          recurring: { isRecurring: planMode === "recurring", cadence: planMode === "recurring" ? "monthly" : "none" },
          installment: (planMode === "installment" || planMode === "credit_installment")
            ? { isInstallment: true, total: occurrenceTotal, current: occurrenceIndex }
            : { isInstallment: false, total: null, current: null },
          finance: planMode === "finance"
            ? { isFinance: true, total: occurrenceTotal, current: occurrenceIndex }
            : { isFinance: false, total: null, current: null }
        };

        await createTxnWithDerivations(txnPayload, { walletId: state.walletId, txnId });
      }

      if (planMode === "recurring") {
        const generatedThrough = formatMonthKey(addMonthsPreserveDay(startDate, monthsTotal - 1));
        await setDoc(planRef, { generatedThrough, updatedAt: serverTimestamp(), updatedBy: state.uid }, { merge: true });
      }

      txnAmount.value = "";
      txnNote.value = "";
      if (txnPayment) txnPayment.value = "";
      if (txnCard) txnCard.value = "";
      syncCreditTxnFields();

      await reloadAll();
    } catch (e) {
      console.error("createPlanFromTxnFormV2 failed", e);
      setOpsError("Nao foi possivel gerar o plano. Tente novamente.");
    } finally {
      btnAddTxn.disabled = false;
      btnAddTxn.textContent = "Adicionar";
    }
  }

  async function addTransaction() {
    setOpsError("");

    if (isCoupleWallet()) {
      setOpsError("Esta visao consolidada e somente leitura. Lance receitas e despesas em uma carteira pessoal.");
      return;
    }

    const dateStr = txnDate.value;
    if (!dateStr) { setOpsError("Informe a data."); return; }

    const rawType = txnType.value;
    const type = rawType === "reserve" ? "expense" : rawType;
    const txnV2 = buildTxnV2Payload(rawType, type);
    const catId = txnCat.value;
    if (!catId) { setOpsError("Selecione uma categoria."); return; }

    const amountCents = parseAmountToCents(txnAmount.value);
    if (amountCents == null || amountCents <= 0) {
      setOpsError("Informe um valor valido (maior que zero).");
      return;
    }

    const note = (txnNote.value ?? "").trim();
    const cat = state.categories.get(catId);
    const categoryName = cat?.name ?? "";

    const wantsRecurring = !!cbRecurring?.checked;
    const wantsInstallment = !!cbInstallment?.checked;
    const wantsFinance = !!cbFinance?.checked;

    if ((wantsInstallment && wantsFinance) || (wantsRecurring && (wantsInstallment || wantsFinance))) {
      setOpsError("Escolha apenas uma opcao de plano.");
      return;
    }

    let planMode = "";
    if (wantsFinance) planMode = "finance";
    else if (wantsInstallment) planMode = (isCreditCardPayment(txnV2.paymentMethod) ? "credit_installment" : "installment");
    else if (wantsRecurring) planMode = "recurring";

    if (planMode) {
      await createPlanFromTxnFormV2({
        planMode,
        dateStr,
        type,
        catId,
        categoryName,
        amountCents,
        note,
        paymentMethod: txnV2.paymentMethod
      });
      return;
    }

    const personalWalletId = state.walletId;

    let creditCardId = null;
    let invoiceMonth = null;
    let statementMonth = null;
    let purchaseDate = null;
    let creditCardNameSnapshot = null;

    if (isCreditCardPayment(txnV2.paymentMethod)) {
      creditCardId = txnCard?.value || "";
      if (!creditCardId) { setOpsError("Selecione um cartao."); return; }

      const purchaseDateObj = new Date(dateStr + "T00:00:00");
      invoiceMonth = computeInvoiceMonth(purchaseDateObj, getCardClosingDay(creditCardId));
      statementMonth = invoiceMonth || null;
      purchaseDate = Timestamp.fromDate(purchaseDateObj);
      creditCardNameSnapshot = state.creditCards.get(creditCardId)?.name || null;
    }

    btnAddTxn.disabled = true;
    btnAddTxn.textContent = "Salvando...";

    try {
      const baseDate = new Date(dateStr + "T00:00:00");
      const dateForTxn = invoiceMonth ? alignDateToMonthKey(baseDate, invoiceMonth) : baseDate;
      const ts = Timestamp.fromDate(dateForTxn);
      const monthKey = formatMonthKey(dateForTxn);

      const txnPayload = {
        date: ts,
        monthKey,
        amountCents,
        type,
        categoryId: catId,
        categoryName,
        note,
        ...txnV2,
        creditCardId,
        creditCardNameSnapshot,
        invoiceMonth,
        statementMonth,
        purchaseDate
      };

      await createTxnWithDerivations(txnPayload, { walletId: personalWalletId });

      txnAmount.value = "";
      txnNote.value = "";
      if (txnPayment) txnPayment.value = "";
      if (txnCard) txnCard.value = "";
      syncCreditTxnFields();

      await reloadAll();
    } catch (e) {
      console.error("addTransaction failed", e);
      setOpsError("Nao foi possivel salvar a transacao. Tente novamente.");
    } finally {
      btnAddTxn.disabled = false;
      btnAddTxn.textContent = "Adicionar";
    }
  }

  async function deleteTransactionPersonalAndSync(txnId) {
    setOpsError("");

    const personalWalletId = state.walletId;
    if (!isPersonalWalletId(personalWalletId)) {
      setOpsError("Para excluir aqui, escolha uma carteira pessoal.");
      return;
    }

    try {
      await deleteTxnWithDerivations(txnId, { walletId: personalWalletId });
      await reloadAll();
    } catch (e) {
      setOpsError("Nao foi possivel excluir a transacao. Tente novamente.");
    }
  }

  async function handleTransactionDelete(txnId) {
    if (!txnId) return;
    const cached = state.txnCache.get(txnId) || state.currentRows.find((r) => r.id === txnId) || {};
    const planId = cached.planId || "";
    const planType = cached.planType || "";
    const isInstallmentPlan = planId && ["installment", "finance", "credit_installment"].includes(planType);

    if (isInstallmentPlan) {
      const onlyThis = confirm("Excluir somente esta parcela do mes?\nOK = apenas esta parcela\nCancelar = outras opcoes");
      if (onlyThis) {
        await deleteTransactionPersonalAndSync(txnId);
        return;
      }
      const removeAll = confirm("Excluir todas as parcelas deste plano? Isso remove o plano e todas as parcelas.");
      if (!removeAll) return;
      await deletePlanAndOccurrences(planId, { deletePlanDoc: true, statusEl: txnStatus });
      return;
    }

    if (!confirm("Excluir esta transacao? Isso tambem removera do consolidado.")) return;
    await deleteTransactionPersonalAndSync(txnId);
  }

  async function updateTransactionPersonalAndSync() {
    if (!editModal || !editTxnDate || !editTxnType || !editTxnCat || !editTxnAmount || !editTxnNote || !btnSaveEdit || !editError || !editStatus) {
      return;
    }
    editError.textContent = "";
    editStatus.textContent = "";

    if (!state.editingTxnId) { editError.textContent = "Nenhuma transacao selecionada."; return; }
    if (!isPersonalWalletId(state.walletId)) { editError.textContent = "Edicao so e permitida em wallets pessoais."; return; }

    const txnId = state.editingTxnId;
    const dateStr = editTxnDate.value;
    const type = editTxnType.value;
    const catId = editTxnCat.value;
    const amountCents = parseAmountToCents(editTxnAmount.value);
    const note = (editTxnNote.value ?? "").trim();

    if (!dateStr) { editError.textContent = "Informe a data."; return; }
    if (!catId) { editError.textContent = "Selecione uma categoria."; return; }
    if (amountCents == null || amountCents <= 0) { editError.textContent = "Informe um valor valido (maior que zero)."; return; }

    const cat = state.categories.get(catId);
    const categoryName = cat?.name ?? (editTxnCat.options[editTxnCat.selectedIndex]?.textContent ?? "");

    btnSaveEdit.disabled = true;
    btnSaveEdit.textContent = "Salvando...";

    try {
      const cached = state.txnCache.get(txnId) || {};
      const isCredit = isCreditCardPayment(cached.paymentMethod);
      const baseDate = new Date(dateStr + "T00:00:00");
      const updates = {
        amountCents,
        type,
        categoryId: catId,
        categoryName,
        note
      };

      if (isCredit) {
        const closingDay = cached.creditCardId ? getCardClosingDay(cached.creditCardId) : 31;
        const invoiceMonth = computeInvoiceMonth(baseDate, closingDay);
        const dateForTxn = invoiceMonth ? alignDateToMonthKey(baseDate, invoiceMonth) : baseDate;
        updates.date = Timestamp.fromDate(dateForTxn);
        updates.monthKey = formatMonthKey(dateForTxn);
        updates.purchaseDate = Timestamp.fromDate(baseDate);
        updates.invoiceMonth = invoiceMonth || null;
        updates.statementMonth = invoiceMonth || null;
        updates.creditCardId = cached.creditCardId || null;
        updates.creditCardNameSnapshot = cached.creditCardNameSnapshot
          || (cached.creditCardId ? state.creditCards.get(cached.creditCardId)?.name : null)
          || null;
      } else {
        updates.date = Timestamp.fromDate(baseDate);
        updates.monthKey = formatMonthKey(baseDate);
      }

      await updateTxnWithDerivations(txnId, updates, { walletId: state.walletId });

      editStatus.textContent = "Transacao atualizada.";
      closeEditModal();
      await reloadAll();
    } catch (e) {
      editError.textContent = e?.message ?? String(e);
    } finally {
      btnSaveEdit.disabled = false;
      btnSaveEdit.textContent = "Salvar alteracoes";
    }
  }

// ===== Transactions list / Couple views =====

  function renderTxnRows(rows, { allowDelete, isCoupleView, allowEdit }) {
    txnTable.innerHTML = "";
    updateSortIndicators("transactions");
    const sorted = sortCollection("transactions", rows || []);

    for (const r of sorted) {
      const dateToShow = (isCreditCardPayment(r.paymentMethod) && r.purchaseDate) ? r.purchaseDate : r.date;
      const dt = dateToShow ? toISODateLocal(dateToShow) : "-";
      const display = toBRL(Math.abs(r.amountCents));
      const prefix = (r.type === "income") ? "+" : "-";
      const metaParts = [];
      const isInstallment = isInstallmentTxn(r);
      const isFinance = isFinanceTxn(r);
      const isCounterTxn = isInstallment || isFinance;
      const isCredit = isCreditCardPayment(r.paymentMethod);
      const installmentBadge = occurrenceCounterLabel(r);
      const showRecurringIcon = shouldShowRecurringIcon(r);
      if (r.planType && r.planType !== "recurring" && !isCounterTxn && !isCredit) {
        metaParts.push(friendlyPlanType(r.planType));
      }
      const isRecurringPlan = r.planType === "recurring" || r.recurring?.isRecurring;
      if (r.occurrenceIndex && r.occurrenceTotal && !isCounterTxn && !isRecurringPlan && !isCredit) {
        metaParts.push(`${r.occurrenceIndex}/${r.occurrenceTotal}`);
      }
      const statusLabel = friendlyTxnStatus(r.status);
      if (statusLabel && !isCounterTxn && !isCredit && !(showRecurringIcon && statusLabel.toLowerCase().includes("agend"))) {
        metaParts.push(statusLabel);
      }
      const creditTag = creditCardTag(r);
      const extraParts = [];
      if (isCoupleView && r.sourceLabel) extraParts.push(`<span>${escapeHtml(r.sourceLabel)}</span>`);
      if (metaParts.length) extraParts.push(`<span>${escapeHtml(metaParts.join(" | "))}</span>`);
      if (creditTag) extraParts.push(`<span class="badge">${escapeHtml(creditTag)}</span>`);
      const extraLine = extraParts.length
        ? `<div class="muted" style="margin-top:4px; display:flex; flex-wrap:wrap; gap:6px;">${extraParts.join("")}</div>`
        : "";
      const descBase = (r.note || "").trim();
      const descText = descBase || (installmentBadge || showRecurringIcon ? "(sem descricao)" : "-");
      const installmentHtml = installmentBadge ? `<span class="installment-badge">${escapeHtml(installmentBadge)}</span>` : "";
      const recurringHtml = showRecurringIcon ? `<span class="recurring-icon" aria-label="Recorrente">${ICON_RECURRING}</span>` : "";
      const canPay = allowDelete && !isCoupleView
        && r.status && r.status !== "paid"
        && ["installment", "finance", "credit_installment"].includes(r.planType);

      const paymentBase = friendlyPaymentMethod(r.paymentMethod);
      let paymentLabel = paymentBase;
      if (isCreditCardPayment(r.paymentMethod)) {
        const cardName = r.creditCardNameSnapshot
          || (r.creditCardId ? state.creditCards.get(r.creditCardId)?.name : "");
        if (cardName) paymentLabel = `${paymentBase} - ${cardName}`;
      }

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(descText)}${installmentHtml}${recurringHtml}${extraLine}</td>
        <td>${escapeHtml(paymentLabel)}</td>
        <td>${escapeHtml(r.categoryName || "-")}</td>
        <td class="nowrap">${escapeHtml(dt)}</td>
        <td class="right nowrap">${prefix} ${escapeHtml(display)}</td>
        <td class="right nowrap">
          ${allowEdit ? `<button class="ghost" data-edit-txn="${r.id}" aria-label="Editar" title="Editar" style="margin-right:6px;">${ICON_EDIT}</button>` : ""}
          ${allowDelete ? `<button class="ghost" data-del-txn="${r.id}" aria-label="Excluir" title="Excluir">${ICON_DELETE}</button>` : `<span class="muted">-</span>`}
          ${canPay ? `<button class="ghost" data-pay-txn="${r.id}" style="margin-left:6px;">Marcar paga</button>` : ""}
        </td>
      `;
      txnTable.appendChild(tr);
    }

    if (allowDelete) {
      txnTable.querySelectorAll("button[data-del-txn]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-del-txn");
          await handleTransactionDelete(id);
        });
      });
    }

    if (allowEdit) {
      txnTable.querySelectorAll("button[data-edit-txn]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-edit-txn");
          await prepareEditModal(id);
        });
      });
    }

    if (allowDelete) {
      txnTable.querySelectorAll("button[data-pay-txn]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-pay-txn");
          await markOccurrencePaid(id);
          await reloadAll();
        });
      });
    }
  }

  async function loadCoupleTotals(yyyyMM) {
    coupleBreakdown.style.display = "";
    coupleBreakdown.innerHTML = "";
    state.currentRows = [];

    let income = 0;
    let expense = 0;

    try {
      const repRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", yyyyMM);
      const repSnap = await getDoc(repRef);

      if (!repSnap.exists()) {
        coupleBreakdown.innerHTML = `<p class="muted">Sem totais para ${escapeHtml(yyyyMM)}. Adicione lançamentos nas carteiras pessoais para gerar automaticamente.</p>`;
        return { income: 0, expense: 0, balance: 0 };
      }

      const rep = repSnap.data();
      const sources = rep.sources ?? {};

      const lines = [];
      for (const [sourceWalletId, s] of Object.entries(sources)) {
        const inc = Number(s?.incomeCents || 0);
        const exp = Number(s?.expenseCents || 0);
        income += inc;
        expense += exp;
        const label = state.walletLabels.get(sourceWalletId) ?? friendlyWalletLabel(sourceWalletId);

        lines.push(`
          <div class="kpi" style="margin-top:8px;">
            <div class="label">${escapeHtml(label)}</div>
            <div class="value">${toBRL(inc - exp)}</div>
            <div class="muted">Receitas: ${toBRL(inc)} | Despesas: ${toBRL(exp)}</div>
          </div>
        `);
      }

      coupleBreakdown.innerHTML = lines.length
        ? `<div class="muted">Quebra por fonte (somado no total acima):</div>${lines.join("")}`
        : `<p class="muted">Dados consolidados disponíveis, mas sem fontes preenchidas.</p>`;

      return { income, expense, balance: income - expense };
    } catch (e) {
      setOpsError("Não foi possível carregar o consolidado agora. Tente novamente.");
      coupleBreakdown.innerHTML = `<p class="err">Falha ao carregar o consolidado.</p>`;
      return { income: 0, expense: 0, balance: 0 };
    }
  }

  async function loadCoupleDetails(startTS, endTS) {
    const monthKey = formatMonthKey(startTS?.toDate?.() ?? startTS);
    try {
      const qRef = query(
        collection(db, "wallets", COUPLE_WALLET_ID, "transactions_view"),
        where("date", ">=", startTS),
        where("date", "<", endTS),
        orderBy("date", "desc")
      );

      const snaps = await getDocs(qRef);
      const rows = [];
      let income = 0, expense = 0;

      for (const d of snaps.docs) {
        const t = normalizeTxn(d.data());
        const docMonthKey = t.monthKey || formatMonthKey(t.date?.toDate?.() ?? t.date);
        if (monthKey && docMonthKey && docMonthKey !== monthKey) continue;
        const amount = Number(t.amountCents || 0);
        if (t.type === "income") income += amount;
        else expense += amount;
        const sourceLabel = t.sourceWalletId ? `Fonte: ${friendlyWalletLabel(t.sourceWalletId, state.walletLabels.get(t.sourceWalletId))}` : "";

        const status = t.status ?? (t.planId ? "scheduled" : "");
        rows.push({
          id: d.id,
          date: t.date?.toDate?.() ?? null,
          purchaseDate: t.purchaseDate?.toDate?.() ?? null,
          monthKey: docMonthKey,
          categoryName: t.categoryName ?? "",
          note: t.note ?? "",
          type: t.type ?? "",
          amountCents: amount,
          sourceLabel,
          planId: t.planId ?? "",
          planType: t.planType ?? "",
          occurrenceIndex: t.occurrenceIndex ?? null,
          occurrenceTotal: t.occurrenceTotal ?? null,
          status,
          paymentMethod: t.paymentMethod ?? "",
          creditCardId: t.creditCardId ?? "",
          creditCardNameSnapshot: t.creditCardNameSnapshot ?? "",
          invoiceMonth: t.invoiceMonth ?? t.statementMonth ?? "",
          statementMonth: t.statementMonth ?? "",
          recurring: t.recurring ?? { isRecurring: false, cadence: "none" }
        });
      }

      state.currentRows = rows;
      renderTxnRows(rows, { allowDelete: false, isCoupleView: true, allowEdit: false });
      coupleBreakdown.style.display = "none";

      return { income, expense, balance: income - expense };
    } catch (e) {
      setOpsError("Não foi possível carregar os detalhes do consolidado.");
      txnTable.innerHTML = "";
      return { income: 0, expense: 0, balance: 0 };
    }
  }

  async function loadTransactionsForMonth() {
    txnTable.innerHTML = "";
    txnStatus.textContent = "";
    setOpsError("");
    state.currentRows = [];
    renderDashboardMovements([]);
    dashboardStatus.textContent = "";

    let yyyyMM = yyyyMMFromMonthInput(monthInput.value);
    if (!yyyyMM) {
      yyyyMM = currentYYYYMM();
      if (yyyyMM) {
        monthInput.value = yyyyMM;
        syncMonthLabel();
      }
    }
    if (!yyyyMM) { setOpsError("Selecione um mês válido."); return { income: 0, expense: 0, balance: 0 }; }

    const { start, end } = startEndForMonth(yyyyMM);
    const startTS = Timestamp.fromDate(start);
    const endTS = Timestamp.fromDate(end);

    if (isCoupleWallet()) {
      if (state.coupleTab === "totals") {
        const totals = await loadCoupleTotals(yyyyMM);
        renderKPIs(totals.income, totals.expense);
        txnStatus.textContent = "Totais consolidados carregados.";
        renderDashboardMovements([]);
        dashboardStatus.textContent = "Use a aba Detalhes para ver os lançamentos.";
        return totals;
      } else {
        const totals = await loadCoupleDetails(startTS, endTS);
        renderKPIs(totals.income, totals.expense);
        txnStatus.textContent = "Detalhes consolidados carregados.";
        renderDashboardMovements(state.currentRows);
        dashboardStatus.textContent = state.currentRows.length ? "Movimentações consolidadas do mês." : "Sem lançamentos neste mês.";
        return totals;
      }
    }

    let income = 0;
    let expense = 0;

    try {
      const qRef = query(
        collection(db, "wallets", state.walletId, "transactions"),
        where("date", ">=", startTS),
        where("date", "<", endTS),
        orderBy("date", "desc")
      );

      const snaps = await getDocs(qRef);
      const rows = [];

      for (const d of snaps.docs) {
        const t = normalizeTxn(d.data());
        const docMonthKey = t.monthKey || formatMonthKey(t.date?.toDate?.() ?? t.date);
        if (docMonthKey !== yyyyMM) continue;
        const amount = Number(t.amountCents || 0);
        if (t.type === "income") income += amount;
        else expense += amount;

        const status = t.status ?? (t.planId ? "scheduled" : "");
        rows.push({
          id: d.id,
          date: t.date?.toDate?.() ?? null,
          purchaseDate: t.purchaseDate?.toDate?.() ?? null,
          monthKey: docMonthKey,
          categoryName: t.categoryName ?? "",
          note: t.note ?? "",
          type: t.type ?? "",
          amountCents: amount,
          categoryId: t.categoryId ?? "",
          planId: t.planId ?? "",
          planType: t.planType ?? "",
          occurrenceIndex: t.occurrenceIndex ?? null,
          occurrenceTotal: t.occurrenceTotal ?? null,
          status,
          paymentMethod: t.paymentMethod ?? "",
          creditCardId: t.creditCardId ?? "",
          creditCardNameSnapshot: t.creditCardNameSnapshot ?? "",
          invoiceMonth: t.invoiceMonth ?? t.statementMonth ?? "",
          statementMonth: t.statementMonth ?? "",
          recurring: t.recurring ?? { isRecurring: false, cadence: "none" }
        });

        state.txnCache.set(d.id, {
          id: d.id,
          date: t.date?.toDate?.() ?? null,
          purchaseDate: t.purchaseDate?.toDate?.() ?? null,
          monthKey: docMonthKey,
          categoryName: t.categoryName ?? "",
          categoryId: t.categoryId ?? "",
          note: t.note ?? "",
          type: t.type ?? "",
          amountCents: amount,
          originalType: t.originalType ?? "",
          paymentMethod: t.paymentMethod ?? "outro",
          recurring: t.recurring ?? { isRecurring: false, cadence: "none" },
          installment: t.installment ?? { isInstallment: false, total: null, current: null },
          finance: t.finance ?? { isFinance: false, total: null, current: null },
          planId: t.planId ?? "",
          planType: t.planType ?? "",
          occurrenceIndex: t.occurrenceIndex ?? null,
          occurrenceTotal: t.occurrenceTotal ?? null,
          status,
          creditCardId: t.creditCardId ?? "",
          creditCardNameSnapshot: t.creditCardNameSnapshot ?? "",
          invoiceMonth: t.invoiceMonth ?? t.statementMonth ?? "",
          statementMonth: t.statementMonth ?? ""
        });
      }

      state.currentRows = rows;
      renderDashboardMovements(rows);
      renderTxnRows(rows, { allowDelete: true, isCoupleView: false, allowEdit: true });
      txnStatus.textContent = `Transações no mês: ${rows.length}`;
      renderKPIs(income, expense);
      dashboardStatus.textContent = rows.length ? "Movimentações do mês selecionado." : "Sem lançamentos no mês.";

      return { income, expense, balance: income - expense };
    } catch (e) {
      setOpsError("Não foi possível carregar suas movimentações. Tente novamente.");
      renderKPIs(0, 0);
      return { income: 0, expense: 0, balance: 0 };
    }
  }

  function setCreditCardOptions(selectEl, selectedId = "", emptyLabel = "Sem cartoes") {
    if (!selectEl) return;
    selectEl.innerHTML = "";
    const entries = Array.from(state.creditCards.entries())
      .map(([id, c]) => ({ id, ...c }))
      .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));

    if (entries.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = emptyLabel;
      selectEl.appendChild(opt);
      return;
    }

    let hasSelected = false;
    for (const c of entries) {
      const opt = document.createElement("option");
      opt.value = c.id;
      opt.textContent = c.name;
      if (selectedId && selectedId === c.id) hasSelected = true;
      selectEl.appendChild(opt);
    }

    if (selectedId && hasSelected) selectEl.value = selectedId;
    if (!selectedId || !hasSelected) selectEl.value = entries[0]?.id || "";
  }

  function listPersonalWalletsForMigration() {
    const ids = new Set(PERSONAL_WALLETS);
    const byEmail = USER_PERSONAL_WALLET[state.email];
    if (byEmail) ids.add(byEmail);
    return Array.from(ids);
  }

  async function migrateTxnV2Defaults() {
    if (!btnMigrateTxnV2 || !migrateStatus) return;
    migrateStatus.textContent = "Aplicando defaults v2...";
    const originalLabel = btnMigrateTxnV2.textContent;
    btnMigrateTxnV2.disabled = true;
    btnMigrateTxnV2.textContent = "Aplicando...";

    let scanned = 0;
    let updated = 0;
    let failures = 0;

    const personalWallets = listPersonalWalletsForMigration();
    for (const walletId of personalWallets) {
      try {
        migrateStatus.textContent = `Varredura: ${walletId}...`;
        const colRef = collection(db, "wallets", walletId, "transactions");
        const snaps = await getDocs(colRef);
        for (const snap of snaps.docs) {
          scanned += 1;
          const patch = buildTxnV2MergePatch(snap.data());
          if (Object.keys(patch).length === 0) continue;
          await setDoc(snap.ref, patch, { merge: true });
          updated += 1;
        }
      } catch {
        failures += 1;
      }
    }

    try {
      migrateStatus.textContent = "Varredura: casal...";
      const viewCol = collection(db, "wallets", COUPLE_WALLET_ID, "transactions_view");
      const snaps = await getDocs(viewCol);
      for (const snap of snaps.docs) {
        scanned += 1;
        const patch = buildTxnV2MergePatch(snap.data());
        if (Object.keys(patch).length === 0) continue;
        await setDoc(snap.ref, patch, { merge: true });
        updated += 1;
      }
    } catch {
      failures += 1;
    }

    const extra = failures ? ` (${failures} com erro)` : "";
    migrateStatus.textContent = `Defaults aplicados: ${updated} de ${scanned} transacoes${extra}.`;
    btnMigrateTxnV2.disabled = false;
    btnMigrateTxnV2.textContent = originalLabel;
  }

  async function reloadAll() {
    setOpsError("");
    if (!isCoupleWallet()) await loadCategories();
    else {
      state.categories.clear();
      txnCat.innerHTML = `<option value="">-</option>`;
      if (catGrid) catGrid.innerHTML = "";
      if (catStatus) catStatus.textContent = "Categorias nao disponiveis nesta carteira.";
    }
    await loadTransactionsForMonth();
  }

  // ===== Events =====

  const openMonthPickerCurrent = () => {
    const cur = currentYYYYMM() || yyyyMMFromDateStr(toISODateLocal(currentDateInTZ()));
    if (cur) monthInput.value = cur;
    syncMonthLabel();
    reloadAll();
  };

  const openMonthPickerInline = () => {
    if (!monthInput) return;
    try {
      if (typeof monthInput.showPicker === "function") {
        monthInput.showPicker();
        return;
      }
    } catch {}
    monthInput.focus({ preventScroll: true });
    monthInput.click();
  };

  if (loginForm) loginForm.addEventListener("submit", (e) => {
    e.preventDefault();
    loginEmailPassword();
  });
  if (btnGoogle) btnGoogle.addEventListener("click", loginGoogle);
  if (btnForgot) btnForgot.addEventListener("click", resetPassword);
  if (btnLogout) btnLogout.addEventListener("click", logout);
  if (btnCloseEdit) btnCloseEdit.addEventListener("click", closeEditModal);
  if (btnSaveEdit) btnSaveEdit.addEventListener("click", updateTransactionPersonalAndSync);
  if (btnCloseCardEdit) btnCloseCardEdit.addEventListener("click", closeEditCardModal);
  if (btnSaveCardEdit) btnSaveCardEdit.addEventListener("click", saveCardEdits);
  if (editModal) editModal.addEventListener("click", (e) => {
    if (e.target === editModal) closeEditModal();
  });
  if (editCardModal) editCardModal.addEventListener("click", (e) => {
    if (e.target === editCardModal) closeEditCardModal();
  });
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && editModal && !editModal.hidden) closeEditModal();
    if (e.key === "Escape" && editCardModal && !editCardModal.hidden) closeEditCardModal();
  });

  walletSelect.addEventListener("change", refreshWalletContext);
  monthInput.addEventListener("change", reloadAll);
  monthInput.addEventListener("change", syncMonthLabel);

  if (btnMonthPrev) btnMonthPrev.addEventListener("click", () => shiftMonth(-1));
  if (btnMonthNext) btnMonthNext.addEventListener("click", () => shiftMonth(1));
  if (btnMonthPicker) btnMonthPicker.addEventListener("click", openMonthPickerCurrent);
  if (monthDisplay) monthDisplay.addEventListener("click", openMonthPickerInline);

  btnAddCat.addEventListener("click", addCategory);
  btnSeedCats.addEventListener("click", seedDefaultCategories);
  btnAddTxn.addEventListener("click", addTransaction);
  if (btnMigrateTxnV2) btnMigrateTxnV2.addEventListener("click", migrateTxnV2Defaults);
  txnType.addEventListener("change", syncOptionalFields);
  cbInstallment.addEventListener("change", syncOptionalFields);
  cbFinance.addEventListener("change", syncOptionalFields);
  if (installmentCurrent) installmentCurrent.addEventListener("input", syncOptionalFields);
  if (financeCurrent) financeCurrent.addEventListener("input", syncOptionalFields);
  if (txnPayment) txnPayment.addEventListener("change", syncCreditTxnFields);
  if (txnCard) txnCard.addEventListener("change", syncCreditTxnFields);
  if (txnDate) txnDate.addEventListener("change", syncCreditTxnFields);
  if (planType) planType.addEventListener("change", syncPlanFields);
  if (planPaymentMethod) planPaymentMethod.addEventListener("change", syncPlanFields);
  if (planCreditCard) planCreditCard.addEventListener("change", syncPlanFields);
  if (planPurchaseDate) planPurchaseDate.addEventListener("change", syncPlanFields);
  if (btnCreatePlan) btnCreatePlan.addEventListener("click", createPlanAndGenerate);
  if (btnAddCard) btnAddCard.addEventListener("click", addCreditCard);
  if (statementCard) statementCard.addEventListener("change", loadStatements);

  navButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const target = btn.getAttribute("data-page-target");
      if (!target) return;
      navigate(`#/app/${target}`);
    });
  });
  if (sidebarToggle && appShell) {
    sidebarToggle.addEventListener("click", () => {
      const collapsed = appShell.classList.toggle("collapsed");
      sidebarToggle.setAttribute("aria-pressed", collapsed ? "true" : "false");
    });
  }

  coupleTabs.addEventListener("click", async (e) => {
    const btn = e.target?.closest?.("button[data-tab]");
    if (!btn) return;

    coupleTabs.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
    btn.classList.add("active");

    state.coupleTab = btn.getAttribute("data-tab") || "totals";
    syncCoupleTabs();
    await reloadAll();
  });

  (function initDates() {
    const cur = currentYYYYMM() || yyyyMMFromDateStr(toISODateLocal(currentDateInTZ()));
    const nowLocal = currentDateInTZ();
    if (cur) monthInput.value = cur;
    txnDate.value = toISODateLocal(nowLocal);
    if (planStartMonth && cur) planStartMonth.value = cur;
    if (planPurchaseDate) planPurchaseDate.value = toISODateLocal(nowLocal);
    if (planPaymentMethod) planPaymentMethod.value = "outro";
    syncMonthLabel();
    syncOptionalFields();
    syncCreditTxnFields();
    syncPlanFields();
  })();

  initSortControls();

  setView("loading");
  window.addEventListener("hashchange", renderRoute);

  onAuthStateChanged(auth, async (user) => {
    setAuthMessage("");
    setAppError("");
    setOpsError("");
    authReady = true;

    if (!user) {
      resetSessionState();
      renderRoute();
      return;
    }

    try {
      await bootstrapUser(user);
      renderRoute();
    } catch (e) {
      resetSessionState();
      const msg = e?.message?.toLowerCase?.() || "";
      const friendly = msg.includes("autoriz")
        ? "Conta nao autorizada."
        : "Nao foi possivel iniciar a sessao. Tente novamente.";
      setAuthMessage(friendly, true);
      renderRoute();
    }
  });

  renderRoute();


</script>

</body>
</html>
