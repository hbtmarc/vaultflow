<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VaultFlow</title>
  
  <style>
    :root {
      color-scheme: light;
      --bg: #0f172a;
      --surface: #0b1222;
      --card: #0f172a;
      --muted: #98a2b3;
      --line: #1f2a44;
      --primary: #7c3aed;
      --primary-strong: #6d28d9;
      --success: #22c55e;
      --error: #ef4444;
      --shadow: 0 24px 60px rgba(0, 0, 0, 0.35);
    }

    body {
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial;
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 10% 20%, rgba(124, 58, 237, 0.12), transparent 30%),
        radial-gradient(circle at 80% 0%, rgba(14, 165, 233, 0.18), transparent 28%),
        linear-gradient(160deg, #0b1020 0%, #0f172a 50%, #0a0f1c 100%);
      color: #f8fafc;
    }

    h1,
    h2,
    h3 {
      margin: 0 0 12px;
      letter-spacing: -0.02em;
    }

    p {
      margin: 6px 0;
    }

    .muted {
      color: var(--muted);
    }

    .ok {
      color: var(--success);
    }

    .err {
      color: var(--error);
      white-space: pre-wrap;
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px 28px 46px;
    }

    .glass {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .grid.cols2 {
      grid-template-columns: 1fr 1fr;
    }

    .grid.cols3 {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    @media (max-width: 980px) {
      .grid.cols2,
      .grid.cols3 {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: rgba(15, 23, 42, 0.86);
      border: 1px solid rgba(255, 255, 255, 0.04);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    input,
    select {
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      min-width: 220px;
      background: rgba(255, 255, 255, 0.02);
      color: #e5e7eb;
    }

    input::placeholder,
    select:invalid {
      color: var(--muted);
    }

    input[type="month"],
    input[type="date"] {
      min-width: 170px;
    }

    button {
      padding: 11px 14px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: linear-gradient(120deg, var(--primary-strong), var(--primary));
      color: #f8fafc;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: -0.01em;
      box-shadow: 0 10px 30px rgba(124, 58, 237, 0.35);
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.04);
      border-color: rgba(255, 255, 255, 0.1);
      box-shadow: none;
    }

    button.ghost {
      background: transparent;
      border-color: rgba(255, 255, 255, 0.12);
      color: #e5e7eb;
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    hr {
      border: none;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      margin: 14px 0;
    }

    .pill {
      display: inline-flex;
      padding: 4px 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      font-size: 12px;
      color: #e5e7eb;
      background: rgba(255, 255, 255, 0.04);
      align-items: center;
      gap: 6px;
    }

    .pill.dot::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22c55e;
      display: inline-block;
    }

    .kpi {
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: radial-gradient(circle at 0% 0%, rgba(124, 58, 237, 0.08), transparent 45%), rgba(255, 255, 255, 0.02);
    }

    .kpi .label {
      font-size: 12px;
      color: var(--muted);
    }

    .kpi .value {
      font-size: 20px;
      font-weight: 700;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      padding: 10px 8px;
      text-align: left;
      vertical-align: top;
    }

    th {
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    td {
      font-size: 14px;
      color: #e5e7eb;
    }

    .right {
      text-align: right;
    }

    .nowrap {
      white-space: nowrap;
    }

    .tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .tab {
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.02);
      cursor: pointer;
      font-size: 13px;
      color: #e5e7eb;
    }

    .tab.active {
      border-color: var(--primary);
      background: rgba(124, 58, 237, 0.08);
      font-weight: 700;
    }

    .badge {
      font-size: 12px;
      border-radius: 12px;
      padding: 6px 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
      color: #e5e7eb;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(5, 10, 25, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      backdrop-filter: blur(4px);
    }

    .modal {
      background: #0f172a;
      border-radius: 16px;
      padding: 16px;
      max-width: 620px;
      width: 100%;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 18px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .brand-badge {
      width: 36px;
      height: 36px;
      border-radius: 12px;
      background: linear-gradient(140deg, #22c55e, #0ea5e9);
      display: grid;
      place-items: center;
      font-weight: 800;
      color: #0b1222;
      box-shadow: 0 10px 40px rgba(14, 165, 233, 0.45);
    }

    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
  </style>

</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="brand-badge">VF</div>
      <div>
        <h1>VaultFlow</h1>
        <p class="muted">Controle financeiro seguro, multi-wallet e pronto para o casal.</p>
      </div>
    </div>
    <div class="toolbar">
      <span class="pill dot">Status ativo</span>
      <span class="pill" id="envPill">vaultflow-dev-marc35</span>
      <span class="pill" id="autoPill">Auto-sync Casal: ON</span>
    </div>
  </div>

  <div class="card glass" id="authCard" style="margin-top:4px;">
    <div class="row" style="justify-content: space-between; gap: 16px;">
      <div>
        <h2>Acesso</h2>
        <p class="muted">Entre com email/senha ou Google para continuar.</p>
      </div>
      <div class="pill" id="authStatus" style="min-width: 160px; justify-content: center;">Aguardando login</div>
    </div>
    <div class="row" style="margin-top:10px;">
      <input id="email" type="email" placeholder="email" autocomplete="username" />
      <input id="pass" type="password" placeholder="senha" autocomplete="current-password" />
    </div>
    <div class="row" style="margin-top:12px;">
      <button id="btnEmail">Entrar com Email/Senha</button>
      <button id="btnGoogle" class="secondary">Entrar com Google</button>
      <button id="btnLogout" class="ghost" style="display:none;">Sair</button>
    </div>
    <p id="authError" class="err"></p>
  </div>

  <div class="grid cols2" style="margin-top:16px; display:none;" id="appGrid">
    <div class="card glass">
      <h2>Contexto</h2>
      <div class="row">
        <div style="min-width: 320px;">
          <div class="muted">Usuário</div>
          <div id="me"></div>
          <div class="muted mono" id="uidLine"></div>
        </div>
        <div style="min-width: 320px;">
          <div class="muted">Wallet</div>
          <select id="walletSelect"></select>
          <div style="margin-top:8px;">
            <span class="badge" id="walletRoleBadge">role: -</span>
            <span class="badge" id="walletTypeBadge">type: -</span>
          </div>
        </div>
      </div>

      <hr />

      <div class="row">
        <div>
          <div class="muted">Mês</div>
          <input id="month" type="month" />
        </div>
        <div style="display:flex; gap:8px; align-items:flex-end;">
          <button id="btnReload" class="secondary">Recarregar</button>
        </div>
      </div>

      <p class="muted" id="walletInfo" style="margin-top:10px;"></p>
      <p class="err" id="appError"></p>

      <div class="tabs" id="coupleTabs" style="display:none;">
        <button class="tab active" data-tab="totals">Totais</button>
        <button class="tab" data-tab="details">Detalhes</button>
      </div>

      <div id="coupleHint" class="muted" style="display:none; margin-top:10px;">
        Casal é automático: ao adicionar/excluir transações nas wallets pessoais, os totais e detalhes do casal são atualizados.
      </div>

      <div style="margin-top:12px;" class="grid cols3" id="kpis">
        <div class="kpi">
          <div class="label">Receitas</div>
          <div class="value" id="kpiIncome">R$ 0,00</div>
        </div>
        <div class="kpi">
          <div class="label">Despesas</div>
          <div class="value" id="kpiExpense">R$ 0,00</div>
        </div>
        <div class="kpi">
          <div class="label">Saldo</div>
          <div class="value" id="kpiBalance">R$ 0,00</div>
        </div>
      </div>

      <div id="coupleBreakdown" style="display:none; margin-top:10px;"></div>
    </div>

    <div class="card glass">
      <h2>Operações</h2>

      <div id="personalOps">
        <h3>Categorias</h3>
        <div class="row">
          <input id="catName" placeholder="Nome da categoria" />
          <select id="catKind">
            <option value="expense">Despesa</option>
            <option value="income">Receita</option>
            <option value="both">Ambos</option>
          </select>
          <button id="btnAddCat">Adicionar</button>
          <button id="btnSeedCats" class="ghost">Criar categorias padrão</button>
        </div>
        <div class="muted" id="catStatus" style="margin-top:8px;"></div>
        <div style="margin-top:10px; max-height: 180px; overflow:auto; border:1px solid #eee; border-radius:12px;">
          <table>
            <thead>
              <tr><th>Nome</th><th>Tipo</th><th class="right">Ações</th></tr>
            </thead>
            <tbody id="catTable"></tbody>
          </table>
        </div>

        <hr />

        <h3>Transações</h3>
        <p class="muted" style="margin-top:-6px;">
          Ao adicionar/excluir transações nesta wallet pessoal, o Casal é atualizado automaticamente (reports + transactions_view).
        </p>
        <div class="row">
          <input id="txnDate" type="date" />
          <select id="txnType">
            <option value="expense">Despesa</option>
            <option value="income">Receita</option>
          </select>
          <select id="txnCat"></select>
        </div>
        <div class="row" style="margin-top:10px;">
          <input id="txnAmount" placeholder="Valor (ex: 35,90)" />
          <input id="txnNote" placeholder="Observação (opcional)" style="min-width: 420px; flex:1;" />
          <button id="btnAddTxn">Adicionar</button>
        </div>
      </div>

      <div id="coupleOps" style="display:none;">
        <h3>Casal (agregado)</h3>
        <p class="muted">
          Totais vêm de <span class="mono">reports</span>. Detalhes vêm de <span class="mono">transactions_view</span>.
          Ambos são atualizados automaticamente quando Marcelino/Luiza adicionam/excluem transações nas wallets pessoais.
        </p>
      </div>

      <hr />

      <h3>Lista do mês</h3>
      <div style="max-height: 330px; overflow:auto; border:1px solid #eee; border-radius:12px;">
        <table>
          <thead>
            <tr>
              <th class="nowrap">Data</th>
              <th>Categoria</th>
              <th>Descrição</th>
              <th class="right nowrap">Valor</th>
              <th class="right nowrap">Ações</th>
            </tr>
          </thead>
          <tbody id="txnTable"></tbody>
        </table>
      </div>

      <div class="muted" id="txnStatus" style="margin-top:10px;"></div>
      <p class="err" id="opsError"></p>
    </div>

    <div class="card glass">
      <h2>Diagnóstico</h2>
      <p class="muted">Verifica consistência de memberships entre <span class="mono">wallets/*/members</span> e <span class="mono">users/*/memberships</span>.</p>
      <div class="grid cols2" style="margin-top:10px;">
        <div>
          <div class="muted">Wallet atual</div>
          <div id="diagWallet">-</div>
          <div class="muted" style="margin-top:6px;">Role: <span class="mono" id="diagRole">-</span> | Tipo: <span class="mono" id="diagType">-</span></div>
        </div>
        <div>
          <div class="muted">Status</div>
          <div id="diagMemberStatus" class="mono">—</div>
          <div id="diagMembershipStatus" class="mono" style="margin-top:4px;">—</div>
        </div>
      </div>
      <div class="row" style="margin-top:12px;">
        <button id="btnRunDiag" class="secondary">Reavaliar</button>
        <button id="btnReconcile" class="ghost">Reconciliar memberships</button>
        <span class="muted" id="diagActionStatus"></span>
      </div>
      <p class="err" id="diagError"></p>
    </div>
  </div>
</div>

<div class="modal-backdrop" id="editModal">
  <div class="modal">
    <h3>Editar transação</h3>
    <p class="muted" id="editHelper"></p>
    <div class="row" style="margin-top:8px;">
      <input id="editTxnDate" type="date" />
      <select id="editTxnType">
        <option value="expense">Despesa</option>
        <option value="income">Receita</option>
      </select>
      <select id="editTxnCat"></select>
    </div>
    <div class="row" style="margin-top:10px;">
      <input id="editTxnAmount" placeholder="Valor (ex: 35,90)" />
      <input id="editTxnNote" placeholder="Observação (opcional)" style="min-width: 420px; flex:1;" />
    </div>
    <div class="row" style="margin-top:12px; justify-content:flex-end; gap:8px;">
      <button id="btnCloseEdit" class="ghost">Cancelar</button>
      <button id="btnSaveEdit">Salvar alterações</button>
    </div>
    <div class="muted" id="editStatus" style="margin-top:8px;"></div>
    <p class="err" id="editError"></p>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js";

  import {
    getAuth,
    onAuthStateChanged,
    signInWithEmailAndPassword,
    GoogleAuthProvider,
    signInWithPopup,
    signOut
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

  import {
    getFirestore,
    Timestamp,
    doc,
    getDoc,
    setDoc,
    deleteDoc,
    collection,
    getDocs,
    addDoc,
    query,
    where,
    orderBy,
    serverTimestamp,
    runTransaction
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

  // Firebase Config (VaultFlow-Dev / vaultflow-dev-marc35)
  const firebaseConfig = {
    apiKey: "AIzaSyDIXLjoqxDQrDr7rhxfBjCBzsXZUycTWD0",
    authDomain: "vaultflow-dev-marc35.firebaseapp.com",
    projectId: "vaultflow-dev-marc35",
    storageBucket: "vaultflow-dev-marc35.firebasestorage.app",
    messagingSenderId: "806046110940",
    appId: "1:806046110940:web:aab0a3245bb304e14b9019",
    measurementId: "G-CMZTW66KS9"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Allowlist (somente vocês 3)
  const ALLOWED_EMAILS = new Set([
    "hbmarc35@gmail.com",
    "lzmarc25@gmail.com",
    "herbertmarck@gmail.com"
  ]);

  const COUPLE_WALLET_ID = "w_casal";
  const PERSONAL_WALLETS = new Set(["w_marcelino", "w_luiza"]);
  const KNOWN_WALLETS = ["w_marcelino", "w_luiza", "w_casal"];

  const $ = (id) => document.getElementById(id);

  const btnEmail = $("btnEmail");
  const btnGoogle = $("btnGoogle");
  const btnLogout = $("btnLogout");

  const authStatus = $("authStatus");
  const authError = $("authError");

  const appGrid = $("appGrid");

  const me = $("me");
  const uidLine = $("uidLine");

  const walletSelect = $("walletSelect");
  const walletRoleBadge = $("walletRoleBadge");
  const walletTypeBadge = $("walletTypeBadge");
  const walletInfo = $("walletInfo");

  const monthInput = $("month");
  const btnReload = $("btnReload");

  const kpiIncome = $("kpiIncome");
  const kpiExpense = $("kpiExpense");
  const kpiBalance = $("kpiBalance");
  const coupleBreakdown = $("coupleBreakdown");

  const coupleTabs = $("coupleTabs");
  const coupleHint = $("coupleHint");

  const personalOps = $("personalOps");
  const coupleOps = $("coupleOps");

  const catName = $("catName");
  const catKind = $("catKind");
  const btnAddCat = $("btnAddCat");
  const btnSeedCats = $("btnSeedCats");
  const catStatus = $("catStatus");
  const catTable = $("catTable");

  const txnDate = $("txnDate");
  const txnType = $("txnType");
  const txnCat = $("txnCat");
  const txnAmount = $("txnAmount");
  const txnNote = $("txnNote");
  const btnAddTxn = $("btnAddTxn");

  const txnTable = $("txnTable");
  const txnStatus = $("txnStatus");

  const appError = $("appError");
  const opsError = $("opsError");

  const diagWallet = $("diagWallet");
  const diagRole = $("diagRole");
  const diagType = $("diagType");
  const diagMemberStatus = $("diagMemberStatus");
  const diagMembershipStatus = $("diagMembershipStatus");
  const diagActionStatus = $("diagActionStatus");
  const diagError = $("diagError");
  const btnRunDiag = $("btnRunDiag");
  const btnReconcile = $("btnReconcile");

  const editModal = $("editModal");
  const editHelper = $("editHelper");
  const editTxnDate = $("editTxnDate");
  const editTxnType = $("editTxnType");
  const editTxnCat = $("editTxnCat");
  const editTxnAmount = $("editTxnAmount");
  const editTxnNote = $("editTxnNote");
  const btnCloseEdit = $("btnCloseEdit");
  const btnSaveEdit = $("btnSaveEdit");
  const editStatus = $("editStatus");
  const editError = $("editError");

  const state = {
    user: null,
    email: null,
    uid: null,
    walletId: null,
    walletRole: null,
    walletType: null,
    walletName: null,
    coupleTab: "totals",
    categories: new Map(), // catId -> {name, kind}
    txnCache: new Map(),
    editingTxnId: null
  };

  function setAuthMessage(msg, isError = false) {
    authStatus.textContent = isError ? "" : msg;
    authError.textContent = isError ? msg : "";
  }
  function setAppError(msg = "") { appError.textContent = msg; }
  function setOpsError(msg = "") { opsError.textContent = msg; }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function toBRL(cents) {
    const v = (Number(cents || 0) / 100);
    return v.toLocaleString("pt-BR", { style: "currency", currency: "BRL" });
  }

  function parseAmountToCents(text) {
    const clean = (text ?? "").trim().replace(/\./g, "").replace(",", ".");
    const n = Number(clean);
    if (!Number.isFinite(n)) return null;
    return Math.round(n * 100);
  }

  function formatCentsToInputValue(cents) {
    const v = Number(cents || 0) / 100;
    return v.toFixed(2).replace(".", ",");
  }

  function yyyyMMFromMonthInput(value) {
    if (!value || !/^\d{4}-\d{2}$/.test(value)) return null;
    return value;
  }

  function yyyyMMFromDateStr(dateStr) {
    if (!dateStr || dateStr.length < 7) return null;
    return dateStr.slice(0, 7);
  }

  function yyyyMMFromTimestamp(ts) {
    try {
      const d = ts?.toDate?.();
      if (!d) return null;
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      return `${d.getFullYear()}-${mm}`;
    } catch { return null; }
  }

  function startEndForMonth(yyyyMM) {
    const [y, m] = yyyyMM.split("-").map(Number);
    const start = new Date(Date.UTC(y, m - 1, 1, 0, 0, 0));
    const end = new Date(Date.UTC(y, m, 1, 0, 0, 0));
    return { start, end };
  }

  function toISODateLocal(d) {
    const pad = (x) => String(x).padStart(2, "0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  }

  function setCategoryOptions(selectEl, selectedId = "", fallbackLabel = "") {
    selectEl.innerHTML = "";

    if (state.categories.size === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "Sem categorias (crie uma)";
      selectEl.appendChild(opt);
    } else {
      for (const [id, c] of state.categories.entries()) {
        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = c.name;
        selectEl.appendChild(opt);
      }
    }

    if (selectedId && !state.categories.has(selectedId)) {
      const opt = document.createElement("option");
      opt.value = selectedId;
      opt.textContent = fallbackLabel || `Categoria ${selectedId}`;
      selectEl.appendChild(opt);
    }

    if (selectedId) selectEl.value = selectedId;
  }

  function renderKPIs(incomeCents, expenseCents) {
    const bal = Number(incomeCents || 0) - Number(expenseCents || 0);
    kpiIncome.textContent = toBRL(incomeCents);
    kpiExpense.textContent = toBRL(expenseCents);
    kpiBalance.textContent = toBRL(bal);
  }

  function isCoupleWallet() {
    return state.walletId === COUPLE_WALLET_ID && state.walletType === "aggregate";
  }

  function isPersonalWalletId(walletId) {
    return PERSONAL_WALLETS.has(walletId);
  }

  function openEditModal(txnId) {
    state.editingTxnId = txnId;
    editError.textContent = "";
    editStatus.textContent = "";
    editHelper.textContent = `Wallet: ${state.walletId} | ID: ${txnId}`;
    editModal.style.display = "flex";
  }

  function closeEditModal() {
    state.editingTxnId = null;
    editModal.style.display = "none";
    editStatus.textContent = "";
    editError.textContent = "";
  }

  // ===== Bootstrap =====

  async function ensureUserProfile(user) {
    const ref = doc(db, "users", user.uid);
    const snap = await getDoc(ref);
    if (!snap.exists()) {
      await setDoc(ref, {
        displayName: user.displayName ?? (user.email?.split("@")[0] ?? "Usuário"),
        email: (user.email ?? "").toLowerCase(),
        createdAt: Timestamp.now()
      }, { merge: true });
    } else {
      await setDoc(ref, {
        email: (user.email ?? "").toLowerCase(),
        displayName: snap.data().displayName ?? user.displayName ?? "Usuário"
      }, { merge: true });
    }
  }

  async function ensureWalletMetaIfOwner(user) {
    const email = (user.email ?? "").toLowerCase();
    const uid = user.uid;

    const isMarcelino = email === "hbmarc35@gmail.com";
    const isLuiza = email === "lzmarc25@gmail.com";

    async function upsertWallet(walletId, dataIfCreate, dataMerge) {
      const wRef = doc(db, "wallets", walletId);
      const wSnap = await getDoc(wRef);
      if (!wSnap.exists()) {
        await setDoc(wRef, dataIfCreate, { merge: false });
      } else {
        await setDoc(wRef, dataMerge, { merge: true });
      }
    }

    if (isMarcelino) {
      await upsertWallet(
        "w_marcelino",
        { name: "Marcelino (Pessoal)", type: "personal", createdBy: uid, createdAt: Timestamp.now() },
        { name: "Marcelino (Pessoal)", type: "personal" }
      );
    }

    if (isLuiza) {
      await upsertWallet(
        "w_luiza",
        { name: "Luiza (Pessoal)", type: "personal", createdBy: uid, createdAt: Timestamp.now() },
        { name: "Luiza (Pessoal)", type: "personal" }
      );
    }

    if (isMarcelino || isLuiza) {
      const srcRefs = [
        doc(db, "wallets", "w_marcelino"),
        doc(db, "wallets", "w_luiza")
      ];
      await upsertWallet(
        "w_casal",
        {
          name: "Casal (Agregado)",
          type: "aggregate",
          createdBy: uid,
          createdAt: Timestamp.now(),
          sources: srcRefs
        },
        {
          name: "Casal (Agregado)",
          type: "aggregate",
          sources: srcRefs
        }
      );
    }
  }

  async function ensureMembershipShortcutsFromMembers(user) {
    const membershipCol = collection(db, "users", user.uid, "memberships");
    const existing = await getDocs(membershipCol);
    if (existing.size > 0) return;

    for (const walletId of KNOWN_WALLETS) {
      try {
        const mRef = doc(db, "wallets", walletId, "members", user.uid);
        const mSnap = await getDoc(mRef);
        if (!mSnap.exists()) continue;

        const role = mSnap.data().role;
        await setDoc(doc(db, "users", user.uid, "memberships", walletId), {
          role,
          createdAt: Timestamp.now()
        }, { merge: true });
      } catch {
        // ignore
      }
    }
  }

  async function loadWalletOptions(user) {
    const membershipCol = collection(db, "users", user.uid, "memberships");
    const snaps = await getDocs(membershipCol);
    const list = snaps.docs.map(d => ({ walletId: d.id, role: d.data().role }));

    walletSelect.innerHTML = "";
    for (const item of list) {
      let label = item.walletId;
      let type = "?";
      try {
        const wSnap = await getDoc(doc(db, "wallets", item.walletId));
        if (wSnap.exists()) {
          label = wSnap.data().name ?? item.walletId;
          type = wSnap.data().type ?? "?";
        }
      } catch {}

      const opt = document.createElement("option");
      opt.value = item.walletId;
      opt.textContent = `${label} (${item.role})`;
      walletSelect.appendChild(opt);
    }
    return list;
  }

  async function refreshWalletContext() {
    setAppError("");
    setOpsError("");

    const walletId = walletSelect.value;
    if (!walletId) {
      setAppError("Nenhuma wallet encontrada para este usuário.");
      return;
    }

    let role = null;
    try {
      const mSnap = await getDoc(doc(db, "users", state.uid, "memberships", walletId));
      role = mSnap.exists() ? mSnap.data().role : null;
    } catch {}

    let name = walletId;
    let type = "?";
    try {
      const wSnap = await getDoc(doc(db, "wallets", walletId));
      if (wSnap.exists()) {
        name = wSnap.data().name ?? walletId;
        type = wSnap.data().type ?? "?";
      }
    } catch (e) {
      setAppError(`Não foi possível ler a wallet: ${e?.message ?? e}`);
    }

    state.walletId = walletId;
    state.walletRole = role ?? "-";
    state.walletType = type;
    state.walletName = name;

    walletRoleBadge.textContent = `role: ${state.walletRole}`;
    walletTypeBadge.textContent = `type: ${state.walletType}`;
    walletInfo.textContent = `Wallet: ${state.walletName} | id: ${state.walletId} | type: ${state.walletType}`;

    const couple = isCoupleWallet();
    coupleTabs.style.display = couple ? "" : "none";
    coupleHint.style.display = couple ? "" : "none";
    coupleBreakdown.style.display = couple ? "" : "none";

    personalOps.style.display = couple ? "none" : "";
    coupleOps.style.display = couple ? "" : "none";

    const now = new Date();
    txnDate.value = toISODateLocal(now);

    await reloadAll();
    await runDiagnostics();
  }

  async function runDiagnostics() {
    diagError.textContent = "";

    if (!state.walletId) {
      diagError.textContent = "Selecione uma wallet para avaliar.";
      return;
    }

    diagWallet.textContent = `${state.walletName} (${state.walletId})`;
    diagRole.textContent = state.walletRole ?? "-";
    diagType.textContent = state.walletType ?? "-";

    try {
      const memberRef = doc(db, "wallets", state.walletId, "members", state.uid);
      const memberSnap = await getDoc(memberRef);
      const memberRole = memberSnap.exists() ? (memberSnap.data()?.role ?? "-") : null;

      const membershipRef = doc(db, "users", state.uid, "memberships", state.walletId);
      const membershipSnap = await getDoc(membershipRef);
      const membershipRole = membershipSnap.exists() ? (membershipSnap.data()?.role ?? "-") : null;

      if (memberSnap.exists()) {
        diagMemberStatus.textContent = `OK: wallets/${state.walletId}/members/${state.uid} (role: ${memberRole})`;
      } else {
        diagMemberStatus.textContent = `FALHA: wallets/${state.walletId}/members/${state.uid} ausente.`;
      }

      if (!membershipSnap.exists()) {
        diagMembershipStatus.textContent = `FALHA: users/${state.uid}/memberships/${state.walletId} ausente.`;
      } else if (memberRole && membershipRole && memberRole !== membershipRole) {
        diagMembershipStatus.textContent = `FALHA: role divergente (members=${memberRole}, membership=${membershipRole}).`;
      } else if (!memberSnap.exists() && membershipSnap.exists()) {
        diagMembershipStatus.textContent = `FALHA: membership existe, mas usuário não está em members.`;
      } else {
        diagMembershipStatus.textContent = `OK: membership consistente (role: ${membershipRole ?? "-"}).`;
      }
    } catch (e) {
      diagError.textContent = e?.message ?? String(e);
    }
  }

  async function reconcileMembershipsFromMembers() {
    diagError.textContent = "";
    diagActionStatus.textContent = "Reconhecendo memberships...";
    btnReconcile.disabled = true;

    try {
      for (const walletId of KNOWN_WALLETS) {
        const memberRef = doc(db, "wallets", walletId, "members", state.uid);
        const memberSnap = await getDoc(memberRef);
        const membershipRef = doc(db, "users", state.uid, "memberships", walletId);
        const membershipSnap = await getDoc(membershipRef);

        if (!memberSnap.exists()) {
          try { await deleteDoc(membershipRef); } catch {}
          continue;
        }

        const role = memberSnap.data()?.role;
        const payload = {
          role,
          updatedAt: serverTimestamp()
        };

        if (!membershipSnap.exists()) payload.createdAt = serverTimestamp();

        await setDoc(membershipRef, payload, { merge: true });
      }

      diagActionStatus.textContent = "Reconciliado com base em wallets/*/members.";
    } catch (e) {
      diagError.textContent = e?.message ?? String(e);
    } finally {
      btnReconcile.disabled = false;
      await runDiagnostics();
    }
  }

  // ===== Categories =====

  async function loadCategories() {
    state.categories.clear();
    txnCat.innerHTML = "";
    editTxnCat.innerHTML = "";

    if (isCoupleWallet()) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "—";
      txnCat.appendChild(opt);
      editTxnCat.appendChild(opt.cloneNode(true));
      catTable.innerHTML = "";
      catStatus.textContent = "Categorias: N/A na visão agregada.";
      return;
    }

    const colRef = collection(db, "wallets", state.walletId, "categories");
    const snaps = await getDocs(colRef);

    for (const d of snaps.docs) {
      const data = d.data();
      state.categories.set(d.id, { name: data.name, kind: data.kind });
    }

    setCategoryOptions(txnCat);
    setCategoryOptions(editTxnCat, editTxnCat.value);

    renderCategoriesTable();
    catStatus.textContent = `Categorias carregadas: ${state.categories.size}`;
  }

  function renderCategoriesTable() {
    catTable.innerHTML = "";
    const entries = Array.from(state.categories.entries())
      .map(([id, c]) => ({ id, ...c }))
      .sort((a, b) => (a.name ?? "").localeCompare(b.name ?? ""));

    for (const c of entries) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(c.name)}</td>
        <td><span class="badge">${escapeHtml(c.kind)}</span></td>
        <td class="right"><button class="ghost" data-del-cat="${c.id}">Excluir</button></td>
      `;
      catTable.appendChild(tr);
    }

    catTable.querySelectorAll("button[data-del-cat]").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-del-cat");
        if (!confirm("Excluir esta categoria?")) return;
        try {
          await deleteDoc(doc(db, "wallets", state.walletId, "categories", id));
          await loadCategories();
        } catch (e) {
          setOpsError(`Erro ao excluir categoria: ${e?.message ?? e}`);
        }
      });
    });
  }

  async function addCategory() {
    setOpsError("");
    const name = (catName.value ?? "").trim();
    const kind = catKind.value;

    if (!name) {
      setOpsError("Informe o nome da categoria.");
      return;
    }

    try {
      await addDoc(collection(db, "wallets", state.walletId, "categories"), {
        name,
        kind,
        createdAt: serverTimestamp(),
        createdBy: state.uid
      });
      catName.value = "";
      await loadCategories();
    } catch (e) {
      setOpsError(`Erro ao adicionar categoria: ${e?.message ?? e}`);
    }
  }

  async function seedDefaultCategories() {
    setOpsError("");
    if (!confirm("Criar categorias padrão nesta wallet?")) return;

    const defaults = [
      { name: "Alimentação", kind: "expense" },
      { name: "Transporte", kind: "expense" },
      { name: "Moradia", kind: "expense" },
      { name: "Saúde", kind: "expense" },
      { name: "Lazer", kind: "expense" },
      { name: "Compras", kind: "expense" },
      { name: "Salário", kind: "income" },
      { name: "Outras receitas", kind: "income" }
    ];

    try {
      for (const c of defaults) {
        await addDoc(collection(db, "wallets", state.walletId, "categories"), {
          ...c,
          createdAt: serverTimestamp(),
          createdBy: state.uid
        });
      }
      await loadCategories();
      catStatus.textContent = "Categorias padrão criadas.";
    } catch (e) {
      setOpsError(`Erro ao criar categorias padrão: ${e?.message ?? e}`);
    }
  }

  // ===== Auto-sync Casal (corrigido: reads antes de writes) =====

  function clampNonNegative(n) {
    n = Number(n || 0);
    return n < 0 ? 0 : n;
  }

  function computeCoupleSourceNext(repData, sourceWalletId, deltaIncomeCents, deltaExpenseCents) {
    const sources = repData?.sources ?? {};
    const cur = sources?.[sourceWalletId] ?? {};
    const curIncome = Number(cur.incomeCents || 0);
    const curExpense = Number(cur.expenseCents || 0);

    const nextIncome = clampNonNegative(curIncome + Number(deltaIncomeCents || 0));
    const nextExpense = clampNonNegative(curExpense + Number(deltaExpenseCents || 0));

    return { nextIncome, nextExpense };
  }

  async function prepareEditModal(txnId) {
    editError.textContent = "";
    editStatus.textContent = "";

    if (!isPersonalWalletId(state.walletId)) {
      editError.textContent = "Edição só é permitida em wallets pessoais.";
      return;
    }

    let txn = state.txnCache.get(txnId);
    if (!txn) {
      try {
        const snap = await getDoc(doc(db, "wallets", state.walletId, "transactions", txnId));
        if (snap.exists()) {
          const data = snap.data();
          txn = {
            id: txnId,
            date: data.date?.toDate?.() ?? null,
            amountCents: Number(data.amountCents || 0),
            type: data.type ?? "expense",
            categoryId: data.categoryId ?? "",
            categoryName: data.categoryName ?? "",
            note: data.note ?? ""
          };
        }
      } catch (e) {
        editError.textContent = e?.message ?? String(e);
        return;
      }
    }

    if (!txn) {
      editError.textContent = "Transação não encontrada para edição.";
      return;
    }

    if (txn.date) editTxnDate.value = toISODateLocal(txn.date);
    editTxnType.value = txn.type || "expense";
    setCategoryOptions(editTxnCat, txn.categoryId || "", txn.categoryName || "Categoria removida");
    editTxnAmount.value = formatCentsToInputValue(txn.amountCents);
    editTxnNote.value = txn.note || "";

    openEditModal(txnId);
  }

  async function addTransaction() {
    setOpsError("");

    if (isCoupleWallet()) {
      setOpsError("Não é possível lançar transações diretamente na visão agregada (Casal).");
      return;
    }

    const dateStr = txnDate.value;
    if (!dateStr) { setOpsError("Informe a data."); return; }

    const type = txnType.value;
    const catId = txnCat.value;
    if (!catId) { setOpsError("Selecione uma categoria."); return; }

    const amountCents = parseAmountToCents(txnAmount.value);
    if (amountCents == null || amountCents <= 0) {
      setOpsError("Informe um valor válido (maior que zero).");
      return;
    }

    const note = (txnNote.value ?? "").trim();
    const cat = state.categories.get(catId);
    const categoryName = cat?.name ?? "";

    const personalWalletId = state.walletId;
    const shouldSyncToCouple = isPersonalWalletId(personalWalletId);

    btnAddTxn.disabled = true;
    btnAddTxn.textContent = "Salvando...";

    try {
      const dt = new Date(dateStr + "T00:00:00");
      const ts = Timestamp.fromDate(dt);
      const yyyyMM = yyyyMMFromDateStr(dateStr);

      const personalCol = collection(db, "wallets", personalWalletId, "transactions");
      const newRef = doc(personalCol); // gera ID já

      const txnPayload = {
        date: ts,
        amountCents,
        type,
        categoryId: catId,
        categoryName,
        note,
        createdAt: serverTimestamp(),
        createdBy: state.uid
      };

      const viewId = `${personalWalletId}_${newRef.id}`;
      const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", viewId);

      const reportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", yyyyMM);

      await runTransaction(db, async (tx) => {
        // ===== READS FIRST =====
        let repSnap = null;
        let repData = null;
        let repExists = false;

        if (shouldSyncToCouple) {
          repSnap = await tx.get(reportRef);
          repExists = repSnap.exists();
          repData = repExists ? repSnap.data() : null;
        }

        // ===== WRITES AFTER READS =====
        tx.set(newRef, txnPayload);

        if (shouldSyncToCouple) {
          tx.set(viewRef, {
            sourceWalletId: personalWalletId,
            sourceTxnId: newRef.id,
            sourceUid: state.uid,
            date: ts,
            amountCents,
            type,
            categoryId: catId,
            categoryName,
            note,
            syncedAt: serverTimestamp()
          }, { merge: true });

          const deltaIncome = (type === "income") ? amountCents : 0;
          const deltaExpense = (type === "expense") ? amountCents : 0;

          const { nextIncome, nextExpense } = computeCoupleSourceNext(repData, personalWalletId, deltaIncome, deltaExpense);

          const reportPatch = {
            month: yyyyMM,
            updatedAt: serverTimestamp(),
            updatedBy: state.uid,
            sources: {
              [personalWalletId]: {
                incomeCents: nextIncome,
                expenseCents: nextExpense,
                updatedAt: serverTimestamp(),
                updatedBy: state.uid
              }
            }
          };

          const mergeFields = ["month", "updatedAt", "updatedBy", `sources.${personalWalletId}`];

          // só cria createdAt/createdBy se ainda não existe
          if (!repExists) {
            reportPatch.createdAt = serverTimestamp();
            reportPatch.createdBy = state.uid;
            mergeFields.push("createdAt", "createdBy");
          }

          tx.set(reportRef, reportPatch, { mergeFields });
        }
      });

      txnAmount.value = "";
      txnNote.value = "";

      await reloadAll();
    } catch (e) {
      setOpsError(`Erro ao adicionar transação: ${e?.message ?? e}`);
    } finally {
      btnAddTxn.disabled = false;
      btnAddTxn.textContent = "Adicionar";
    }
  }

  async function deleteTransactionPersonalAndSync(txnId) {
    setOpsError("");

    const personalWalletId = state.walletId;
    if (!isPersonalWalletId(personalWalletId)) {
      setOpsError("Exclusão com auto-sync só é aplicável em wallets pessoais.");
      return;
    }

    const personalTxnRef = doc(db, "wallets", personalWalletId, "transactions", txnId);
    const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${personalWalletId}_${txnId}`);

    try {
      await runTransaction(db, async (tx) => {
        // ===== READS FIRST =====
        const txnSnap = await tx.get(personalTxnRef);
        if (!txnSnap.exists()) return;

        const t = txnSnap.data();
        const amount = Number(t.amountCents || 0);
        const type = t.type ?? "expense";
        const yyyyMM = yyyyMMFromTimestamp(t.date);

        const reportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", yyyyMM);
        const repSnap = await tx.get(reportRef);
        const repExists = repSnap.exists();
        const repData = repExists ? repSnap.data() : null;

        // ===== WRITES AFTER READS =====
        tx.delete(personalTxnRef);
        tx.delete(viewRef);

        // atualiza totals do casal (decremento)
        const deltaIncome = (type === "income") ? -amount : 0;
        const deltaExpense = (type === "expense") ? -amount : 0;

        const { nextIncome, nextExpense } = computeCoupleSourceNext(repData, personalWalletId, deltaIncome, deltaExpense);

        const reportPatch = {
          month: yyyyMM,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid,
          sources: {
            [personalWalletId]: {
              incomeCents: nextIncome,
              expenseCents: nextExpense,
              updatedAt: serverTimestamp(),
              updatedBy: state.uid
            }
          }
        };

        const mergeFields = ["month", "updatedAt", "updatedBy", `sources.${personalWalletId}`];

        // se report não existia (situação rara), cria sem quebrar
        if (!repExists) {
          reportPatch.createdAt = serverTimestamp();
          reportPatch.createdBy = state.uid;
          mergeFields.push("createdAt", "createdBy");
        }

        tx.set(reportRef, reportPatch, { mergeFields });
      });

      await reloadAll();
    } catch (e) {
      setOpsError(`Erro ao excluir transação: ${e?.message ?? e}`);
    }
  }

  async function updateTransactionPersonalAndSync() {
    editError.textContent = "";
    editStatus.textContent = "";

    if (!state.editingTxnId) { editError.textContent = "Nenhuma transação selecionada."; return; }
    if (!isPersonalWalletId(state.walletId)) { editError.textContent = "Edição só é permitida em wallets pessoais."; return; }

    const txnId = state.editingTxnId;
    const dateStr = editTxnDate.value;
    const type = editTxnType.value;
    const catId = editTxnCat.value;
    const amountCents = parseAmountToCents(editTxnAmount.value);
    const note = (editTxnNote.value ?? "").trim();

    if (!dateStr) { editError.textContent = "Informe a data."; return; }
    if (!catId) { editError.textContent = "Selecione uma categoria."; return; }
    if (amountCents == null || amountCents <= 0) { editError.textContent = "Informe um valor válido (maior que zero)."; return; }

    const cat = state.categories.get(catId);
    const categoryName = cat?.name ?? (editTxnCat.options[editTxnCat.selectedIndex]?.textContent ?? "");

    const personalWalletId = state.walletId;
    const shouldSyncToCouple = isPersonalWalletId(personalWalletId);

    btnSaveEdit.disabled = true;
    btnSaveEdit.textContent = "Salvando...";

    try {
      const dt = new Date(dateStr + "T00:00:00");
      const ts = Timestamp.fromDate(dt);
      const newMonth = yyyyMMFromDateStr(dateStr);
      if (!newMonth) throw new Error("Data inválida.");

      const personalTxnRef = doc(db, "wallets", personalWalletId, "transactions", txnId);
      const viewRef = doc(db, "wallets", COUPLE_WALLET_ID, "transactions_view", `${personalWalletId}_${txnId}`);

      await runTransaction(db, async (tx) => {
        const txnSnap = await tx.get(personalTxnRef);
        if (!txnSnap.exists()) throw new Error("Transação não encontrada.");

        const existing = txnSnap.data();
        const oldAmount = Number(existing.amountCents || 0);
        const oldType = existing.type ?? "expense";
        const oldMonth = yyyyMMFromTimestamp(existing.date);
        if (!oldMonth) throw new Error("Data atual inválida na transação existente.");

        let oldRepSnap = null;
        let newRepSnap = null;
        let oldReportRef = null;
        let newReportRef = null;

        if (shouldSyncToCouple) {
          oldReportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", oldMonth);
          oldRepSnap = await tx.get(oldReportRef);

          if (newMonth === oldMonth) {
            newReportRef = oldReportRef;
            newRepSnap = oldRepSnap;
          } else {
            newReportRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", newMonth);
            newRepSnap = await tx.get(newReportRef);
          }
        }

        tx.update(personalTxnRef, {
          date: ts,
          amountCents,
          type,
          categoryId: catId,
          categoryName,
          note,
          updatedAt: serverTimestamp(),
          updatedBy: state.uid
        });

        if (shouldSyncToCouple) {
          tx.set(viewRef, {
            sourceWalletId: personalWalletId,
            sourceTxnId: txnId,
            sourceUid: existing.sourceUid || state.uid,
            date: ts,
            amountCents,
            type,
            categoryId: catId,
            categoryName,
            note,
            syncedAt: serverTimestamp()
          }, { merge: true });

          const oldIncome = oldType === "income" ? oldAmount : 0;
          const oldExpense = oldType === "expense" ? oldAmount : 0;
          const newIncome = type === "income" ? amountCents : 0;
          const newExpense = type === "expense" ? amountCents : 0;

          const applyReportUpdate = (repRef, repSnap, deltaIncome, deltaExpense) => {
            const repExists = repSnap?.exists?.() ?? false;
            const repData = repExists ? repSnap.data() : null;

            const { nextIncome, nextExpense } = computeCoupleSourceNext(repData, personalWalletId, deltaIncome, deltaExpense);

            const patch = {
              month: repRef.id,
              updatedAt: serverTimestamp(),
              updatedBy: state.uid,
              sources: {
                [personalWalletId]: {
                  incomeCents: nextIncome,
                  expenseCents: nextExpense,
                  updatedAt: serverTimestamp(),
                  updatedBy: state.uid
                }
              }
            };

            const mergeFields = ["month", "updatedAt", "updatedBy", `sources.${personalWalletId}`];

            if (!repExists) {
              patch.createdAt = serverTimestamp();
              patch.createdBy = state.uid;
              mergeFields.push("createdAt", "createdBy");
            }

            tx.set(repRef, patch, { mergeFields });
          };

          if (newMonth === oldMonth) {
            applyReportUpdate(oldReportRef, oldRepSnap, newIncome - oldIncome, newExpense - oldExpense);
          } else {
            applyReportUpdate(oldReportRef, oldRepSnap, -oldIncome, -oldExpense);
            applyReportUpdate(newReportRef, newRepSnap, newIncome, newExpense);
          }
        }
      });

      editStatus.textContent = "Transação atualizada.";
      closeEditModal();
      await reloadAll();
    } catch (e) {
      editError.textContent = e?.message ?? String(e);
    } finally {
      btnSaveEdit.disabled = false;
      btnSaveEdit.textContent = "Salvar alterações";
    }
  }

  // ===== Transactions list / Couple views =====

  function renderTxnRows(rows, { allowDelete, isCoupleView, allowEdit }) {
    txnTable.innerHTML = "";

    for (const r of rows) {
      const dt = r.date ? toISODateLocal(r.date) : "-";
      const display = toBRL(Math.abs(r.amountCents));
      const prefix = (r.type === "income") ? "+" : "-";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(dt)}</td>
        <td>${escapeHtml(r.categoryName || "-")}</td>
        <td>${escapeHtml(r.note || "")}${isCoupleView ? `<div class="muted mono" style="margin-top:4px;">${escapeHtml(r.sourceLabel || "")}</div>` : ""}</td>
        <td class="right nowrap">${prefix} ${escapeHtml(display)}</td>
        <td class="right nowrap">
          ${allowEdit ? `<button class="ghost" data-edit-txn="${r.id}">Editar</button>` : ""}
          ${allowDelete ? `<button class="ghost" data-del-txn="${r.id}" style="margin-left:6px;">Excluir</button>` : `<span class="muted">—</span>`}
        </td>
      `;
      txnTable.appendChild(tr);
    }

    if (allowDelete) {
      txnTable.querySelectorAll("button[data-del-txn]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-del-txn");
          if (!confirm("Excluir esta transação? (Isso também removerá do Casal automaticamente)")) return;
          await deleteTransactionPersonalAndSync(id);
        });
      });
    }

    if (allowEdit) {
      txnTable.querySelectorAll("button[data-edit-txn]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-edit-txn");
          await prepareEditModal(id);
        });
      });
    }
  }

  async function loadCoupleTotals(yyyyMM) {
    coupleBreakdown.style.display = "";
    coupleBreakdown.innerHTML = "";

    let income = 0;
    let expense = 0;

    try {
      const repRef = doc(db, "wallets", COUPLE_WALLET_ID, "reports", yyyyMM);
      const repSnap = await getDoc(repRef);

      if (!repSnap.exists()) {
        coupleBreakdown.innerHTML = `<p class="muted">Sem relatório para ${escapeHtml(yyyyMM)}. Adicione transações nas wallets pessoais para gerar automaticamente.</p>`;
        return { income: 0, expense: 0, balance: 0 };
      }

      const rep = repSnap.data();
      const sources = rep.sources ?? {};

      const lines = [];
      for (const [sourceWalletId, s] of Object.entries(sources)) {
        const inc = Number(s?.incomeCents || 0);
        const exp = Number(s?.expenseCents || 0);
        income += inc;
        expense += exp;

        lines.push(`
          <div class="kpi" style="margin-top:8px;">
            <div class="label">${escapeHtml(sourceWalletId)}</div>
            <div class="value">${toBRL(inc - exp)}</div>
            <div class="muted">Receitas: ${toBRL(inc)} | Despesas: ${toBRL(exp)}</div>
          </div>
        `);
      }

      coupleBreakdown.innerHTML = lines.length
        ? `<div class="muted">Quebra por fonte (somado no total acima):</div>${lines.join("")}`
        : `<p class="muted">Relatório existe, mas sem fontes preenchidas.</p>`;

      return { income, expense, balance: income - expense };
    } catch (e) {
      setOpsError(`Erro ao ler reports do casal: ${e?.message ?? e}`);
      coupleBreakdown.innerHTML = `<p class="err">${escapeHtml(e?.message ?? String(e))}</p>`;
      return { income: 0, expense: 0, balance: 0 };
    }
  }

  async function loadCoupleDetails(startTS, endTS) {
    try {
      const qRef = query(
        collection(db, "wallets", COUPLE_WALLET_ID, "transactions_view"),
        where("date", ">=", startTS),
        where("date", "<", endTS),
        orderBy("date", "desc")
      );

      const snaps = await getDocs(qRef);
      const rows = [];
      let income = 0, expense = 0;

      for (const d of snaps.docs) {
        const t = d.data();
        const amount = Number(t.amountCents || 0);
        if (t.type === "income") income += amount;
        else expense += amount;

        rows.push({
          id: d.id,
          date: t.date?.toDate?.() ?? null,
          categoryName: t.categoryName ?? "",
          note: t.note ?? "",
          type: t.type ?? "",
          amountCents: amount,
          sourceLabel: t.sourceWalletId ? `fonte: ${t.sourceWalletId}` : ""
        });
      }

      renderTxnRows(rows, { allowDelete: false, isCoupleView: true, allowEdit: false });
      coupleBreakdown.style.display = "none";

      return { income, expense, balance: income - expense };
    } catch (e) {
      setOpsError(`Erro ao carregar detalhes do casal: ${e?.message ?? e}`);
      txnTable.innerHTML = "";
      return { income: 0, expense: 0, balance: 0 };
    }
  }

  async function loadTransactionsForMonth() {
    txnTable.innerHTML = "";
    txnStatus.textContent = "";
    setOpsError("");
    state.txnCache = new Map();

    const yyyyMM = yyyyMMFromMonthInput(monthInput.value);
    if (!yyyyMM) { setOpsError("Selecione um mês válido."); return { income: 0, expense: 0, balance: 0 }; }

    const { start, end } = startEndForMonth(yyyyMM);
    const startTS = Timestamp.fromDate(start);
    const endTS = Timestamp.fromDate(end);

    if (isCoupleWallet()) {
      if (state.coupleTab === "totals") {
        const totals = await loadCoupleTotals(yyyyMM);
        renderKPIs(totals.income, totals.expense);
        txnStatus.textContent = "Totais carregados via reports (auto-sync).";
        return totals;
      } else {
        const totals = await loadCoupleDetails(startTS, endTS);
        renderKPIs(totals.income, totals.expense);
        txnStatus.textContent = "Detalhes carregados via transactions_view (auto-sync).";
        return totals;
      }
    }

    let income = 0;
    let expense = 0;

    try {
      const qRef = query(
        collection(db, "wallets", state.walletId, "transactions"),
        where("date", ">=", startTS),
        where("date", "<", endTS),
        orderBy("date", "desc")
      );

      const snaps = await getDocs(qRef);
      const rows = [];

      for (const d of snaps.docs) {
        const t = d.data();
        const amount = Number(t.amountCents || 0);
        if (t.type === "income") income += amount;
        else expense += amount;

        rows.push({
          id: d.id,
          date: t.date?.toDate?.() ?? null,
          categoryName: t.categoryName ?? "",
          note: t.note ?? "",
          type: t.type ?? "",
          amountCents: amount,
          categoryId: t.categoryId ?? ""
        });

        state.txnCache.set(d.id, {
          id: d.id,
          date: t.date?.toDate?.() ?? null,
          categoryName: t.categoryName ?? "",
          categoryId: t.categoryId ?? "",
          note: t.note ?? "",
          type: t.type ?? "",
          amountCents: amount
        });
      }

      renderTxnRows(rows, { allowDelete: true, isCoupleView: false, allowEdit: true });
      txnStatus.textContent = `Transações no mês: ${rows.length}`;
      renderKPIs(income, expense);

      return { income, expense, balance: income - expense };
    } catch (e) {
      setOpsError(`Erro ao carregar transações: ${e?.message ?? e}`);
      renderKPIs(0, 0);
      return { income: 0, expense: 0, balance: 0 };
    }
  }

  async function reloadAll() {
    setOpsError("");
    if (!isCoupleWallet()) await loadCategories();
    else {
      state.categories.clear();
      txnCat.innerHTML = `<option value="">—</option>`;
      catTable.innerHTML = "";
      catStatus.textContent = "Categorias: N/A na visão agregada.";
    }
    await loadTransactionsForMonth();
  }

  // ===== Events =====

  btnEmail.addEventListener("click", async () => {
    try {
      setAuthMessage("Entrando...");
      const email = $("email").value.trim().toLowerCase();
      const pass = $("pass").value;

      if (!ALLOWED_EMAILS.has(email)) throw new Error("Este e-mail não está autorizado no VaultFlow-Dev.");

      await signInWithEmailAndPassword(auth, email, pass);
      setAuthMessage("Login OK.");
    } catch (e) {
      setAuthMessage(e?.message ?? String(e), true);
    }
  });

  btnGoogle.addEventListener("click", async () => {
    try {
      setAuthMessage("Abrindo Google...");
      const provider = new GoogleAuthProvider();
      const result = await signInWithPopup(auth, provider);
      const email = (result.user.email ?? "").toLowerCase();

      if (!ALLOWED_EMAILS.has(email)) {
        await signOut(auth);
        throw new Error("Conta Google não autorizada no VaultFlow-Dev.");
      }

      setAuthMessage("Login Google OK.");
    } catch (e) {
      setAuthMessage(e?.message ?? String(e), true);
    }
  });

  btnLogout.addEventListener("click", async () => {
    await signOut(auth);
  });

  btnReload.addEventListener("click", reloadAll);
  walletSelect.addEventListener("change", refreshWalletContext);
  monthInput.addEventListener("change", reloadAll);

  btnAddCat.addEventListener("click", addCategory);
  btnSeedCats.addEventListener("click", seedDefaultCategories);
  btnAddTxn.addEventListener("click", addTransaction);
  btnRunDiag.addEventListener("click", async () => {
    diagActionStatus.textContent = "Reavaliando...";
    await runDiagnostics();
  });
  btnReconcile.addEventListener("click", reconcileMembershipsFromMembers);

  btnCloseEdit.addEventListener("click", () => { closeEditModal(); });
  editModal.addEventListener("click", (e) => {
    if (e.target === editModal) closeEditModal();
  });
  btnSaveEdit.addEventListener("click", updateTransactionPersonalAndSync);

  coupleTabs.addEventListener("click", async (e) => {
    const btn = e.target?.closest?.("button[data-tab]");
    if (!btn) return;

    coupleTabs.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
    btn.classList.add("active");

    state.coupleTab = btn.getAttribute("data-tab") || "totals";
    await reloadAll();
  });

  (function initDates() {
    const now = new Date();
    const mm = String(now.getMonth() + 1).padStart(2, "0");
    monthInput.value = `${now.getFullYear()}-${mm}`;
    txnDate.value = toISODateLocal(now);
  })();

  onAuthStateChanged(auth, async (user) => {
    try {
      setAuthMessage("");
      setAppError("");
      setOpsError("");

      if (!user) {
        btnLogout.style.display = "none";
        appGrid.style.display = "none";
        return;
      }

      const email = (user.email ?? "").toLowerCase();
      if (!ALLOWED_EMAILS.has(email)) {
        await signOut(auth);
        throw new Error("Usuário autenticado, mas não autorizado (allowlist).");
      }

      state.user = user;
      state.email = email;
      state.uid = user.uid;

      btnLogout.style.display = "";
      appGrid.style.display = "";

      me.textContent = `${user.email}`;
      uidLine.textContent = `uid: ${user.uid}`;

      await ensureUserProfile(user);
      await ensureWalletMetaIfOwner(user);
      await ensureMembershipShortcutsFromMembers(user);

      const wallets = await loadWalletOptions(user);
      if (!walletSelect.value && wallets.length > 0) walletSelect.value = wallets[0].walletId;

      await refreshWalletContext();

      setAuthMessage("Sessão ativa.");
    } catch (e) {
      setAppError(e?.message ?? String(e));
    }
  });
</script>

</body>
</html>
